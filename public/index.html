<!DOCTYPE html>












  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">


























<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.0.1">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.0.1">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.0.1">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.0.1">


  <link rel="mask-icon" href="/images/logo.svg?v=7.0.1" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '7.0.1',
    sidebar: {"position":"right","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="伪化生的小窝">
<meta property="og:type" content="website">
<meta property="og:title" content="Ionizing&#39;s Blog">
<meta property="og:url" content="https://ionizing.science/index.html">
<meta property="og:site_name" content="Ionizing&#39;s Blog">
<meta property="og:description" content="伪化生的小窝">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Ionizing&#39;s Blog">
<meta name="twitter:description" content="伪化生的小窝">






  <link rel="canonical" href="https://ionizing.science/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Ionizing's Blog</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-right 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Ionizing's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">Challenge Everything</p>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home menu-item-active">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>Home</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>About</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>Tags</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>Categories</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>Archives</a>

  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://ionizing.science/2019/01/25/how-to-solve-matrix-B-in-A-times-B-equals-C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ionizing Radiation">
      <meta itemprop="description" content="伪化生的小窝">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ionizing's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/01/25/how-to-solve-matrix-B-in-A-times-B-equals-C/" class="post-title-link" itemprop="url">如何求解 A * B = C 中的矩阵 B ？</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-01-25 23:44:50" itemprop="dateCreated datePublished" datetime="2019-01-25T23:44:50+08:00">2019-01-25</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-01-26 00:19:11" itemprop="dateModified" datetime="2019-01-26T00:19:11+08:00">2019-01-26</time>
              
            
          </span>

          

          
            
            
          

          
          
            <span id="/2019/01/25/how-to-solve-matrix-B-in-A-times-B-equals-C/" class="leancloud_visitors" data-flag-title="如何求解 A * B = C 中的矩阵 B ？">
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              
                <span class="post-meta-item-text">Views: </span>
              
                <span class="leancloud-visitors-count"></span>
            </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>给定一个矩阵方程<br>$$<br>\mathbf{A} \times \mathbf{B} = \mathbf{C}<br>$$<br>其中 $\mathbf{B}$ 是方阵， $\mathbf{A}$  和 $\mathbf{C}$ 的形状相同，问如何求解 $\mathbf{B}$ ?</p>
<h1 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h1><p>$\mathbf{A}$ 和 $\mathbf{C}$ 的形状相同，如果它们都是方阵，则<br>$$<br>\begin{align}<br>\mathbf{A} \times \mathbf{B} ={}&amp; \mathbf{C} \<br>\mathbf{A}^{-1} \times \mathbf{A} \times \mathbf{B} ={}&amp; \mathbf{A}^{-1} \times \mathbf{C} \<br>\mathbf{B} ={}&amp; \mathbf{A}^{-1} \times \mathbf{C} \label{eq:easy}<br>\end{align}<br>$$</p>
<p>但 $\mathbf{A}$ 和 $\mathbf{C}$ 未必是方阵，所以不存在逆矩阵，也就无法通过等式左右同时左乘 $\mathbf{A}^{-1}$ 的方法直接求出 $\mathbf{B}$ 。那么此时如何求解 $\mathbf{B}$ 呢？</p>
<p>既然 $\mathbf{A}$ 和 $\mathbf{C}$ 不是方阵，那么把它们变换成方阵不就好了吗？因此等式左右共同左乘 $\mathbf{A}^{T}$ ，即可将 $\mathbf{A}$ 和 $\mathbf{C}$ 变换成方阵，即<br>$$<br>\begin{align}<br>\mathbf{A}<em>{m\times n} \times \mathbf{B}</em>{n\times n} ={}&amp; \mathbf{C}<em>{m\times n} \<br>\mathbf{A}^{T}</em>{n\times m} \times \mathbf{A}<em>{m\times n} \times \mathbf{B}</em>{n\times n} ={}&amp; \mathbf{A}^{T}<em>{n\times m} \times  \mathbf{C}</em>{m\times n} \<br>\mathbf{A}’<em>{n\times n} \mathbf{B}</em>{n\times n} ={}&amp; \mathbf{C}’_{n\times n} \label{eq:difficult}<br>\end{align}<br>$$<br>$\eqref{eq:difficult}$ 即是我们熟悉的形式，直接使用 $\eqref{eq:easy}$ 的解法即可解得 $\mathbf{B}$ 。 </p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://ionizing.science/2019/01/21/2019-1-21-how-to-setup-travis-ci/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ionizing Radiation">
      <meta itemprop="description" content="伪化生的小窝">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ionizing's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/01/21/2019-1-21-how-to-setup-travis-ci/" class="post-title-link" itemprop="url">如何为 github 上的 cpp 项目设置 Travis-CI 自动测试</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-01-21 11:32:17 / Modified: 12:03:13" itemprop="dateCreated datePublished" datetime="2019-01-21T11:32:17+08:00">2019-01-21</time>
            

            
              

              
            
          </span>

          

          
            
            
          

          
          
            <span id="/2019/01/21/2019-1-21-how-to-setup-travis-ci/" class="leancloud_visitors" data-flag-title="如何为 github 上的 cpp 项目设置 Travis-CI 自动测试">
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              
                <span class="post-meta-item-text">Views: </span>
              
                <span class="leancloud-visitors-count"></span>
            </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Travis-CI 是一个持续集成测试网站，其 org 版对用户免费开放，对用户的 public 仓库可以免费提供 持续集成测试服务（私有仓库要使用 com 版）</p>
<h1 id="设置步骤"><a href="#设置步骤" class="headerlink" title="设置步骤"></a>设置步骤</h1><ol>
<li>访问 <a href="https://travis-ci.org" target="_blank" rel="noopener"></a> 并使自己的 github 账户与 travis-ci 关联，并给予它足够的权限 （一路下一步就行）；</li>
<li>点击右上角的用户头像，进入自己的 repositories 配置面板，找到自己想要开启集成测试的项目， 开启集成测试功能；</li>
<li>进入刚刚项目集成测试的 settings ，在页面最下面的 Cron Jobs 一栏设置自己想要的定时测试任务 配置；</li>
<li>在<strong>本地</strong>该仓库的根目录下写好 <code>Makefile</code> ；</li>
<li><p>在<strong>本地</strong>该仓库的根目录下创建 <code>.travis.yml</code> ，里面写上如下内容：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">language:</span> <span class="string">cpp</span>     <span class="comment"># 指定项目语言类型</span></span><br><span class="line"><span class="attr">dist:</span> <span class="string">trusty</span></span><br><span class="line"><span class="attr">sudo:</span> <span class="literal">false</span>       <span class="comment"># 是否需要 sudo 权限</span></span><br><span class="line"><span class="attr">matrix:</span>           <span class="comment"># 配置 travis-ci 系统变量</span></span><br><span class="line"><span class="attr">  include:</span></span><br><span class="line"><span class="attr">    - os:</span> <span class="string">linux</span>   <span class="comment"># 指定构建环境的系统类型</span></span><br><span class="line"><span class="attr">    - compiler:</span> <span class="string">gcc</span>  <span class="comment"># 指定编译器</span></span><br><span class="line"></span><br><span class="line"><span class="attr">addons:</span>           <span class="comment"># 第三方依赖库的添加</span></span><br><span class="line"><span class="attr">  apt:</span></span><br><span class="line"><span class="attr">    packages:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">libfftw*</span></span><br><span class="line"></span><br><span class="line"><span class="attr">script:</span>           <span class="comment"># 构建的命令，默认为 ./configure &amp;&amp; make</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">make</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>git push</p>
</li>
</ol>
<p>然后 Travis-CI 应该就开始进行构建了，在构建的页面上还有构建状态的 badge ，可以放到 github 的 <code>README.md</code> 上标注构建状态 = =</p>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>Travis-CI 还有很多功能没有用到，不过对于现在我的 repo 已经完全够用了。</p>
<p>GitHub 都已经开通了免费的 private repo ，travis-ci 什么时候也能开通免费版的 private plan 呢？</p>
<p>参考来源: <a href="https://blog.csdn.net/u012348774/article/details/78663381" target="_blank" rel="noopener">https://blog.csdn.net/u012348774/article/details/78663381</a></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://ionizing.science/2018/12/31/2018-12-31_WAVECAR-parsing/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ionizing Radiation">
      <meta itemprop="description" content="伪化生的小窝">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ionizing's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/12/31/2018-12-31_WAVECAR-parsing/" class="post-title-link" itemprop="url">WAVECAR 数据结构的解析</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2018-12-31 20:16:24" itemprop="dateCreated datePublished" datetime="2018-12-31T20:16:24+08:00">2018-12-31</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-01-16 19:19:49" itemprop="dateModified" datetime="2019-01-16T19:19:49+08:00">2019-01-16</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/First-Principle/" itemprop="url" rel="index"><span itemprop="name">First Principle</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          
            <span id="/2018/12/31/2018-12-31_WAVECAR-parsing/" class="leancloud_visitors" data-flag-title="WAVECAR 数据结构的解析">
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              
                <span class="post-meta-item-text">Views: </span>
              
                <span class="leancloud-visitors-count"></span>
            </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>我们知道，WAVECAR 是 VASP 计算完成后输出的一个二进制文件，它包含的信息用普通的文本编辑器不能直接查看。但有时一些拥有好奇心的人总想看看它里面到底储存了什么东东，于是闲得 X 疼的本人就本着生命不息、折腾不止的态度研究了一下 WAVECAR 的数据结构，终于写出了一个能解析 WAVECAR 的小程序，于是有了这篇博客。</p>
<h1 id="WAVECAR-的基本结构"><a href="#WAVECAR-的基本结构" class="headerlink" title="WAVECAR 的基本结构"></a>WAVECAR 的基本结构</h1><p><code>WAVECAR</code> 本身是由多个等长的记录 (record) 组成的，没有特殊说明的情况下，<code>WAVECAR</code> 中大部分数据的存储类型为<code>double</code>(64-bit)，即使是整数也会被转换为双精度浮点数存储。</p>
<figure class="highlight bash"><figcaption><span>WAVECAR的基本结构</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> ---------------------------------------------</span><br><span class="line">|info    |header  |body   |body    | ....</span><br><span class="line"> ---------------------------------------------</span><br></pre></td></tr></table></figure>
<p>下面我们从源码的角度分析一下 VASP 在读写 <code>WAVECAR</code> 时都发生了哪些操作。</p>
<h1 id="读写-WAVECAR-的函数"><a href="#读写-WAVECAR-的函数" class="headerlink" title="读写 WAVECAR 的函数"></a>读写 WAVECAR 的函数</h1><p>与文件读写有关的操作有一些定义在源码的 <code>fileio.F</code> 中（本渣读的是 VASP 5.4.1 的源码，但这种很基础的函数在版本更新时应该不会有太大变动吧），其中读写 WAVECAR 的函数有：</p>
<ul>
<li><code>OPENWAV(IO, COM, EXT)</code></li>
<li><code>CLOSEWAV</code></li>
<li><code>READ_TO_BUF(IU, IREC, IRECL_REAL, INBUF, IFAIL)</code></li>
<li><code>WRITE_FROM_BUF(IU, IREC, IRECL_REAL, OUTBUF)</code></li>
<li><code>INWAV_HEAD(WDES, LATT_INI, LATT_CUR, ENMAXI, ISTART, IU0)</code></li>
<li><code>INWAV_FAST(IO, WDES, W, GRID, LATT_CUR, LATT_INI, ISTART, EFERMI)</code></li>
<li><del><code>INWAV_ALTERNATIVE(IO, WDES, W, GRID, LATT_CUR, LREAD, EXT)</code></del></li>
<li><code>OUTWAV_4(IO, WDES, W, LATT_INI, EXT)</code></li>
<li><code>OUTWAV(IO, WDES, W, LATT_INI, EFERMI, EXT)</code></li>
</ul>
<p>上面<code>OPENWAV</code>, <code>CLOSEWAV</code>, 分别是打开文件操作句柄同时确定写入的一些参数和关闭文件操作句柄，对应 C++ 里面的 <code>fstream::open()</code> 和 <code>fstream::close()</code> 操作；</p>
<h2 id="READ-TO-BUF-和-WRITE-FROM-BUF"><a href="#READ-TO-BUF-和-WRITE-FROM-BUF" class="headerlink" title="READ_TO_BUF 和 WRITE_FROM_BUF"></a><code>READ_TO_BUF</code> 和 <code>WRITE_FROM_BUF</code></h2><p>顾名思义，它们执行的是一个读取和写入一个 <strong>buffer</strong> 到文件的操作（对于相同的数据量一次性读写大量数据比多次读写，每次读写少量的数据效率更高）。函数参数中的 <code>*BUF</code> 就是读写用到的 <code>buffer</code>，由于 Fortran 语言的特性，它的函数传参默认为传引用，所以 <code>READ_TO_BUF</code> 函数执行完毕后数据已经放到了 <code>INBUF</code> 中了，这一点对从 C 系语言入门的本渣来说很不习惯。函数的 <code>IREC</code> 和 <code>IRECL_REAL</code> 分别表示 <code>WAVECAR</code> 中记录的位置和 <code>real(q)</code> 的数据在内存中占的大小。 <code>IU</code> 参数在本函数中没有作用（目测作者是想将文件指针作为参数传进来，但最后因为某种原因放弃了，现在 VASP 中 <code>WAVECAR</code> 的 <code>unit</code> 已经写死了，为 <code>12</code>）。</p>
<ul>
<li><code>IU</code>: 文件操作结构，此处无作用；</li>
<li><code>IREC</code>：此次读取/写入 <code>buffer</code> 的记录的编号；</li>
<li><code>IRECL_REAL</code>：此次读取/写入 <code>buffer</code> 中 <code>real(q)</code> 的长度；</li>
<li><code>*BUF</code>：读取、写入的 <code>buffer</code> ，是一个一维数组；</li>
<li><code>IFAIL</code>：读取时是否失败的标志。</li>
</ul>
<h2 id="INWAV-HEAD"><a href="#INWAV-HEAD" class="headerlink" title="INWAV_HEAD"></a><code>INWAV_HEAD</code></h2><p>这个函数读取 <code>WAVECAR</code> 的 header 部分，即 <code>WAVECAR</code> 中第<strong>二</strong>个记录的前 12 个<code>double</code> 型的值。这 12 个值按照顺序分别表示：</p>
<ul>
<li><code>_nKpoints</code>: 体系取了多少个 K 点，转换为 <code>int</code> 型；</li>
<li><code>_nBands</code>: 体系中有多少条能带，转换为 <code>int</code> 型；</li>
<li><code>_enCut</code>: 体系的截断能，无需转换；</li>
<li><code>_latticeVectors</code>: 接下来的⑨个 <code>double</code> 值构成了一个矩阵，它们表示体系在实空间中的格矢，按照行优先的顺序分别存放，无需转换；</li>
<li><code>_eFermi</code>: 体系的费米能级（在早期版本的 VASP 不会写入这个值）</li>
</ul>
<p>事实上，这个函数还做了一些检查，比如用户提供的 <code>NBAND</code> 、 <code>NKPOINTS</code> 是否与 <code>WAVECAR</code> 中对应值一致等，由于现在这些都不重要，我们暂时略过。</p>
<ul>
<li><code>WDES</code>: <code>WAVECAR</code> 的描述结构，包含了波函数的一些初步描述信息；</li>
<li><code>LATT_INI</code>: 从 <code>WAVECAR</code> 读取的格子结构；</li>
<li><code>LATT_CUR</code>: 从 <code>POSCAR</code> 读取的格子结构，程序会对 <code>LATT_INI</code> 和 <code>LATT_CUR</code> 作 diff 操作，如果两者有差别，则给出警告；</li>
<li><code>ENMAXI</code>: 从 <code>WAVECAR</code> 中读取的截断能（<code>ENCUT</code>）；</li>
<li><code>ISTART</code>: 是否为从头算，即是否舍弃 <code>WAVECAR</code> 重新计算波函数，手册中有详细说明；</li>
<li><code>IU0</code>: 文件句柄，各种错误信息、警告信息都将从这个句柄输出。</li>
</ul>
<p><del>### <code>INWAV_ALTERNATIVE</code><br>这个函数很迷，它只在 <code>chi.F</code> 中有调用，并且是在 <code>LGW0 == true</code> 时才调用，并且实质上只是调用了 <code>INWAV_HEAD</code> 和一些输出警告、帮助的函数，在 <code>chi.F</code> 中在对它的调用后面还有一些其他的读写函数，个人认为 <code>INWAV_ALTERNATIVE</code> 是在执行特殊计算任务时读取 <code>WAVECAR</code> 的函数，它与我们解析 <code>WAVECAR</code> 的任务关系不大。</del></p>
<h2 id="INWAV-FAST"><a href="#INWAV-FAST" class="headerlink" title="INWAV_FAST"></a><code>INWAV_FAST</code></h2><p>这个函数是读取 <code>WAVECAR</code> 的 <strong>主要函数</strong> 。</p>
<p>它首先读取 <code>WAVECAR</code> 的开头部分，获得以下三个值： </p>
<ul>
<li><code>_recordLength</code>: <code>WAVECAR</code> 中每个记录的长度，应转换为 <code>int</code> 类型；</li>
<li><code>_nSpin</code>: <code>WAVECAR</code> 中是否开启自旋，如果开启自旋，则上下两个自旋的波函数等将分别存放，应转换为 <code>int</code> 类型；</li>
<li><code>_precisionTag</code>: <code>WAVECAR</code> 中平面波系数的精度标签，它决定了平面系数是使用 <code>complex&lt;float&gt;</code> 存储还是 <code>complex&lt;double&gt;</code> 来存储。这个标签应转换为 <code>int</code> 类型；</li>
</ul>
<p>然后调用 <code>INWAV_HEAD</code> 获得体系的 header 信息。</p>
<p>最后，它将文件指针定位到第<strong>三</strong>个记录，并开始读取体系的能带、K 点的波函数信息。</p>
<p>从第三个记录开始，<code>WAVECAR</code> 的数据结构如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> ispin=<span class="number">0</span>; i!=_nSpin; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> ikpoint=<span class="number">0</span>; ikpoint!=_nKpoint; ++ikpoint) &#123;</span><br><span class="line">        <span class="comment">// one record here.	        (1)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> iband=<span class="number">0</span>; iband!=_nBand; ++iband) &#123;</span><br><span class="line">            <span class="comment">// one record here.	    (2)</span></span><br><span class="line">        &#125; <span class="comment">// end for iband</span></span><br><span class="line">    &#125; <span class="comment">// end for ikpoint</span></span><br><span class="line">&#125; <span class="comment">// end for ispin</span></span><br></pre></td></tr></table></figure></p>
<p>其中 <code>(1)</code> 处的记录读取 <code>4 + 3*_nBand</code> 个值，前四个值分别为：</p>
<ul>
<li><code>current_nPlaneWave</code>: 该 K 点波函数展开需要的平面波数量，转换为 <code>int</code> 类型；</li>
<li><code>current_kVector</code>: 该 K 点的坐标（倒空间），转换为 3 个 <code>double</code> 类型；</li>
</ul>
<p>之后的 <code>3*_nBand</code> 个值构成一个 <code>_nBand * 3</code> 的矩阵，前两列分别表示该 K 点处各个能带的特征值（能量），由于特征值解出来可能是复数，所以这里用两列表示，第一列表示 <code>band</code> 的实部，第二列表示 <code>band</code> 的虚部，第三列表示每个能带的费米权重，即<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Re(band[0]), Im(band[0]), fermiWeights[0];</span><br><span class="line">Re(band[1]), Im(band[1]), fermiWeights[1];</span><br><span class="line">...          ...          ...</span><br></pre></td></tr></table></figure></p>
<p><code>(2)</code> 处的记录就是每个 K 点每条能带波函数展开的平面波系数，系数的个数由前面得到的 <code>current_nPlaneWave</code> 决定。由于 <code>WAVECAR</code> 中占比最大的部分就是这部分，故设法减小文件的体积时便从这里开刀。还记得这个函数开头得到的 <code>_precisionTag</code> 吗？这里就派上用场了：<br>如果 <code>_precisionTag == 45200 || _precisionTag == 53300</code> ，则后面的波函数展开的平面波系数就是由 <code>complex&lt;float&gt;</code> 类型存储，否则由 <code>complex&lt;double&gt;</code> 类型存储，即<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (_precisionTag) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">45200</span>: ;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">53300</span>: 平面波系数类型 = <span class="keyword">complex</span>&lt;<span class="keyword">float</span> &gt;; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">45210</span>: ;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">53310</span>: 平面波系数类型 = <span class="keyword">complex</span>&lt;<span class="keyword">double</span>&gt;; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>: _precisionTag 无效，终止程序。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>因此， <code>WAVECAR</code> 共有 <code>2 + nSpin * nKpoint * (1 + nBand)</code> 条记录，每条记录的长度都是一样的。</p>
<p>其大部分参数和 <code>INWAV_HEAD</code> 一致，只多了一个 <code>GRID</code> </p>
<ul>
<li><code>GRID</code>: 格子的 mesh 结构，但在这个函数中不参与文件读写，暂时不需要了解它的作用。</li>
</ul>
<h2 id="OUTWAV-和-OUTWAV-4"><a href="#OUTWAV-和-OUTWAV-4" class="headerlink" title="OUTWAV 和 OUTWAV_4"></a><code>OUTWAV</code> 和 <code>OUTWAV_4</code></h2><p>这两个函数的功能几乎一致，只是 <code>OUTWAV</code> 比 <code>OUTWAV_4</code> 多了一个 <code>EFERMI</code> 的参数，很自然地 <code>OUTWAV</code> 将这个参数写在了 header 的最后，这也解释了为什么早期版本的 header 没有 <code>_eFermi</code> 这一项。至于函数的具体流程，读者只需按照 <code>INWAV_FAST</code> 的流程把读改成写即可，事实上源代码也确实是这样做的。</p>
<p>读到这里读者是否有个疑问， <code>WAVECAR</code> 是由连续的等长的记录组成的，这个记录的长度在读取时可以得到，那么在写入的时候如何确定？源代码中是这样确定这个数的：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IO%IRECLW=<span class="built_in">MAX</span>((NPL_TOT+<span class="number">1</span>)/<span class="number">2</span>,<span class="number">7</span>)*IO%ICMPLX</span><br><span class="line">IRECLW_OLD=<span class="built_in">MAX</span>(<span class="built_in">MAX</span>((NPL_TOT+<span class="number">1</span>)/<span class="number">2</span>,<span class="number">6</span>),((WDES%NB_TOT*<span class="number">3</span>+<span class="number">1</span>)/<span class="number">2</span>+<span class="number">2</span>))*IO%ICMPLX</span><br></pre></td></tr></table></figure>
<p>翻译成人话就是使每条记录都不溢出的最小值，（我在实现小程序时直接使用 <code>_recordLength = (_maxOfNPlaneWaves + 1) / 2</code> 来决定平面波系数数组的大小，这样虽然会浪费一点内存，但省去了很多麻烦）。</p>
<ul>
<li><code>IO</code>: 文件读写的句柄结构，包含多个文件读写的句柄；</li>
<li><code>WDES</code>: 波函数的描述结构，这里只用到了里面对于 <code>_nBand</code>、<code>nSpin</code> 、 <code>_nKpoint</code>以及 <code>_enCut</code> 等值（未全列出）；</li>
<li><code>W</code>: 储存 <code>band</code> 、<code>fermiWeight</code> 等值的结构</li>
<li><code>LATT_INI</code>: 格子的描述结构，包含格子在实空间的格矢；</li>
<li><code>EFERMI</code>: 费米能级；</li>
<li><code>EXT</code>: 这是个可选参数，表示写入前 <code>WAVECAR</code> 是否存在。</li>
</ul>
<h1 id="WAVECAR-解析小程序的实现"><a href="#WAVECAR-解析小程序的实现" class="headerlink" title="WAVECAR 解析小程序的实现"></a><code>WAVECAR</code> 解析小程序的实现</h1><p>显然我们要构建一个类，这个类要包含至少两部分内容：</p>
<ol>
<li><code>WAVECAR</code> 的 header 部分；</li>
<li><code>WAVECAR</code> 的 body 部分。</li>
</ol>
<p>header 部分直接按照 <code>INWAV_FAST</code> 或者 <code>OUTWAV</code> 给出的顺序读取即可：<br><figure class="highlight cpp"><figcaption><span>header</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span>  _recordLength, _nSpin, _precisionTag;</span><br><span class="line">    <span class="keyword">bool</span> _isDoubleType;</span><br><span class="line">    <span class="keyword">int</span> _fileSize;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> _nKpoints, _nBands;</span><br><span class="line">    <span class="keyword">double</span> _enCut;</span><br><span class="line">    Eigen::Matrix&lt;<span class="keyword">double</span>, <span class="number">3</span>, <span class="number">3</span>&gt; _latticeVectors;</span><br><span class="line">    Eigen::Matrix&lt;<span class="keyword">double</span>, <span class="number">3</span>, <span class="number">3</span>&gt; _reciprocalVectors;</span><br><span class="line">    <span class="keyword">double</span> _omega;</span><br><span class="line">    <span class="keyword">double</span> _eFermi;</span><br></pre></td></tr></table></figure></p>
<p>body 部分与之类似：<br><figure class="highlight cpp"><figcaption><span>body</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">VectorXi _nPlaneWaves;</span><br><span class="line">Matrix&lt;<span class="keyword">double</span>, Dynamic, <span class="number">3</span>&gt; _kVectors;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Matrix&lt;<span class="built_in">std</span>::<span class="keyword">complex</span>&lt;<span class="keyword">double</span>&gt;, Dynamic, Dynamic&gt;&gt; _bands;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Matrix&lt;<span class="keyword">double</span>, Dynamic, Dynamic&gt;&gt; _fermiWeights;</span><br><span class="line"><span class="keyword">int</span> _maxOfNPlaneWaves;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4 dimensions are: (ispin, kpoint, nband, nplanewaves)</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt; Matrix&lt;</span><br><span class="line">    VectorXcd, Dynamic, Dynamic&gt;&gt; _complexWaves;</span><br></pre></td></tr></table></figure></p>
<p>需要的操作也很简单：<br><figure class="highlight cpp"><figcaption><span>operations</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">read_info</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">read_header</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">read_band</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>按照上文和源码稍微修改一下基本就能实现了，限于篇幅原因，这里不贴出所有代码了（</p>
<p>输出的效果如图：</p>
<p><img src="a.png" alt></p>
<p>2019-1-15 更新: 已实现的波函数解析程序请见<a href="https://github.com/Ionizing/wavecar_parser" target="_blank" rel="noopener">这里</a></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://ionizing.science/2018/03/28/how-to-struggle-with-vasp/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ionizing Radiation">
      <meta itemprop="description" content="伪化生的小窝">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ionizing's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/03/28/how-to-struggle-with-vasp/" class="post-title-link" itemprop="url">在 VASP(PBE) 计算中如何优雅地踩坑？</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2018-03-28 17:28:20" itemprop="dateCreated datePublished" datetime="2018-03-28T17:28:20+08:00">2018-03-28</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2018-12-31 19:47:25" itemprop="dateModified" datetime="2018-12-31T19:47:25+08:00">2018-12-31</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/First-Principle-Calculation/" itemprop="url" rel="index"><span itemprop="name">First Principle Calculation</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          
            <span id="/2018/03/28/how-to-struggle-with-vasp/" class="leancloud_visitors" data-flag-title="在 VASP(PBE) 计算中如何优雅地踩坑？">
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              
                <span class="post-meta-item-text">Views: </span>
              
                <span class="leancloud-visitors-count"></span>
            </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p><strong>警告</strong>：本渣刚学 <code>VASP</code> 不久，对 <code>VASP</code> 的算法、参数不甚了解，如果有大触偶遇此文，并发现有错误，请在评论区指出或邮箱联系本渣。</p>
</blockquote>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文是本渣从 3 月初以来刚接触 <code>VASP</code> 所学技能与遇到坑的总结，以纪念我为文献中一副图而逝去的最近一星期。何为 <code>VASP</code> 以及<code>VASP</code> 能做什么？本渣只是一个刚学的菜鸡，恕不能回答，请自行 Google 解决。</p>
<h2 id="VASP-的输入文件"><a href="#VASP-的输入文件" class="headerlink" title="VASP 的输入文件"></a>VASP 的输入文件</h2><p>想要执行一次最简单的计算，<code>VASP</code> 需要至少4个文件，它们分别是：</p>
<ul>
<li><code>INCAR</code>：<code>VASP</code> 计算的<strong>核心</strong>文件，基本等同于本次计算的司令部。它包含了“<strong>算什么</strong>”、“<strong>怎么算</strong>”、和“<strong>输入、输出那些</strong>”这三个方面的内容，它的几项常用（PBE计算中）参数在后面我们会较为详细地了解到；</li>
<li><code>POSCAR</code>：决定元胞结构的文件。它包含了元胞的格子类型、格子大小、以和格子内所有原子的种类及坐标，在弛豫时，它还可以指定哪些原子可以在哪些方向上进行<a href="https://en.wikipedia.org/wiki/Relaxation_(physics" target="_blank" rel="noopener">弛豫</a>)，在 <code>VASP</code> 中我们无需给出原子间的成键情况，仅给出原子的坐标即可；</li>
<li><code>KPOINTS</code>：描述 <code>VASP</code> 计算中对元胞格子的 mesh 精细度，或指定格子中哪些点的信息需要计算（？这里留个问号，本渣也不是很懂这里）；</li>
<li><code>POTCAR</code>：赝势库，按 <code>POSCAR</code> 中元素列出顺序给出了对应元素的赝势库。</li>
</ul>
<p><strong>以上四个文件全为文本文件</strong>。当然我们还可以命令 <code>VASP</code> 读取上一次的计算结果，比如 <code>WAVECAR</code> ，比如 <code>CHGCAR</code> ，用以更快地收敛或者执行某些特殊的计算。</p>
<h2 id="我们需要-VASP-的哪些输出文件？（目前为止）"><a href="#我们需要-VASP-的哪些输出文件？（目前为止）" class="headerlink" title="我们需要 VASP 的哪些输出文件？（目前为止）"></a>我们需要 VASP 的哪些输出文件？（目前为止）</h2><ul>
<li><code>OUTCAR</code>：<code>VASP</code> 的计算日志，里面包含了几乎所有我们需要的结果，明文存储，随计算过程实时更新；</li>
<li><del><code>WAVECAR</code>：<strong>二进制</strong>文件，经常很大，计算结束时会将内存中的波函数平面波系数写入该文件。（我对这个文件所了解的仅有这些；</del></li>
<li><code>OSZICAR</code>：<code>VASP</code> 计算过程中能量收敛日志，每个电子步结束时写入；</li>
<li><del><code>EIGENVAL</code>：<code>VASP</code> 计算出的能带信息保存在这个文件中，计算结束时被写入（可以使用 <code>Python</code> 等工具以它为输入绘制能带图，但本渣太菜，目前还没写这个小程序；</del></li>
<li><code>CONTCAR</code>：在<a href="https://en.wikipedia.org/wiki/Relaxation_(physics" target="_blank" rel="noopener">弛豫</a>)中，这个文件包含了<code>VASP</code>每个离子步结束时系统优化得到的元胞原子的坐标，每个离子步结束时写入；如果希望从还未收敛的弛豫结果继续计算，应直接将这个文件复制并重命名为 <code>POSCAR</code> 继续计算即可；</li>
<li><del><code>CHG</code> &amp; <code>CHGCAR</code>：这个两个文件都包含了元胞中原子的位置信息，以及电荷密度信息，但 <code>CHG</code> 比 <code>CHGCAR</code> 小一些，因其不包含 <code>PAW one centre</code>；</del></li>
<li><code>vasprun.xml</code>：XML 格式存储的 <code>VASP</code> 计算过程日志。</li>
<li><code>PROCAR</code>：</li>
</ul>
<h2 id="用-PBE-方法跑出能带图的总体步骤"><a href="#用-PBE-方法跑出能带图的总体步骤" class="headerlink" title="用 PBE 方法跑出能带图的总体步骤"></a>用 PBE 方法跑出能带图的总体步骤</h2><ol>
<li>阅读文献，列出文献所给参数（如果有的话），比如 <code>SIGMA</code> ，<code>ISMEAR</code> ，<code>ENCUT</code> ，晶格常数 $a$ 等等信息；</li>
<li>查阅资料，<strong>实现文献所给结构</strong>，关注文献的结构是否经过超胞，是否有真空层，是否考虑 vdW ；</li>
<li>按顺序测出适合该体系的 <code>SIGMA</code> 、<code>ENCUT</code> 、kpts 、<code>a</code> ；（如果文献中给出了这些参数可跳过这一步</li>
<li>对结构进行弛豫，优化出最稳定结构；</li>
<li>对体系进行高精度的电子自洽计算；</li>
<li>跑出能带图、DOS 图以及直接获得所需的能量值等。</li>
</ol>
<h1 id="正文开始"><a href="#正文开始" class="headerlink" title="正文开始"></a>正文开始</h1><p>下面以单层 C3B 结构为例，走一遍上面的流程，看看有哪些坑。</p>
<h2 id="获取参数"><a href="#获取参数" class="headerlink" title="获取参数"></a>获取参数</h2><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">5.17</span> 		<span class="comment">! 晶格常数</span></span><br><span class="line">EDIFF = <span class="number">1.0E-6</span>	<span class="comment">! 弛豫收敛条件</span></span><br><span class="line">EDIFFG = -<span class="number">0.001</span>	<span class="comment">! </span></span><br><span class="line"></span><br><span class="line">kpts: Monkhorst	<span class="comment">! KPOINTS 取法</span></span><br></pre></td></tr></table></figure>
<p>文献给出单层 C3B 的结构为 $D_{6h}$ ，长这样（从上往下看：</p>
<p><img src="http://owucpthrj.bkt.clouddn.com/FpGVI905Z66B8ksQjiULb3cLahCV" alt></p>
<h2 id="实现结构"><a href="#实现结构" class="headerlink" title="实现结构"></a>实现结构</h2><p>建立元胞的格子基矢（D6h 的晶型都可以这样建系，使用 Direct 模式，可以手写所有原子的坐标），并表示出各个原子的坐标</p>
<p><img src="http://owucpthrj.bkt.clouddn.com/FiQMZt8-XbO9iXes05rkDhfFjHls" alt></p>
<p>所以它对应的 <code>POSCAR</code> 应为：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">C3B graphene like structure, a = <span class="number">5.17</span>               <span class="comment">! 注释</span></span><br><span class="line">   <span class="number">5.17</span>                                             <span class="comment">! 晶格放大系数</span></span><br><span class="line">    <span class="number">0.8660254037</span>   -<span class="number">0.5000000000</span>     <span class="number">0.0000000000</span>   <span class="comment">! 下面三行为实空间中定义元胞的三个格矢 a1, a2, a3</span></span><br><span class="line">    <span class="number">0.8660254037</span>    <span class="number">0.5000000000</span>   	 <span class="number">0.0000000000</span></span><br><span class="line">    <span class="number">0.0000000000</span>    <span class="number">0.0000000000</span>     <span class="number">4.0000000000</span>   <span class="comment">! 真空层厚度为 4.0*5.17 = 20.68A</span></span><br><span class="line">   B    C                                           <span class="comment">! 元素种类，这一行是给人看的，而不是给VASP看的</span></span><br><span class="line">   <span class="number">2</span>    <span class="number">6</span>                                           <span class="comment">! 对应元素的原子数目</span></span><br><span class="line"><span class="keyword">Direct</span>                                              <span class="comment">! 以定义的格矢为基底</span></span><br><span class="line">    <span class="number">0.0000000000</span>    <span class="number">0.0000000000</span>    <span class="number">0.0000000000</span>    <span class="comment">! B 下面皆为原子坐标，顺序与第六行指定的元素种类相同</span></span><br><span class="line">    <span class="number">0.6666666666</span>    <span class="number">0.6666666666</span>    <span class="number">0.0000000000</span>    <span class="comment">! 要注意，仅靠POSCAR，并vasp不知道元素的具体种类，而只知道元素种类的个数。</span></span><br><span class="line">    <span class="number">0.5000000000</span>    <span class="number">0.0000000000</span>    <span class="number">0.0000000000</span>    <span class="comment">! C</span></span><br><span class="line">    <span class="number">0.1666666666</span>    <span class="number">0.1666666666</span>    <span class="number">0.0000000000</span></span><br><span class="line">    <span class="number">0.0000000000</span>    <span class="number">0.5000000000</span>    <span class="number">0.0000000000</span></span><br><span class="line">    <span class="number">0.5000000000</span>    <span class="number">0.5000000000</span>    <span class="number">0.0000000000</span></span><br><span class="line">    <span class="number">0.6666666666</span>    <span class="number">0.1666666666</span>    <span class="number">0.0000000000</span></span><br><span class="line">    <span class="number">0.1666666666</span>    <span class="number">0.6666666666</span>    <span class="number">0.0000000000</span></span><br></pre></td></tr></table></figure>
<p><strong>第一个坑</strong>：文献中的晶格常数应该怎样对应 <code>POSCAR</code> 中的晶格参数？</p>
<p>这取决于我们取的基底。上文中我们以相邻两个元胞的 B 原子间模长最短的矢量为基矢，因此这个这个元胞的实际晶格常数应为 $a = |\vec{a}<em>i| \times a</em>{POSCAR}$ ， $a$ 即为文中给出的晶格常数，可见，<code>POSCAR</code> 中的晶格参数可以理解为缩放系数，所以写完结构时应与文献对照或放入 VESTA 等软件测出原子键长看与文献是否一致。有的文献作者基底的取法特殊，所给的晶格常数也很“魔性”，但不变的是格子的实际大小、原子间距离等，以这些信息为准才能写出与文献中真正等价的结构。此外，二维结构的实现时需要层间有 20 A 左右的真空层，以避免层间不必要的相互作用，但真空层不可取太厚，否则计算量的增加不仅仅是线性的。</p>
<p><strong>闲话</strong>：如何建系是个见仁见智的问题，有人喜欢直接沿着六边形的边建系，有人喜欢像上文那样建系，但不管怎样，只要实现的结构是等价的那么建系就是没有问题的</p>
<h2 id="测出必要的参数"><a href="#测出必要的参数" class="headerlink" title="测出必要的参数"></a>测出必要的参数</h2><h3 id="INCAR-Template"><a href="#INCAR-Template" class="headerlink" title="INCAR Template"></a><code>INCAR</code> Template</h3><p>在测各项参数之前，先给出一个<code>INCAR</code> 模板，具体参数的含义见注释或<code>VASP</code>手册。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">C3B Mono Layer  strcut_optim</span><br><span class="line">  SYSTEM = <span class="string">"C3B Mono Layer"</span> # 系统注释</span><br><span class="line"></span><br><span class="line">Electronic minimization</span><br><span class="line">  ISMEAR =                  # 使用Gaussian smearing，取 <span class="number">0</span> 用于导体、绝缘体的计算</span><br><span class="line">  SIGMA =                   # Smearring 的宽度，在精度允许范围内应尽量大以减小计算量</span><br><span class="line">  EDIFF =                   # 收敛判据的能量判据</span><br><span class="line">  EDIFFG =                  # 收敛判据，若值为负，则为力判据；若值为正，则为能量判据</span><br><span class="line">  PREC =                    # 精确度</span><br><span class="line">  IBRION =                  # 离子移动方法，跑MD、弛豫抑或静态计算时设置不同</span><br><span class="line">  ISIF =                    # 结构优化类型</span><br><span class="line"></span><br><span class="line">Ionic minimization</span><br><span class="line">  NSW =                     # 离子步数上限</span><br><span class="line">  NELMIN = 					# 电子步收敛下限</span><br><span class="line">  ENCUT =                   # 截断能，在保证收敛良好的情况下应尽量小</span><br><span class="line">  LWAVE =                   # 是否输出 WAVECAR；该值为 .FALSE. 时也会有 WAVECAR 输出，但其长度为 <span class="number">0</span></span><br><span class="line">  LCHARG =                  # 是否输出 CHGCAR</span><br><span class="line"></span><br><span class="line">Band Calcs</span><br><span class="line">  ISTART =                  # 是否从当前目录读取 WAVECAR</span><br><span class="line">  ICHARG =                  #  <span class="number">1</span>: 读取 CHGCAR</span><br><span class="line">                            # <span class="number">10</span>: 不改变当前目录下的 CHGCAR</span><br></pre></td></tr></table></figure>
<p>同时 <code>POTCAR</code> 这样获得：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat path/to/PPs/B/POTCAR &gt;&gt; ./POTCAR</span><br><span class="line">cat path/to/PPs/C/POTCAR &gt;&gt; ./POTCAR</span><br></pre></td></tr></table></figure>
<p>这里注意 <code>POTCAR</code> 中元素赝势的顺序应与 <code>POSCAR</code> 元素出现的顺序一致。</p>
<h3 id="测出-SIGMA"><a href="#测出-SIGMA" class="headerlink" title="测出 SIGMA"></a>测出 <code>SIGMA</code></h3><p>固定<code>ENCUT</code>和kpts为较大的值<code>ENCUT = 600</code>、<code>kpts = 21</code>，固定晶格常数为“合适”值，取一系列<code>SIGMA</code>值做静态计算，当<code>OSZICAR</code>中<code>dE</code>绝对值小于 1.0 meV/atom 时取最大的 <code>SIGMA</code> 值。</p>
<p>使用脚本如下（参考候柱锋老师的入门指南）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">rm WAVECAR          <span class="comment"># 删除目录中的 WAVECAR 以免影响收敛</span></span><br><span class="line"><span class="comment"># in 后面 0.20 0.10 0.05 即为 sigma 所取的值，一般从大到小取，取值越小计算量越大当发现 dE 满足要求后可以及时终止计算</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> 0.20 0.10 0.05	</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    cat &gt; INCAR &lt;&lt;! <span class="comment"># 在 INCAR 中覆盖以下内容, ! 表示cat内容终止标志，可以自定义，如用 EOF</span></span><br><span class="line">SYSTEM = Na adsorbed on site 1</span><br><span class="line">ENCUT = 600         <span class="comment"># 截断能取较大值</span></span><br><span class="line">ISMEAR = 0          <span class="comment"># Gaussian Smearing</span></span><br><span class="line">SIGMA = <span class="variable">$i</span>          <span class="comment"># 每次循环 SIGMA 取 $i 的值</span></span><br><span class="line">NSW = 0             <span class="comment"># 静态计算，离子步数为 1</span></span><br><span class="line">IBRION = -1	        <span class="comment"># 静态计算</span></span><br><span class="line">LWAVE = .FALSE.     <span class="comment"># 不输出 WAVECAR，不使用上次计算所得平面波系数作为初始值</span></span><br><span class="line">!</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">" SIGMA = <span class="variable">$i</span> eV "</span></span><br><span class="line">    time vasp &gt;&gt; vasp.log   <span class="comment"># 执行 vasp 计算，重定向输出到 vasp.log ，并对该过程计时，结果输出到 stdout</span></span><br><span class="line">    <span class="comment"># OUTCAR 中 EENTRO 等于 OSZICAR 中的 dE，这里取出 dE</span></span><br><span class="line">    TS=`grep <span class="string">"EENTRO"</span> OUTCAR | tail -1 | awk <span class="string">'&#123;printf "%12.6f", $5&#125;'</span>`</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"<span class="variable">$i</span>   <span class="variable">$TS</span>"</span> &gt;&gt; sigma.txt     <span class="comment"># 输出 SIGMA 和 dE 到sigma.txt</span></span><br><span class="line">    <span class="built_in">echo</span> -e <span class="string">"\n\n"</span>   <span class="comment"># 换行 3 次</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<p>所得 sigma.txt 内容如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0.20   -0.00519083</span><br><span class="line">0.10   -0.00009427</span><br><span class="line">0.05   0.00000000</span><br></pre></td></tr></table></figure>
<p>显然，这里<code>SIGMA</code>取 0.10 即可，当然还可以在 (0.10, 0.20) 之间再取几个点，逼近使 dE &lt; 1meV/atom 的最大 SIGMA。</p>
<h3 id="测出-ENCUT"><a href="#测出-ENCUT" class="headerlink" title="测出 ENCUT"></a>测出 <code>ENCUT</code></h3><p>将上面测出的 <code>SIGMA = 0.10</code> 固定，<code>ENCUT</code> 取不同值，过程与上面类似，只是判断 <code>ENCUT</code> 取值的依据变成了两次计算结果的<code>TOTEN</code>之差绝对值小于 1 meV/atom。</p>
<p>使用脚本如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">rm WAVECAR</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> 300 350 400 450 500 550 600 <span class="comment"># 每次循环 ENCUT 的取值</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    cat &gt; INCAR &lt;&lt;!</span><br><span class="line">SYSTEM = Na adsorbed on site 1</span><br><span class="line">ENCUT = <span class="variable">$i</span></span><br><span class="line">ISMEAR = 0</span><br><span class="line">SIGMA = 0.10		<span class="comment"># SIGMA 取上面测得的值</span></span><br><span class="line">NSW = 0</span><br><span class="line">IBRION = -1</span><br><span class="line">!</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">" ENCUT = <span class="variable">$i</span> eV "</span></span><br><span class="line">    time vasp &gt;&gt; vasp.log</span><br><span class="line">    E=`grep <span class="string">"TOTEN"</span> OUTCAR | tail -1 | awk <span class="string">'&#123;printf "%12.6f", $5&#125;'</span>`	<span class="comment"># 取出 OUTCAR 中的 TOTEN</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"<span class="variable">$i</span>   <span class="variable">$E</span>"</span> &gt;&gt; encut.txt</span><br><span class="line">    <span class="built_in">echo</span> -e <span class="string">"E = <span class="variable">$E</span>\n\n"</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<p>测得 <code>ENCUT</code> 取值为 450。这里 <code>ENCUT</code> 如果取值过小，后面在弛豫时很可能能量不会收敛。</p>
<h3 id="测出-kpts"><a href="#测出-kpts" class="headerlink" title="测出 kpts"></a>测出 kpts</h3><p>kpts 指的是 <code>KPOINTS</code> 里 meshgrid 的取样点数，取样越多，计算结果收敛越好，同时计算量也变大。取值条件与上面相同，即两次计算的 <code>TOTEN</code> 相差小于 1meV/atom 。</p>
<p><strong>注意，不要忘了把测好的 <code>SIGMA</code> 和 <code>ENCUT</code> 写入 <code>INCAR</code></strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">rm WAVECAR</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> 9 13 17 21	<span class="comment"># kpts 取 9 13 17 21</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    cat &gt; KPOINTS &lt;&lt;!</span><br><span class="line">Na adsorbed on site1 -- det_kp</span><br><span class="line">0</span><br><span class="line">Monkhorst-Pack		<span class="comment"># 只要第一个字母为 M 即可</span></span><br><span class="line">    <span class="variable">$i</span>  <span class="variable">$i</span>  1		<span class="comment"># 有真空层存在，z方向采样点数为 1</span></span><br><span class="line">    0   0   0</span><br><span class="line">!</span><br><span class="line">    <span class="built_in">echo</span> -e <span class="string">"k mesh = <span class="variable">$i</span>\t<span class="variable">$i</span>\t1"</span>; time vasp &gt;&gt; vasp.log</span><br><span class="line">    E=`grep <span class="string">"TOTEN"</span> OUTCAR | tail -1 | awk <span class="string">'&#123;printf "%18.10f", $5&#125;'</span>`</span><br><span class="line">    KP=`grep <span class="string">"irreducible"</span> OUTCAR | tail -1 | awk <span class="string">'&#123;printf "%5i", $2&#125;'</span>`</span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$i</span> <span class="variable">$KP</span> <span class="variable">$E</span> &gt;&gt; det_kp.txt</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<p>测得 kpts 取15。</p>
<p><strong>第二个坑</strong>：<code>KPOINTS</code> 文件名一定要写对，本渣使用的 <code>VASP</code> 版本为 5.3.5，计算中如果没检测到 <code>KPOINTS</code> 文件存在，则<strong>默认</strong> kpts 取值为 <strong>3</strong> ，导致结果错误。本渣某次计算中误将 <code>KPOINTS</code> 写成了 <code>KPOINS</code> ，导致后面无论如何修改参数，结果与文献值始终相差很大。（这个东西不仅坑了我，还坑了<strong>比那名居腿娘</strong>(来自WHU的EE大佬)大神熬夜到 3 点多，说来惭愧……</p>
<h3 id="测出-a"><a href="#测出-a" class="headerlink" title="测出 a"></a>测出 <code>a</code></h3><p>这里的<code>a</code>确切地指 <code>POSCAR</code> 中第二行的那个数值，即元胞的放大系数。因为本例中的晶格基矢模长 $|\vec{a_1}| = |\vec{a_2}| = 1$ ，故其放大系等于文献中的晶格常数 $a$。这里 <code>a</code> 的取值条件与上面相同。给出测试脚本如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">rm WAVECAR</span><br><span class="line"><span class="comment"># 晶格参数的取值应在文献值附近取点</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> 4.97 5.02 5.07 5.12 5.17 5.22 5.27 5.32 5.37</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    cat &gt; POSCAR &lt;&lt;!</span><br><span class="line">C3B graphene like structure, a = 5.17</span><br><span class="line">   <span class="variable">$i</span></span><br><span class="line">    0.8660254037   -0.5000000000    0.0000000000</span><br><span class="line">    0.8660254037    0.5000000000    0.0000000000</span><br><span class="line">    0.0000000000    0.0000000000    3.0000000000</span><br><span class="line">   B    C</span><br><span class="line">   2    6</span><br><span class="line">Direct</span><br><span class="line">    0.0000000000    0.0000000000    0.0000000000    ! B1</span><br><span class="line">    0.6666666666    0.6666666666    0.0000000000    ! B2</span><br><span class="line">    0.5000000000    0.0000000000    0.0000000000    ! C1</span><br><span class="line">    0.1666666666    0.1666666666    0.0000000000    ! C2</span><br><span class="line">    0.0000000000    0.5000000000    0.0000000000    ! C3</span><br><span class="line">    0.5000000000    0.5000000000    0.0000000000    ! C4</span><br><span class="line">    0.6666666666    0.1666666666    0.0000000000    ! C5</span><br><span class="line">    0.1666666666    0.6666666666    0.0000000000    ! C6</span><br><span class="line">!</span><br><span class="line">	<span class="built_in">echo</span> -e <span class="string">"a = <span class="variable">$i</span> angstrom"</span>; time vasp &gt;&gt; vasp.log</span><br><span class="line">	E=`grep <span class="string">"TOTEN"</span> OUTCAR | tail -1 | awk <span class="string">'&#123;printf "%12.6f", $5 &#125;'</span>`</span><br><span class="line">	V=`grep <span class="string">"volume"</span> OUTCAR | tail -1 | awk <span class="string">'&#123;printf "%12.4f", $5&#125;'</span>`</span><br><span class="line">	<span class="built_in">printf</span> <span class="string">"%6.3f %10.4f %18.10f\n"</span> <span class="variable">$i</span> <span class="variable">$V</span> <span class="variable">$E</span> &gt;&gt; a.txt</span><br><span class="line">	tail -1 a.txt</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<p>测得 <code>a</code> 与文献值相同，5.17。这里的 <code>a</code> 还可以取得更精细一些，甚至可以到小数点后三位，这里取值越接近“真实值”，后面弛豫的过程将会越短。</p>
<h2 id="弛豫（结构优化，relaxation）"><a href="#弛豫（结构优化，relaxation）" class="headerlink" title="弛豫（结构优化，relaxation）"></a>弛豫（结构优化，relaxation）</h2><p>弛豫中需要用到的 <code>INCAR</code> 参数有</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ISMEAR = <span class="number">0</span>       <span class="comment">! 继承自上面的计算结果</span></span><br><span class="line">SIGMA = <span class="number">0.1</span></span><br><span class="line">ENCUT = <span class="number">450</span></span><br><span class="line"></span><br><span class="line">PREC = Accurate</span><br><span class="line">EDIFF = <span class="number">1.0E-6</span></span><br><span class="line">EDIFFG = -<span class="number">0.01</span></span><br><span class="line">IBRION = <span class="number">1</span>       <span class="comment">! 准牛顿法</span></span><br><span class="line">ISIF = <span class="number">3</span>         <span class="comment">! 计算 force、stress tensor，对离子、晶格进行弛豫 </span></span><br><span class="line"></span><br><span class="line">NELMIN = <span class="number">6</span>       <span class="comment">! (optional) 强制每个离子步跑至少 6 电子步，提高收敛效果</span></span><br><span class="line">NSW = <span class="number">200</span>        <span class="comment">! 离子步上限为 200 步，目前本渣所算的体系中离子步数没有超过这个值的，也许是我太年轻了吧</span></span><br></pre></td></tr></table></figure>
<p>这个步骤耗时最长，尤其是加上 <code>PREC</code> 后，每个电子步计算量上升很多，而为了结构的优化，离子步数的增多也使这个过程耗时不少，本例中 8 个原子的体系优化需要数个小时；本渣另外的一个体系中有 12 个原子，优化就需要 12h+ 。</p>
<p><strong>第三个坑</strong>：<code>EDIFFG</code>有正负之分，<strong>负数</strong>表示收敛的力判据。如果<code>EDIFFG</code>误写为正，则<code>EDIFF</code>会被覆盖，<code>VASP</code>按照<code>EDIFFG</code>进行收敛判断，结果就是收敛可能会变得很快（快上几个数量级），但是所得结构不是我们想要的结构。</p>
<p><strong>第四个坑</strong>：如果 <code>EDIFF</code>和<code>EDIFFG</code>设置过小，则计算时收敛可能会变得非常漫长，有时甚至会将结构跑散——原子间距离越来越大，这时候有三种选择：1. 提高精度，重新测出晶格常数，晶格常数可以精确到 0.001；2. 放宽收敛判据； 3. <code>IBRION</code> 取 2 （如果你对这个结构是否稳定没有信心的话。</p>
<h2 id="高精度的电子自洽计算（SCF）"><a href="#高精度的电子自洽计算（SCF）" class="headerlink" title="高精度的电子自洽计算（SCF）"></a>高精度的电子自洽计算（SCF）</h2><p>进行高精度的电子自洽计算是为了得到体系的电荷分布，同时也为后面计算能带提供数据。</p>
<p>这一步需要<strong>将 relaxation 得到的 CONTCAR 复制到 SCF 计算目录下，并重命名为 POSCAR</strong> ，<code>INCAR</code> 内容相似，仅将弛豫相关参数修改即可，<code>INCAR</code> 如下</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">C3B Mono Layer  strcut_optim</span><br><span class="line">  SYSTEM = <span class="string">"C3B Mono Layer"</span> # System <span class="keyword">Name</span></span><br><span class="line"></span><br><span class="line">Electronic minimization</span><br><span class="line">  ISMEAR = <span class="number">0</span>                # Toggle Gaussian Method, complete later</span><br><span class="line">  SIGMA = <span class="number">0.1</span>               # Broadening <span class="keyword">in</span> eV -<span class="number">4</span>-tet-<span class="number">1</span>-fermi <span class="number">0</span>-gaus</span><br><span class="line">  EDIFF = <span class="number">1.E-6</span>             # Energy tolerance eV/atom</span><br><span class="line">#  EDIFFG = -<span class="number">0.01</span>            # Force tolerance</span><br><span class="line">  PREC = Accurate           # Accuracy</span><br><span class="line">  IBRION = -<span class="number">1</span>               # quasi-Newton algorithm</span><br><span class="line">#  ISIF = <span class="number">3</span>                  # optim totally: volume, stress, force, ion, <span class="built_in">shape</span></span><br><span class="line"></span><br><span class="line">Ionic minimization</span><br><span class="line">  NSW = <span class="number">0</span>                   # Converge steps, must set</span><br><span class="line">  ENCUT = <span class="number">450</span>               # components beyond ENCUT are <span class="string">'removed'</span> from the projection</span><br><span class="line">                            # operators</span><br><span class="line">  LWAVE = .TRUE.            # Output WAVECAR</span><br><span class="line">  LCHARG = .TRUE.           # Output density of charge to CHG and CHGCAR</span><br><span class="line">  NCORE = <span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>由于默认输出 <code>CHGCAR</code> ， <code>INCAR</code> 中的 <code>LCHARG</code> 可以不写。</p>
<h2 id="计算能带（band）"><a href="#计算能带（band）" class="headerlink" title="计算能带（band）"></a>计算能带（band）</h2><p><strong>复制 SCF 计算所得 CHGCAR 到 band 计算目录下。</strong></p>
<p>我们需要重写 <code>KPOINTS</code> ，之前的 <code>KPOINTS</code> 一直是系统帮助我们在布里渊区采样，现在我们想要得到布里渊区某一路径上能带的能量变化，则需要在 <code>KPOINTS</code> 指定出路径。</p>
<p>根据 <a href="https://arxiv.org/abs/1004.2974" target="_blank" rel="noopener">DOI:10.1016/j.commatsci.2010.05.010</a> 后面所给资料提示选择对应的布里渊区 K 点路径（注意文中基矢的取法是否与自己一致，否则需要重新画出布里渊区，找出对应的 K 点。这里在寻找 K 点时可以借助 <a href="http://www.xcrysden.org/" target="_blank" rel="noopener">XCrysDen</a> ，选择 K-Point path 即可</p>
<p><img src="http://owucpthrj.bkt.clouddn.com/FpmnmrDYGQOgi2NLIPUvy31t0c4p" alt="这里取 Gamma -&gt; K -&gt; M -&gt; Gamma"></p>
<p>写出 <code>KPOINTS</code> 如下：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">K-POINTS    C3B Mono Layer Bands	<span class="comment">! 注释行</span></span><br><span class="line">    <span class="number">40</span>								<span class="comment">! 每两个K点之间取样点数</span></span><br><span class="line">Line-mode							<span class="comment">! Line-mode，区别于自动取样模式，跑能带专用</span></span><br><span class="line"><span class="keyword">Rec</span>									<span class="comment">! 在倒空间内取点</span></span><br><span class="line">    <span class="number">0</span>       <span class="number">0</span>       <span class="number">0</span>   			<span class="comment">! Gamma</span></span><br><span class="line">    <span class="number">0.33333</span> <span class="number">0.66666</span> <span class="number">0</span>   			<span class="comment">! K</span></span><br><span class="line"></span><br><span class="line">    <span class="number">0.33333</span> <span class="number">0.66666</span> <span class="number">0</span>   			<span class="comment">! K</span></span><br><span class="line">    <span class="number">0.5</span>     <span class="number">0.5</span>     <span class="number">0</span>   			<span class="comment">! M</span></span><br><span class="line"></span><br><span class="line">    <span class="number">0.5</span>     <span class="number">0.5</span>     <span class="number">0</span>   			<span class="comment">! M</span></span><br><span class="line">    <span class="number">0</span>       <span class="number">0</span>       <span class="number">0</span>   			<span class="comment">! Gamma</span></span><br></pre></td></tr></table></figure>
<p>同时在 <code>INCAR</code> 中加上 <code>ICHARG = 11</code> 以读取 SCF 所得 <code>CHGCAR</code> 进行能带计算。</p>
<p>最后，取所得 <code>vasprun.xml</code> 导入 <code>p4vasp</code> 进行绘制能带图。如果读者有兴趣可以以 <code>EIGENVAL</code>  文件为输入自己实现绘制band的程序（不会很难）。</p>
<blockquote>
<p>跑能带的感觉就和抽卡/开箱是一样的，你永远也不知道下一个体系的 band 会是什么鸟样。</p>
</blockquote>
<p>跑出的能带是这个样子</p>
<p><img src="http://owucpthrj.bkt.clouddn.com/Fodl8Omy6tyxekWIF6pAxHI_lPkN" alt></p>
<p>文献中的截图是这个样子的</p>
<p><img src="http://owucpthrj.bkt.clouddn.com/Fp0bJ1vUyw-dm2uxoVXt61hm6ka_" alt></p>
<p>这里解释一下，本渣最初在跑 band 时 K 点取的路径和文献不同，所以两幅图基本等于对方水平翻转所得，但本文中所给 <code>KPOINTS</code> 里 K 点路径与文献是相符的。细心的大神已经看出两幅图中上图似乎向下平移了一部分，这可能是费米能级的取值差异所致，由于本渣水平太低，姑且只能这样理解了。</p>
<h2 id="计算态密度（DOS）"><a href="#计算态密度（DOS）" class="headerlink" title="计算态密度（DOS）"></a>计算态密度（DOS）</h2><p>如果阅读过文献的话，我们会发现文献中经常和能带图一起出现的还有 <em>态密度</em> 图。何为态密度？<a href="https://zh.wikipedia.org/zh-hans/%E7%8A%B6%E6%80%81%E5%AF%86%E5%BA%A6" target="_blank" rel="noopener">Wikipedia</a> 上的解释为某一能量周围单位区间内的微观状态数量。具体到本文，上面的微观状态便是指占据某能级的电子态。</p>
<h1 id="论检查输入文件正确性的重要性"><a href="#论检查输入文件正确性的重要性" class="headerlink" title="论检查输入文件正确性的重要性"></a>论检查输入文件正确性的重要性</h1><p>这里的输入文件指 <code>VASP</code> 计算时需要用到的文件，如<code>INCAR</code>、<code>POSCAR</code>、<code>POTCAR</code>、<code>KPOINTS</code>、<code>CHGCAR</code>等。</p>
<ol>
<li>文件名是否正确。我知道很多人在 <code>bash</code> 中喜欢用 Tab 补全，这对提高命令输入效率非常有效，但同时也降低了我们检查文件名正确性的机会，上文中提到的 <code>KPOINS</code> 错误就是因为一直使用 Tab 补全而使它一直被继承到跑出 band ，还不止坑了自己，多么可笑；</li>
<li>脚本中重定向输出的文件名是否与需求一致。当使用上一次计算的脚本进行修改时本渣很容易忘了修改输出重定向的目标，从而导致 <code>POSCAR</code> 的内容被输出到 <code>KPOINTS</code> 里，这时 <code>VASP</code> 会报错，遇到这种情况及时修改脚本重新提交任务即可，无非是重新排队的问题；</li>
<li><code>POTCAR</code> 是否与体系相对应。有的论文并不明确说出自己使用哪个 <code>POTCAR</code> ，而是这样说：”We treated 4p, 5s, 4d orbitals of xx, and x orbitals of xxx as valence electrons…”，这就表明我们需要考虑使用带 <code>_pv</code> 、 <code>_sv</code> 的 <code>POTCAR</code> 。<strong>这大概是本人近期踩过的最大的坑了吧</strong>，可以想象，如果从一开始的 <code>POTCAR</code> 就出了问题，那么后面所有的计算就都是徒劳的，而在排错时无论如何也很难将目光投向 <code>POTCAR</code> 。这里要特别感谢 <strong>比那名居腿娘</strong> 同学的帮助；</li>
<li><code>POSCAR</code> 中的晶胞是否需要超胞。有的文献中给出一个 band 图但未给出其对应的结构，本渣按照前文所给结构计算，始终无法得到与文献相符的 band 图，直到本渣使用 2x2 超胞后的结构进行计算，终于重复出和文献很接近的结果；</li>
<li>有时在弛豫后进行 SCF 计算时会提示对称性错误，这时需要在 <code>INCAR</code> 中指定 <code>SYMPREC</code> 的值，这个值默认为<code>SYMPREC = 1.0E-5</code>，指定时可以使用更小的值。</li>
</ol>
<p>除了上面说到的 <code>INCAR</code>、<code>POSCAR</code>、<code>POTCAR</code>、<code>KPOINTS</code>、<code>CHGCAR</code>等，有时还会用到 <code>WAVECAR</code> ，<code>WAVECAR</code> 是二进制文件，在使用 FileZilla 传送时，如果没有勾选 <code>binary</code> 选项，则传送时会按照 ASCII 编码进行传送，后果就是 <code>WAVECAR</code> 文件损坏。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li>VASP软件包的使用入门指南——候柱锋</li>
<li>VASP the GUIDE(April 20, 2016)——Kresse, Martijn Marsman , Jurgen Furthmuller</li>
<li><a href="https://arxiv.org/abs/1004.2974" target="_blank" rel="noopener">High-throughput electronic band structure calculations: challenges and tools</a> ——<a href="https://arxiv.org/find/cond-mat/1/au:+Setyawan_W/0/1/0/all/0/1" target="_blank" rel="noopener">Wahyu Setyawan</a>, <a href="https://arxiv.org/find/cond-mat/1/au:+Curtarolo_S/0/1/0/all/0/1" target="_blank" rel="noopener">Stefano Curtarolo</a></li>
</ol>
<p>这次 blog 就写到这里吧，反正也是为自己写的。（当然如果有大佬愿意在评论区指出其中的错误，本渣感激不尽！</p>
<p>最后祝愿各位读到这里的菊苣，提前（</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://ionizing.science/2017/09/30/how-to-solve-viberation-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ionizing Radiation">
      <meta itemprop="description" content="伪化生的小窝">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ionizing's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2017/09/30/how-to-solve-viberation-1/" class="post-title-link" itemprop="url">简谐振动系统浅析（一）</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2017-09-30 22:21:37" itemprop="dateCreated datePublished" datetime="2017-09-30T22:21:37+08:00">2017-09-30</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2018-12-31 19:47:25" itemprop="dateModified" datetime="2018-12-31T19:47:25+08:00">2018-12-31</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Physics/" itemprop="url" rel="index"><span itemprop="name">Physics</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          
            <span id="/2017/09/30/how-to-solve-viberation-1/" class="leancloud_visitors" data-flag-title="简谐振动系统浅析（一）">
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              
                <span class="post-meta-item-text">Views: </span>
              
                <span class="leancloud-visitors-count"></span>
            </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="何为简谐振动"><a href="#何为简谐振动" class="headerlink" title="何为简谐振动"></a>何为简谐振动</h1><p>引用 Wikipedia 上的<a href="https://zh.wikipedia.org/zh-cn/%E7%B0%A1%E8%AB%A7%E9%81%8B%E5%8B%95" target="_blank" rel="noopener">定义</a>，<strong>简谐运动</strong>（或<strong>简谐振动</strong>、<strong>谐振</strong>、<strong>SHM</strong>（Simple Harmonic Motion））既是最基本也是最简单的一种<a href="https://zh.wikipedia.org/wiki/%E6%8C%AF%E5%8A%A8" target="_blank" rel="noopener">机械振动</a>。当某物体进行简谐运动时，物体所受的<a href="https://zh.wikipedia.org/wiki/%E5%8A%9B" target="_blank" rel="noopener">力</a>跟<a href="https://zh.wikipedia.org/wiki/%E4%BD%8D%E7%A7%BB" target="_blank" rel="noopener">位移</a>成正比，并且力总是指向平衡位置。</p>
<p>典型的例子即为水平面内的弹簧振子，如下图所示（忽略一切摩擦）</p>
<p><img src="http://owucpthrj.bkt.clouddn.com/Fkz3IAKLr9KLnGExvHe6RlsOB_Pr" alt></p>
<p>如果用 $F$ 表示物体受到的回复力，用 $x$ 表示小球相对于平衡位置的位移，由胡克定律，小球受力总有<br>$$<br>F = -kx<br>$$<br>简谐振动系统的机械能守恒（即动能和弹簧的势能之间来回转换，动能和势能之和不变）。</p>
<h1 id="动力学方程"><a href="#动力学方程" class="headerlink" title="动力学方程"></a>动力学方程</h1><h2 id="普通表述"><a href="#普通表述" class="headerlink" title="普通表述"></a>普通表述</h2><p>由牛顿第二定律<br>$$<br>F = ma<br>$$<br>因此<br>$$<br>ma + kx = 0<br>$$<br>即<br>$$<br>m\ddot{x} + kx = 0<br>$$<br>解上面的方程（这是一个很简单的二阶线性齐次常系数微分方程，$mr^2 + k = 0$，推出 $r = \pm i\sqrt{\frac{k}{m}}$，直接代入解的表达式并用欧拉公式展开即可），可以得到<br>$$<br>\begin{aligned}<br>x &amp;= c_1 \cos(\omega t) + c_2 \sin(\omega t)\<br> &amp;= A\cos(\omega t + \varphi_0)<br>\end{aligned}<br>$$</p>
<p>式中<br>$$<br>\begin{aligned}<br>\omega &amp;= \sqrt{\frac km} &amp;&amp; \omega 即为角频率\<br>    A &amp;= \sqrt{c_1^2 + c_2^2} &amp;&amp; A即为振幅\<br>    \varphi_0 &amp;= -\tan\frac{c_2}{c_1}&amp; &amp; \varphi_0 即为初相位<br>\end{aligned}<br>$$</p>
<p>显然，从 $x(t)$ 的表达式可以看出，小球的运动呈现一个周期性，周期为<br>$$<br>T = \frac{2\pi}{\omega} = 2\pi \sqrt{\frac mk}<br>$$</p>
<h2 id="复数表述"><a href="#复数表述" class="headerlink" title="复数表述"></a>复数表述</h2><p>这时 $x = A\cos(\omega t + \varphi_0)$ 可以用一个复数表示（欧拉公式：$e^{\mathrm i \theta} = \cos \theta + \mathrm i \sin \theta$，欧拉公式的推导借助了麦克劳林公式展开，感兴趣可以看<a href="https://zh.wikipedia.org/wiki/%E6%AC%A7%E6%8B%89%E5%85%AC%E5%BC%8F" target="_blank" rel="noopener">这里</a>）<br>$$<br>\begin{aligned}<br>x = \tilde{s}(t) &amp;= Ae^{\mathrm i(\omega t + \varphi_0)} \<br>  &amp; = Ae^{\mathrm i\omega t}\cdot e^{\mathrm i\varphi_0} \<br>  &amp; = (Ae^{\mathrm i\varphi_0})\cdot e^{\mathrm i\omega t} \<br>  &amp; = \tilde{A} e^{\mathrm i\omega t}<br>\end{aligned}<br>$$<br>（为什么要用复数呢？<del>因为可以装X，</del>因为后面涉及求简正模问题时使用复数会变得非常简单）</p>
<p>此时小球的速度和加速度可以表示为<br>$$<br>\begin{aligned}<br>    \tilde{v} &amp;= \frac{\mathrm d \tilde{s}}{\mathrm d t} = \frac{\mathrm d}{\mathrm dt} \tilde{A} e^{\mathrm i\omega t}  = \mathrm i \omega \tilde{A} e^{\mathrm i\omega t} = \mathrm i\omega \tilde{s}\<br>    \tilde{a} &amp;= \frac{\mathrm d^2 \tilde{s}}{\mathrm d t^2} = \frac{\mathrm d^2}{\mathrm d t^2} \tilde{A} e^{\mathrm i\omega t} =  -{\omega}^2 \tilde{A} e^{\mathrm i\omega t}  = -{\omega}^2 \tilde{s}<br>\end{aligned}<br>$$<br>显然，这种方式求导起来比普通表示法要方便很多。</p>
<h1 id="能量转化分析"><a href="#能量转化分析" class="headerlink" title="能量转化分析"></a>能量转化分析</h1><p>这个系统中值得我们关注的能量有两种：弹簧的弹性势能 $T(x)$ 和小球的动能 $V(x)$。</p>
<h2 id="对动能分析"><a href="#对动能分析" class="headerlink" title="对动能分析"></a>对动能分析</h2><p>显然有<br>$$<br>V(s) = \frac 12 m\dot{s}^2 = -\frac 12 \omega^2 \tilde{s}^2<br>$$<br><del>没什么好说的</del></p>
<h2 id="对势能分析"><a href="#对势能分析" class="headerlink" title="对势能分析"></a>对势能分析</h2><p><strong>注意，这一部分所分析的势能都是以平衡位置为零势能点所算起的势能。</strong></p>
<p>弹簧的势能有<br>$$<br>T(s) = \frac 12 k s^2<br>$$<br>对势能求二阶导<br>$$<br>\frac{\mathrm d^2}{\mathrm ds^2} T(s) =  \frac{\mathrm d^2}{\mathrm ds^2} \bigg(\frac12 ks^2 \bigg)= k<br>$$<br>我们发现势能对位移求二阶导后恰好等于劲度系数，因此有<br>$$<br>\begin{aligned}<br>    T &amp;= \frac 12 T’’ s^2 \<br>    f_{\rm 回} &amp;= -T’’s<br>\end{aligned}<br>$$<br>此时，我们上一小节所讲的所有公式中的振幅 $A$ 和 角频率 $\omega$ 都可以用势能的二阶导数表示<br>$$<br>\begin{aligned}<br>    A = s_{\max} &amp;= \sqrt{ \frac{2E}{k} } = \sqrt{ \frac{2E}{T’’} } \<br>        \omega    &amp;= \sqrt{ \frac{k}{m} } = \sqrt{ \frac{T’’}{m} }<br>\end{aligned}<br>$$</p>
<p>根据这个条件，当我们遇到某些特殊情况而无法很轻松求出 $k$ ，但 $T$ 又显而易见时，我们可以使用上面的式子来计算振动的相关参数（比如摆）。</p>
<h1 id="简正模"><a href="#简正模" class="headerlink" title="简正模"></a>简正模</h1><p>当我们研究的系统不再由单一振子，而是多个振子耦合在一起时，各个振子可能会有各自不同的固有频率，此时系统内的振子如何运动？如果这个系统是孤立的，那么系统的动量守恒，所有的振子一定会按照统一的频率振动，那么这个频率是由谁来决定？我们用一个例子来说明这个问题：</p>
<p>下图表示一个线形三原子分子 $\rm A_2B$ ，相邻原子之间的化学键看成弹性力，它的大小正比于原子离开平衡位置的距离，假设原子只做纵向振动（即振动方向始终与原子核之间连线共线），试求分子可能的纵向运动形式和相应的振动角频率。</p>
<p><img src="http://owucpthrj.bkt.clouddn.com/Fk4cNP6wcbGvH68621OHVFdoQIVz" alt></p>
<p>我们假设从左到右三个原子相对平衡位置的位移分别为 $x_1,\, x_2,\, x_3$ ，列出它们的运动方程为<br>$$<br>\begin{aligned}<br>    m_A \frac{\mathrm d^2}{\mathrm d t^2}x_1 &amp;= -k(x_1 - x_2) \<br>    m_B \frac{\mathrm d^2}{\mathrm d t^2}x_2 &amp;= -k(x_2 - x_1) - k(x_2 - x_3) \<br>    m_A \frac{\mathrm d^2}{\mathrm d t^2}x_3 &amp;= -k(x_3 - x_2)<br>\end{aligned}<br>$$<br>因为这是个孤立系统，所有原子的振动角频率相同，不妨设所有原子的振动角频率都是 $\omega$ ，所以所有原子的位移可以表示为<br>$$<br>\tilde x_i = \tilde A_i e^{\mathrm i \omega t}<br>$$<br>上面的运动方程可以改写为<br>$$<br>\begin{aligned}<br>    -\omega^2m_A A_1 e^{\mathrm i\omega t} &amp;= -k(A_1 e^{\mathrm i \omega t} - A_2 e^{\mathrm i\omega t} ) \<br>    -\omega^2m_B A_2 e^{\mathrm i\omega t} &amp;= -k(2A_2 e^{\mathrm i \omega t} - (A_1+A_3) e^{\mathrm i\omega t} ) \<br>    -\omega^2m_A A_3 e^{\mathrm i\omega t} &amp;= -k(A_3 e^{\mathrm i \omega t} - A_2 e^{\mathrm i\omega t} ) \<br>\end{aligned}<br>$$<br>经过化简可以得到<br>$$<br>\begin{cases}<br>    (\omega^2-\frac{k}{m_A})A_1 + \dfrac{k}{m_A}A_2 = 0 \<br>    \dfrac{k}{m_B}A_1 + (\omega^2-\dfrac{2k}{m_B})A_2 + \dfrac{k}{m_B}A_3 = 0 \<br>    \dfrac{k}{m_A}A_2 + (\omega^2-\dfrac{k}{m_A})A_3 = 0<br>\end{cases}<br>$$</p>
<p>上述方程组有解得条件是<br>$$<br>\begin{vmatrix}<br>    (\omega^2-\frac{k}{m_A})A_1 &amp; \frac{k}{m_A}A_2  &amp; 0\<br>    \frac{k}{m_B}A_1 &amp; (\omega^2-\frac{2k}{m_B})A_2 &amp; \frac{k}{m_B}A_3 \<br>    0 &amp; \frac{k}{m_A}A_2 &amp; (\omega^2-\frac{k}{m_A})A_3<br>\end{vmatrix}<br>= 0<br>$$<br>即<br>$$<br>(\omega^2 - \frac{k}{m_A})^2 (\omega^2 - \frac{2k}{m_B}) - 2(\omega^2 - \frac{k}{m_A})\frac{k^2}{m_A m_B} = 0<br>$$<br>进一步因式分解可以得到<br>$$<br>(\omega^2 - \frac{k}{m_A}) (\omega^2 - \frac{k(2m_A+m_B)}{m_A m_B})\omega^2= 0<br>$$<br>此时 $\omega ^2$ 有三个根，分别为 $\frac{k}{m_A} $ ， $\frac{k(2m_A+m_B)}{m_A m_B}$ ， $0$ 。下面对这三个根进行讨论：</p>
<ol>
<li>当 $\omega^2 = \frac{k}{m_A}$ 时，$A_1 + A_3 = 0$ 且 $A_2 = 0$ ，即中间原子不动，两边原子做做振动方向相反、振幅和频率相同的运动；</li>
<li>当 $\omega^2 = \frac{k(2m_A + m_B)}{m_A m_B}$ 时，$A_1 = A_3 = -\frac{m_B}{2m_A} A_2$ ，即两边原子运动状态相同，但与中间原子的运动方向相反，振幅之比为 $A_1 : A_2 = m_B: 2m_A$ ；</li>
<li>当 $\omega^2 = 0$ 时，$A_1 = A_2 = A_3$ ，系统做刚性平动。</li>
</ol>
<p>上面 $\omega^2$ 取三个根时，系统分别对应了三个不同的状态，其中除了 $\omega^2 = 0$ 外，其他两个状态都各自表明了一种特殊的振动模式，这些振动模式都对应了各自唯一的一个频率，称为<strong>简正频率</strong>。</p>
<p>一般来说，简正模时系统中各自由度运动的某种特殊组合，是整个系统的集体运动方式，不是其中个别振子的行为所决定的。</p>
<h1 id="来两道题小试牛刀"><a href="#来两道题小试牛刀" class="headerlink" title="来两道题小试牛刀"></a>来两道题小试牛刀</h1><h2 id="求下面系统的简正模"><a href="#求下面系统的简正模" class="headerlink" title="求下面系统的简正模"></a>求下面系统的简正模</h2><p>三个质量为 $m$ 的质点和三个劲度系数为 $k$ 的弹簧串连在一起，紧套在光滑的水平圆周上（如下图）。求此系统的简正模（即简正频率和运动方式）。</p>
<p><img src="http://owucpthrj.bkt.clouddn.com/FvHP-LeH9BzMuBco5XNJP2darkrV" width="400"></p>
<p>列出三个质点的动力学方程：<br>$$<br>\begin{aligned}<br>    m\frac{\mathrm d^2}{\mathrm dt^2} x_1&amp;= -k(2x_1 - x_2 - x_3) = k(x_2 + x_3 - 2x_1) \<br>    m\frac{\mathrm d^2}{\mathrm dt^2} x_2&amp;= -k(2x_2 - x_1 - x_3) = k(x_1 + x_3 - 2x_2) \<br>    m\frac{\mathrm d^2}{\mathrm dt^2} x_3&amp;= -k(2x_3 - x_1 - x_2) = k(x_1 + x_2 - 2x_3)<br>\end{aligned}<br>$$<br>不妨设 $x_i = \tilde{A_i}e^{\mathrm i \omega t}$ ，上面式子改写为<br>$$<br>\begin{aligned}<br>    -\omega^2 m A_1 e^{\mathrm i\omega t} &amp;= k( A_2 e^{\mathrm i\omega t} + A_3 e^{\mathrm i\omega t} - 2A_1 e^{\mathrm i\omega t} ) \<br>    -\omega^2 m A_2 e^{\mathrm i\omega t} &amp;= k( A_1 e^{\mathrm i\omega t} + A_3 e^{\mathrm i\omega t} - 2A_2 e^{\mathrm i\omega t} ) \<br>    -\omega^2 m A_3 e^{\mathrm i\omega t} &amp;= k( A_1 e^{\mathrm i\omega t} + A_2 e^{\mathrm i\omega t} - 2A_3 e^{\mathrm i\omega t} )<br>\end{aligned}<br>$$<br>经过化简，上面式子变为<br>$$<br>\begin{aligned}<br>    ( \omega^2-\frac{2k}{m} )A_1 + \frac{k}{m}A_2 + \frac{k}{m}A_3 &amp;= 0\<br>    \frac{k}{m}A_1 + ( \omega^2-\frac{2k}{m} )A_2 + \frac{k}{m}A_3 &amp;= 0\<br>    \frac{k}{m}A_1 + \frac{k}{m}A_2 + ( \omega^2-\frac{2k}{m} )A_2 &amp;= 0<br>\end{aligned}<br>$$</p>
<p>上述式子成立的条件是矩阵对应的行列式值为零<br>$$<br>\begin{vmatrix}<br>    ( \omega^2-\frac{2k}{m} )A_1 &amp; \frac{k}{m}A_2 &amp; \frac{k}{m}A_3 \<br>    \frac{k}{m}A_1 &amp; ( \omega^2-\frac{2k}{m} )A_2 &amp; \frac{k}{m}A_3 \<br>    \frac{k}{m}A_1 &amp; \frac{k}{m}A_2 &amp; ( \omega^2-\frac{2k}{m} )A_3<br>\end{vmatrix}<br>= 0<br>$$</p>
<p>注意到这是一个特殊的行列式，使用结论可以<del>口算</del>很快算出<br>$$<br>(\omega^2 - \frac{2k}{m} + 2\frac{k}{m}) (\omega^2 -\frac{2k}{m} - \frac{k}{m}) ^2 = 0<br>$$<br>得到三个根 $\omega_1 = 0$ ，$\omega_2 = \omega_3 = \sqrt{\frac{3k}{m}}$ 。</p>
<p>这三个根代入方程组都得出<br>$$<br>A_1 = A_2 = A_3<br>$$<br>即当这个系统趋于稳定时，三个质点的运动是一致的，整个系统做刚体的平动（绕圆盘圆心转动）。</p>
<h2 id="求下面振子的周期公式"><a href="#求下面振子的周期公式" class="headerlink" title="求下面振子的周期公式"></a>求下面振子的周期公式</h2><p>竖直悬挂的弹簧振子，若弹簧本身质量不可忽略，试推导其周期公式。假设弹簧的质量不可忽略，k为其劲度系数，M为系于其上物体的质量（假设弹簧的伸长量由上到下与长度成正比地增加）。</p>
<p><img src="http://owucpthrj.bkt.clouddn.com/FvTsySEGcax0xAS0Xa7MC3bQuS3q" width="150"></p>
<p>假设弹簧长度为 $L$ ，任意时刻 $M$ 的运动速度为 $v = v(t)$ ，则弹簧单位长度的质量为 $\mu = \frac{m}{L}$ ，又假设 $M$ 运动时弹簧上质点的速度是线性增加的，此时计算弹簧运动时的动能<br>$$<br>\begin{aligned}<br>V_{\rm spring} &amp;= \int\mathrm d \bigg(\frac{1}{2} m v^2 \bigg) \<br>        &amp;= \frac{1}{2} \int_{0}^{L} \bigg(\mu \mathrm dl \cdot (v\frac{l}{L})^2\bigg) \<br>        &amp;= \frac{mv^2}{2L^3} \int_{0}^{L} l^2 \mathrm d l \<br>        &amp;= \frac{1}{2}\cdot \frac{m}{3} v^2<br>\end{aligned}<br>$$<br> 即弹簧的运动动能相当于在其末端悬挂了一个质量为 $\frac{m}{3}$ 的质点运动时的动能，因此这个模型可以等效为一个质量为 0 的弹簧在其末端悬挂了质量 $M + \frac{m}{3}$ 的质点做简谐运动，套用简谐运动的角频率公式即可解出 $M$ 运动时的角频率为<br>$$<br>\begin{aligned}<br>    \omega &amp;= \sqrt{ \frac{k}{M + m/3} }\<br>    T &amp;= \frac{2\pi}{\omega} = 2\pi \sqrt{ \frac{M + m/3}{k} }<br>\end{aligned}<br>$$</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>简正模在刚开始看时还是挺费劲的，但是读了5遍左右就开始慢慢明白（大概是明白了吧，雾）了其物理含义，而在求解简正模时用到了线性代数的一点知识，算是复习了一下下线代，心里还是蛮开心的。最后那道题在看钱伯初先生的论文时对平均速度的求解目的不是很理解，后来经物吧腿娘大佬的正确指导下弄明白了如何应对这个问题。</p>
<p>关于振动，不出意外，本渣应该会写两篇浅析，这是第一篇，第二篇已经在计划中，希望有生之年可以见到。</p>
<p>以上</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://ionizing.science/2017/08/23/Coriolis-Force/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ionizing Radiation">
      <meta itemprop="description" content="伪化生的小窝">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ionizing's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2017/08/23/Coriolis-Force/" class="post-title-link" itemprop="url">浅谈科里奥利力</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2017-08-23 13:25:06" itemprop="dateCreated datePublished" datetime="2017-08-23T13:25:06+08:00">2017-08-23</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2018-12-31 19:47:25" itemprop="dateModified" datetime="2018-12-31T19:47:25+08:00">2018-12-31</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Physics/" itemprop="url" rel="index"><span itemprop="name">Physics</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          
            <span id="/2017/08/23/Coriolis-Force/" class="leancloud_visitors" data-flag-title="浅谈科里奥利力">
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              
                <span class="post-meta-item-text">Views: </span>
              
                <span class="leancloud-visitors-count"></span>
            </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>苯渣在补力学时卡在了科氏力这一节，经过 Mr. Ren , 物吧大佬以及 <a href="https://en.wikipedia.org/wiki/Coriolis_force" target="_blank" rel="noopener">Wikipedia</a> 上的详细解释，我总算稍稍弄懂了这个家伙到底是怎么产生的了，于是写下本文分享一下愚见。</p>
<h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p>坐过旋转木马的同学应该会有这样的体验：当坐在绕轴旋转的座位上向轴扔一个纸团（乱扔垃圾什么的最讨厌啦）时，纸团并不会砸到轴上，似乎纸团总是会偏离半径方向，并且总是偏向一个方向，这是为什么呢？这就要涉及到这篇文章要讲到的主角——科里奥利力。</p>
<h1 id="什么是科里奥利力？"><a href="#什么是科里奥利力？" class="headerlink" title="什么是科里奥利力？"></a>什么是科里奥利力？</h1><p>引用 Wikipedia 上的描述就是：</p>
<blockquote>
<p><strong>科里奥利力</strong>（简称：<strong>科氏力</strong>）是对旋转体系中进行直线运动的<a href="https://zh.wikipedia.org/wiki/%E8%B4%A8%E7%82%B9" target="_blank" rel="noopener">质点</a>由于<a href="https://zh.wikipedia.org/wiki/%E6%85%A3%E6%80%A7" target="_blank" rel="noopener">惯性</a>相对于旋转体系产生的直线运动的偏移的一种描述。此现象由法国著名数学家兼物理学家<a href="https://zh.wikipedia.org/wiki/%E7%A7%91%E9%87%8C%E5%A5%A7%E5%88%A9" target="_blank" rel="noopener">古斯塔夫・科里奥利</a>发现，因而得名；同时由于这种力在<a href="https://zh.wikipedia.org/wiki/%E5%9C%B0%E7%90%83%E8%87%AA%E8%BD%AC" target="_blank" rel="noopener">地球自转</a>下产生，因此又称为“<strong>地转偏向力</strong>”。</p>
</blockquote>
<p>个人理解：</p>
<blockquote>
<p>以一个旋转体系为参考系时，若研究对象相对于参考系的有非轴向运动的分量（或在垂直轴的平面内有运动分量）时，这个方向的运动分量会受到一个法向惯性力的作用而偏离原来的运动，这个力就是科里奥利力。</p>
</blockquote>
<p>上面的描述有两个要点：</p>
<ol>
<li>参考体系为旋转体系，这也就意味着该参考系是一个非惯性系，其中必然要考虑惯性力的作用；</li>
<li>研究对象相对于参考系有相对运动，并且这个运动在垂直轴向的平面内有分量。</li>
</ol>
<h1 id="科里奥利力如何产生？"><a href="#科里奥利力如何产生？" class="headerlink" title="科里奥利力如何产生？"></a>科里奥利力如何产生？</h1><h2 id="粗略的理解"><a href="#粗略的理解" class="headerlink" title="粗略的理解"></a>粗略的理解</h2><p>就拿引子里旋转木马的例子：</p>
<p>假设旋转木马是做匀速圆周运动，角速度为 $ \vec{\omega} $ ，读者轨迹半径为 $\vec{r}$ ，那么读者的公转线速度为<br>$$<br>\vec{v}_t = \vec{\omega} \times \vec{r} \notag<br>$$<br>如同这样：</p>
<p><img src="fig1.png" width="400"></p>
<p>（<strong>注意这里的变量用矢量表示</strong>）</p>
<p>朝径向，也就是 $-\vec{r}$ 方向扔一个纸团时，这个纸团既有朝向径向的速度 $\vec{v}_n$ ，又有线速度 $\vec{\omega}\times\vec{r}$ ，当其运动到圆内侧时，内侧的线速度<br>$$<br>\vec{v}’_t = \vec{\omega}\times\vec{r}’ &lt; \vec{\omega}\times\vec{r} = \vec{v}_t<br>$$<br>很自然地，纸团此时的切向速度比其所在圆上的的线速度更大，也就偏移了所谓的“直线”，读者视角俯视图见下图：</p>
<p><img src="fig2.svg" width="300"></p>
<p>从这里也可以看出，所谓的“力”事实上并不存在，纸团的偏转完全是纸团的切向速度大于圆周运动线速度而偏离原来的位置，平面内没有任何力的作用使其真正偏转——假如纸团不受空气阻力，在观众看来，纸团应该做抛体运动，自然其轨迹的俯视图为一条直线，但是当我们置身于旋转木马中时，它的确看起来有一个“力”使其“偏转”，这又如何解释呢？</p>
<p>问题出在我们<strong>置身于旋转木马中</strong>。</p>
<h2 id="更严格的推导"><a href="#更严格的推导" class="headerlink" title="更严格的推导"></a>更严格的推导</h2><p>继承上面的假设，旋转木马做匀速圆周运动，其可以看成一个<a href="https://en.wikipedia.org/wiki/Inertial_frame_of_reference" target="_blank" rel="noopener">非惯性系</a>，在这个参考系中，牛顿第一定律并不成立，为了使牛顿第一定律看起来成立，我们引入了<a href="https://en.wikipedia.org/wiki/Fictitious_force" target="_blank" rel="noopener">惯性力</a>。</p>
<p>现在，让我们做回观众：</p>
<p><img src="fig3.png" width="500"></p>
<p>显然有</p>
<p>$$<br>\vec{R}=\vec{r}<em>\perp = \vec{r} - \vec{r}</em>\parallel = \vec{r} - \frac{(\vec{r}\cdot\vec{\omega}) \cdot \vec{\omega}}{ {\omega}^2}<br>$$</p>
<p>将其简单变形</p>
<p>$$<br>{\omega}^2 \vec{R} = {\omega}^2 \vec{r} -(\vec{r}\cdot\vec{\omega}) \cdot \vec{\omega} = -\vec{\omega}\times(\vec{\omega}\times\vec{r})<br>$$</p>
<p>此时的 ${\omega}^2 \vec{R}$ 就是我们熟知的惯性离心加速度，方向与 $\vec{R}$ 一致，它也是惯性加速度的一种，但不是我们今天要研究的主角。</p>
<p>取一小段时间 $\Delta t$ ：</p>
<p><img src="fig4.png" width="300"></p>
<p>矢量 $\vec{P}$ 的增量为</p>
<p>$$<br>\Delta P \approx P\sin\theta\omega\Delta t=|\vec{\omega}\times \vec{P}|\Delta t<br>$$</p>
<p>$\Delta \vec{P}$方向与 $\vec{\omega}$ 和 $\vec{P}$ 的方向都垂直，即为 $\vec{\omega}\times\vec{P}$ 的方向，因此上式可以写为</p>
<p>$$<br>\Delta \vec{P} \approx\vec{\omega}\times \vec{P}\Delta t<br>$$</p>
<p>故 $\vec{P}$ 的变化率可以表示为其对时间的导数</p>
<p>$$<br>\frac{\mathrm{D}\vec{P}}{\mathrm{D}t} = \lim_{\Delta t\rightarrow0} \frac{\Delta\vec{P}}{\Delta t} = \vec{\omega} \times \vec{P}<br>$$<br>上式中大写的 $\mathrm D$ 表示以静止系统为参考系时各变量的微分，而小写的 $\mathrm d$ 则表示以旋转系统为参考系时变量的微分。上面式子中我们假定 $\vec{P}$ 在旋转体系中都是恒矢量，否则 $\vec{P}$ 的导数应该表示为</p>
<p>$$<br>\frac{\mathrm{D}\vec{P}}{\mathrm{D}t} = \lim_{\Delta t\rightarrow0} \frac{\Delta\vec{P}}{\Delta t} = \vec{\omega} \times \vec{P} + \frac{\mathrm d \vec{P}}{\mathrm d t}<br>$$</p>
<p>上式适用于任何矢量 $\vec{P}$ ，我们取一个质点的位矢 $\vec{r} = \vec{P}$ ，于是有</p>
<p>$$<br>\frac{\mathrm D \vec{r}}{\mathrm D t} = \vec{\omega}\times \vec{r} + \frac{\mathrm d\vec{r}}{\mathrm d t} = \vec{\omega}\times \vec{r} + \vec{v}<br>$$</p>
<p>其中的 $\vec{v}$ 表示质点相对于旋转体系的速度矢量。对上式再次求导，即得到加速度</p>
<p>$$\begin{aligned}<br>\vec{A} = \frac{\mathrm D^2 \vec{r}}{\mathrm D t^2} &amp;= \vec{\omega}\times\frac{\mathrm D\vec{r}}{\mathrm D t} + \frac{\mathrm d \vec{v}}{\mathrm dt} \<br>    &amp;= \vec{\omega}\times(\vec{\omega}\times \vec{r} + \vec{v}) + (\vec{\omega}\times\vec{v} + \frac{\mathrm d\vec{v}}{\mathrm d t}) \<br>    &amp;= \vec{\omega}\times(\vec{\omega}\times \vec{r} ) + 2\vec{\omega}\times\vec{v} + \vec{a}<br>\end{aligned}$$</p>
<p>因此</p>
<p>$$<br>\vec{a} =\vec{A} - \vec{\omega}\times(\vec{\omega}\times\vec{r}) - 2\vec{\omega}\times\vec{v}<br>$$<br>上式中 $\vec{a}$ 表示质点相对于旋转体系的加速度，$\vec{A}$ 是由真实的力提供的加速度，后面两项都是“假想”存在的加速度，即惯性加速度。其中 $-\vec{\omega}\times(\vec{\omega}\times\vec{r})$ 是我们已知的惯性离心加速度，另一项 $-2\vec{\omega}\times\vec{r}$ 就是<strong>科里奥利加速度</strong>，我们用 $\vec{a}_c$ 表示，有了科里奥利加速度，就得到科里奥利力 $\vec{f}_c = m\vec{a}_c$ 。</p>
<p>根据右手定则，可以判断出其始终垂直于质点相对于旋转体系的速度，因此，质点相对于旋转体系运动时出现偏转也就很自然了。</p>
<h1 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h1><p>既然知道了科里奥利力是如何产生，那么知道这个东西对我们有什么用处呢？<del>（可以拿来装X）</del> </p>
<h2 id="可以拿来侧纬度啦"><a href="#可以拿来侧纬度啦" class="headerlink" title="可以拿来侧纬度啦~"></a>可以拿来侧纬度啦~</h2><p>我们所置身的地球就是一个旋转体系，只是它旋转得太慢了，平时难以察觉到科里奥利力的存在，但是有一种东西可以反映出科里奥利力的存在，那就是<a href="https://en.wikipedia.org/wiki/Foucault_pendulum" target="_blank" rel="noopener">傅科摆</a> ，如果你有足够的耐心观察它足够长的时间并确定它进动周期，你就可以很容易算出你所在位置的纬度，后面我们会给上推导这个公式的过程。</p>
<p>为了理解如何通过傅科摆的进动角速度确定纬度，我们先来看一个简单的例子：</p>
<p><img src="fig5.png" width="500"></p>
<p>一个可以旋转的圆盘上有一个单摆，当缓慢旋转圆盘时，我们假设惯性离心力很小，只有科里奥利力作用于单摆运动的切向。 当我们旋转圆盘 $90^\circ$ 时，在静止体系观看单摆的摆平面没有任何变化，只是单纯的平移而已，没有任何转动，但是当以圆盘为参考系时（坐在 $C’$ 的位置向 $A$ 看），单摆的摆平面已经旋转了 $90^\circ$ ，因此以圆盘的视角来观察这个现象时单摆进动的角速度就是圆盘转动的角速度。</p>
<p>下面的动画应该很形象了：</p>
<p><img src="fig5.gif"></p>
<p>现在，我们让将摆线放大到67m长；将圆盘换成南极点的地面（相信这么做一定会有一群好奇的企鹅来围观）；讲缓慢转动圆盘换成地球大大的缓慢自转，这个上面的结论依然成立（当然如果你有上帝视角来看极点上的单摆进动，会更容易明白，就像看懂上面小圆盘上的单摆一样）。</p>
<p>接下来，让我们把情况更加一般化，将这个巨大的单摆放到地球的任何可行的位置，问题变成了旋转球面上直线运动的进动问题，话不多说，看图：</p>
<p><img src="fig6_1.png" width="400"></p>
<p>假设有一单摆在 $C$ 点（三个蓝点中最下面的那个），且在 $C$ 点建立一个坐标系（为了不使图更乱，我就不画了），平面 $CAE$ <del>（说得装X一些叫“C点所在子午面”）</del>如下：</p>
<p><img src="fig6_2.svg" width="150"></p>
<p>其中 $A$ 是球心， $AC$ 是半径， $CE \perp CA$ 并且 $E$ 落在自转轴上，$\angle \psi$ 表示纬度，$\angle \theta$ 则是 $\angle \psi$ 的余角。</p>
<p>我们取一小段时间 $\Delta t$ ，由于地球的自转，单摆从 $C$ 点运动到 $D$ 点，那么 $D$ 点出坐标系的 $y’$ 轴与 $C$ 点处 $y$ 轴所成夹角即为坐标系偏转的角度 $\angle \text{看这里}$ （如下图），这个角度也就是在 $\Delta t$ 时间内单摆进动的角度，现在只要求出 $\angle \text{看这里}$ 与 $\omega \Delta t$ 之间的关系即可求出单摆进动角速度与地球自转角速度的关系。</p>
<p><img src="fig6_3.svg" width="300"></p>
<p>下面来求这个关系：</p>
<p>$$\begin{aligned}<br>\angle \text{看这里} = \angle CED  &amp;=  \frac {\widehat{CD}}{CE} \<br>                    &amp; = \frac{ CE \times \sin\psi \times \omega\Delta t }{ CE } \<br>                    &amp; = \omega\Delta t \sin\psi<br>\end{aligned}$$</p>
<p>于是，单摆进动的角速度为</p>
<p>$$\begin{aligned}<br>\varOmega &amp; = \lim_{\Delta t \rightarrow 0} \frac{\angle \text{看这里}} {\Delta t} \<br>        &amp; = \omega \sin \psi<br>\end{aligned}$$</p>
<p>上面式子表明，当 $\psi = \pm 90 ^ \circ$ 时，$\varOmega = \omega$ ，即当单摆处于极点时，其进动角速度等于地球自转角速度，也就是我们开始时提到单摆在圆盘时的情形。</p>
<p>好了，现在回到傅科摆，只要我们观察足够长的时间，测量出其轨迹的进动角速度，又已知地球自转角速度，便可以轻松算出傅科摆所在的纬度。</p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>这是我在补《力学》时卡住的一个知识点，之前心中总把科里奥利力想象成惯性离心力那样，导致看到傅科摆时完全不知道如何理解，经过请教群友，老师以及动手画图实验，总算稍稍理解了，上面便是本渣的一点愚见，如有疏漏，还请在评论区指出，或邮件联系（联系方式见关于页面）。</p>
<p>以上</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://ionizing.science/2017/06/30/Quantum-Physics-Learning-Log-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ionizing Radiation">
      <meta itemprop="description" content="伪化生的小窝">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ionizing's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2017/06/30/Quantum-Physics-Learning-Log-1/" class="post-title-link" itemprop="url">量子力学学习手记（一）</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2017-06-30 21:28:24" itemprop="dateCreated datePublished" datetime="2017-06-30T21:28:24+08:00">2017-06-30</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2018-12-31 19:47:25" itemprop="dateModified" datetime="2018-12-31T19:47:25+08:00">2018-12-31</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Quantum-Mechanics/" itemprop="url" rel="index"><span itemprop="name">Quantum Mechanics</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          
            <span id="/2017/06/30/Quantum-Physics-Learning-Log-1/" class="leancloud_visitors" data-flag-title="量子力学学习手记（一）">
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              
                <span class="post-meta-item-text">Views: </span>
              
                <span class="leancloud-visitors-count"></span>
            </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><ol>
<li>这篇手记仅为自己学习记录而写。</li>
<li>虽然题目提到量子力学，但内容与量子力学关系不大，事实是这篇文章提到的某些概念以及方法在以后学习中十分普遍，因此有必要将其归为量子力学学习手记。</li>
<li>就当这是在打数学基础好了。</li>
</ol>
<h1 id="符号说明"><a href="#符号说明" class="headerlink" title="符号说明"></a>符号说明</h1><table>
<thead>
<tr>
<th>符号</th>
<th>说明，以下符号表示的量是在 <em>复数范围</em> 内讨论的</th>
</tr>
</thead>
<tbody>
<tr>
<td>$\mid i\rangle$</td>
<td>ket，也称列向量</td>
</tr>
<tr>
<td>$\langle i\mid$</td>
<td>bra，也称行向量</td>
</tr>
<tr>
<td>$\langle i\mid  j \rangle $</td>
<td>inner product，求向量$\langle i\mid $与向量$\mid j\rangle$的内积</td>
</tr>
<tr>
<td>$\mid  i \rangle \langle j \mid  $</td>
<td>outer product，求向量$\mid i\rangle$与向量$\langle j\mid $的外积</td>
</tr>
<tr>
<td>$\mid i\rangle ^\dagger$</td>
<td>transpose conjugate，共轭转置，即向量每个元素取共轭复数后整体转置，$\mid i\rangle ^\dagger = \langle i^*\mid $</td>
</tr>
<tr>
<td>$\Omega$, $\Lambda$</td>
<td>算子，或称算符，由函数组成的矩阵</td>
</tr>
<tr>
<td>$\Omega^\dagger$</td>
<td>对 $\Omega$ 取共轭转置</td>
</tr>
</tbody>
</table>
<h1 id="题目重现"><a href="#题目重现" class="headerlink" title="题目重现"></a>题目重现</h1><p>如图，两个振子组成一维耦合振子，两质点的质量均为$m$，所有弹簧劲度系数均为$k$，以右为正方向，两者位移分别为$x_1$、$x_2$。若两振子初始速度均为零，设两个振子在各自平衡位置时的位移为０，且初始位置未知，求这两个振子的位移-时间函数即$x_i(t)$。</p>
<p><img src="fig.svg" alt="耦合振子示意图"></p>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>​    对两个振子分别分析，不妨设左边振子为1号，右边振子为2号。</p>
<p>​    对1号振子做受力分析：</p>
<p>$$<br>m \frac{\mathrm{d}^2 x_1}{\mathrm{d}t^2} = k(x_2 - x_1) - k{x_1}<br>$$<br>​    即</p>
<p>$$<br>m\ddot{x_1} = -2kx_1+kx_2 \notag<br>$$</p>
<p>​    同理，2号振子满足<br>$$<br>m\ddot{x_2} = k{x_1} - 2kx_2  \notag<br>$$<br>​    问题化简为求微分方程组<br>$$<br>\begin{cases}<br>    \ddot{x_1} = -\frac{2k}{m}x_1 + \frac{k}{m}x_2\<br>    \ddot{x_2} = \frac{k}{m}x_1 - \frac{2k}{m}x_2<br>\end{cases}<br>$$<br>​    的解，写成矩阵形式即为<br>$$<br>\begin{bmatrix}<br>    \ddot{x_1}\<br>    \ddot{x_2}<br>\end{bmatrix} = \begin{bmatrix}<br>    \frac{-2k}{m} &amp; \frac{k}{m}\<br>    \frac{k}{m} &amp; \frac{-2k}{m}<br>\end{bmatrix} \begin{bmatrix}<br>    x_1\<br>    x_2<br>\end{bmatrix}<br>$$<br>​    现令$\Omega=\begin{bmatrix} \frac{-2k}{m} &amp; \frac{k}{m}\  \frac{k}{m} &amp; \frac{-2k}{m} \end{bmatrix} $</p>
<p>​    观察到 $\Omega$ 为Hermitian矩阵（$\Omega^\dagger = \Omega$，共轭转置后不变），</p>
<p>​    故设$\mid\mathrm{I}\rangle $和$\mid\mathrm{II}\rangle $分别为$\Omega$的两个本征矢（也叫特征向量）</p>
<p>​    有<br>$$<br>\begin{cases}<br>    \Omega \mid \mathrm{I} \rangle = -\omega_\mathrm{I}^2 \mid \mathrm{I}\rangle\<br>    \Omega \mid \mathrm{II} \rangle = -\omega_\mathrm{II}^2 \mid \mathrm{II}\rangle<br>\end{cases}<br>$$<br>​    这里$-\omega_\mathrm{I}^2$与$-\omega_\mathrm{II}^2$分别表示$\Omega$的两个本征值，因计算结果表示方便，这里用$-\omega_i^2$表示，而不是$\omega_i$。</p>
<p>​    求出$-\omega_\mathrm{I}^2$与$-\omega_\mathrm{II}^2$分别为$\frac{k}{m} \mp \frac{2k}{m}$。不妨设$-\omega_\mathrm{I}^2＝-\frac{k}{m}$，$-\omega_\mathrm{II}^2＝-\frac{3k}{m}$。</p>
<p>​    已知本征值，可以求出本征矢为<br>$$<br>\begin{cases}<br>    \mid \mathrm{I}\rangle = \frac{1}{\sqrt{2}} \begin{bmatrix} 1 \ 1 \end{bmatrix} &amp; \omega_\mathrm{I}=\sqrt{\frac{k}{m}} \<br>    \mid \mathrm{II} \rangle = \frac{1}{\sqrt{2}} \begin{bmatrix} 1 \ -1 \end{bmatrix}  &amp; \omega_\mathrm{II}=\sqrt{\frac{3k}{m}}<br> \end{cases}<br>$$</p>
<p>​    可以看出$\mid \mathrm{I} \rangle$与$\mid \mathrm{II}\rangle$相互正交（内积为０）。</p>
<p>​    因此$x(t)= \mid \mathrm{I}\rangle x_1(t) +\mid \mathrm{II}\rangle x_2(t)$。</p>
<p>​    到这里，上面的步骤相当于对空间基矢进行了变换，原先的基矢为<br>$x_1(t)$对应$\mid 1 \rangle = \begin{bmatrix} 1 \ 0 \end{bmatrix}$，$x_2(t)$对应$\mid 2 \rangle = \begin{bmatrix} 0 \ 1 \end{bmatrix}$，现变换为$x_\mathrm{I}$对应$\mid \mathrm{I} \rangle =\frac{1}{\sqrt{2}} \begin{bmatrix} 1 \ 1 \end{bmatrix}$，$x_\mathrm{II}$对应$\mid \mathrm{II} \rangle =\frac{1}{\sqrt{2}} \begin{bmatrix} 1 \ -1 \end{bmatrix}$。这样做有什么好处呢？好处马上就会呈现。</p>
<p>​    此时$\Omega$可以对角化为<br>$$<br>\Omega =<br>\begin{bmatrix}<br>    -\omega_\mathrm{I}^2 &amp; 0 \<br>    0 &amp; -\omega_\mathrm{II}^2<br>\end{bmatrix}<br>$$</p>
<p>​    故原方程式可以化为</p>
<p>$$<br>\begin{bmatrix}<br>    \ddot{x_\mathrm{I}} \<br>    \ddot{x_\mathrm{II}}<br>\end{bmatrix}<br>=<br>\begin{bmatrix}<br>    -\omega_\mathrm{I}^2 &amp; 0 \<br>    0 &amp; -\omega_\mathrm{II}^2<br>\end{bmatrix}<br>\begin{bmatrix}<br>    x_\mathrm{I} \<br>    x_\mathrm{II}<br>\end{bmatrix}<br>=<br>\begin{bmatrix}<br>    -\omega_\mathrm{I}^2 x_\mathrm{I} \<br>    -\omega_\mathrm{II}^2 x_\mathrm{II}<br>\end{bmatrix}<br>$$</p>
<p>​    此时分别解$\ddot{x_\mathrm{I}}$与$\ddot{x_\mathrm{II}}$（两个二阶线性微分方程$\ddot{x_i} + \omega_i^2 x_i = 0$，并且$\dot{x_i}$=0），即可得到$x_i (t),\quad i=\mathrm{I,II}$的解，解为<br>$$<br>x_i(t) = x_i(0) \cos\omega_i t, \quad i=\mathrm{I,II}<br>$$</p>
<p>​    此时我们离胜利已经很近了——已经得到<br>$$<br>\begin{aligned}<br>    \mid x(t) \rangle &amp; = \mid \mathrm{I} \rangle x_\mathrm{I}(0)\cos\omega_\mathrm{I}t + \mid \mathrm{II} \rangle x_\mathrm{II}(0)\cos\omega_\mathrm{II}t \<br>    &amp; = \mid \mathrm{I}\rangle\langle\mathrm{I}\mid x(0)\rangle \cos\omega_\mathrm{I}t + \mid \mathrm{II}\rangle\langle\mathrm{II}\mid x(0)\rangle \cos\omega_\mathrm{II}t<br>\end{aligned}<br>$$</p>
<p>​    式中<br>$$<br>\begin{aligned}<br>    \langle \mathrm{I} \mid x(0) \rangle &amp;= \frac{1}{\sqrt{2}} \begin{bmatrix} 1 &amp; 1 \end{bmatrix} \begin{bmatrix} x_1(0) \ x_2(0) \end{bmatrix} = \frac{x_1(0)+x_2(0)}{\sqrt{2}} \<br>    \langle \mathrm{II} \mid x(0) \rangle &amp;= \frac{1}{\sqrt{2}} \begin{bmatrix} 1&amp; -1 \end{bmatrix} \begin{bmatrix} x_1(0) \ x_2(0) \end{bmatrix} = \frac{x_1(0) - x_2(0)}{\sqrt{2}}<br>\end{aligned}<br>$$</p>
<p>​    $\therefore \mid x(t)\rangle = \mid \mathrm{I}\rangle \frac{x_1(0)+x_2(0)}{\sqrt{2}} + \mid \mathrm{II}\rangle \frac{x_1(0) - x_2(0)}{\sqrt{2}}$</p>
<p>​    我们需要将$\mid \mathrm{I}\rangle$和$\mid \mathrm{II}\rangle$还原为$\mid 1\rangle$和$\mid 2\rangle$，这个操作可以通过投影 <code>projection</code> 来实现：<br>$$<br>\begin{aligned}<br>    x_1(t) =&amp; \langle 1 \mid x(t)\rangle \<br>        =&amp; \langle 1 \mid \mathrm{I}\rangle \frac{x_1(0) + x_2(0)}{\sqrt{2}}\cos\omega_\mathrm{I}t + \langle 1 \mid \mathrm{II}\rangle \frac{x_1(0) - x_2(0)}{\sqrt{2}}\cos\omega_\mathrm{II}t \<br>        =&amp; \frac{x_1(0) + x_2(0)}{2}\cos\left(\sqrt{\frac{k}{m}}t\right) + \frac{x_1(0) - x_2(0)}{2}\cos\left(\sqrt{\frac{3k}{m}}t\right)<br>\end{aligned}<br>$$<br>​    同理<br>$$<br>x_2(t)= \frac{x_1(0) + x_2(0)}{2}\cos\left(\sqrt{\frac{k}{m}}t\right) - \frac{x_1(0) - x_2(0)}{2}\cos\left(\sqrt{\frac{3k}{m}}t\right)<br>$$<br>​    写成矩阵形式即为<br>$$<br>\begin{bmatrix} x_1(t) \ x_2(t)  \end{bmatrix}<br>=<br>\begin{bmatrix}<br>    \frac{\cos\left(\sqrt{\frac{k}{m}}t\right) + \cos\left(\sqrt{\frac{3k}{m}}t\right) }{2} &amp; \frac{\cos\left(\sqrt{\frac{k}{m}}t\right) - \cos\left(\sqrt{\frac{3k}{m}}t\right) }{2} \<br>    \frac{\cos\left(\sqrt{\frac{k}{m}}t\right) - \cos\left(\sqrt{\frac{3k}{m}}t\right) }{2} &amp; \frac{\cos\left(\sqrt{\frac{k}{m}}t\right) + \cos\left(\sqrt{\frac{3k}{m}}t\right) }{2}<br>\end{bmatrix}<br>\begin{bmatrix} x_1(0) \ x_2(0) \end{bmatrix}<br>$$<br>​    此时，只要给出$\mid x(0)\rangle$即可得到整个耦合振子系统的运动方程。结束战斗。</p>
<h1 id="收获总结"><a href="#收获总结" class="headerlink" title="收获总结"></a>收获总结</h1><p>​    在Shankar上看到这道题的题解时，起初是不怎么明白的，直到在写这篇手记的过程中，我才体会到这样解的用意：</p>
<ol>
<li>这是一个耦合系统，即两个微分方程分别含有对方的变量。</li>
<li>求出$\mid \mathrm{I}\rangle$与$\mid \mathrm{II}\rangle$的过程就是在对原有的线性空间基矢（或称基底）做变换，变换的目的是为了将微分方程组转化为非耦合的方程组。这里，个人以为，说的通俗一些，就是换元——在高等数学的某些求解不定积分时也会用到这种方法。</li>
<li>求算子$\Omega$的本征值就是为了将其对角化（对角化后只有对角线上元素不为零），做矩阵乘法运算就可以得到非耦合的方程组，然后问题就变成了熟悉的二阶线性微分方程，之后求解需要用到欧拉公式，这里不赘述。</li>
<li>用矩阵表示大块方程组真的很方便！</li>
<li>Ti$k$Z很好用！</li>
</ol>
<p>虽然说上面的题解基本是翻译过来的，但也是有一些收获的，权当 <code>拾人牙慧吧</code> 。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://ionizing.science/2017/06/26/PhysChem-Revise-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ionizing Radiation">
      <meta itemprop="description" content="伪化生的小窝">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ionizing's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2017/06/26/PhysChem-Revise-1/" class="post-title-link" itemprop="url">物理化学复习札记（一）：理想气体热力学量求解总结</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2017-06-26 17:07:41" itemprop="dateCreated datePublished" datetime="2017-06-26T17:07:41+08:00">2017-06-26</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2018-12-31 19:47:25" itemprop="dateModified" datetime="2018-12-31T19:47:25+08:00">2018-12-31</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Physical-Chemistry/" itemprop="url" rel="index"><span itemprop="name">Physical Chemistry</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          
            <span id="/2017/06/26/PhysChem-Revise-1/" class="leancloud_visitors" data-flag-title="物理化学复习札记（一）：理想气体热力学量求解总结">
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              
                <span class="post-meta-item-text">Views: </span>
              
                <span class="leancloud-visitors-count"></span>
            </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>这是这个系列的第一篇，也是第一次写这种类型的札记，如果有纰漏，还请在评论区指出，谢谢各位！</strong></p>
<h2 id="热力学量说明"><a href="#热力学量说明" class="headerlink" title="热力学量说明"></a>热力学量说明</h2><p>物理化学中，热力学主要研究7个热力学量，这7个量如下：</p>
<ol>
<li>$U$，系统的热力学能，或称内能，属于状态函数，$U=f(T)$，无法求出$U$的值，但可以求出$\Delta U$的值，单位为J；</li>
<li>$Q$，系统与环境交换的热量，当系统放热时，$Q$为负值；系统吸热，则$Q$为正值，单位为J；</li>
<li>$W$，环境对系统所做的功，分为体积功和非体积功，单位为J；</li>
<li>$H$，焓，定义为 $H=U+pV$，无实际含义，仅为计算方便而产生，属于状态函数，$H=f(T)$，与$U$一样，无法求出$H$的值，但可以求出$\Delta H$的值，单位为J；</li>
<li>$S$，大名鼎鼎的熵，定义为$S=\int_A^B (\dfrac{\delta Q}{T})_R$，属于状态函数，处于绝对零度时完美晶体的熵为0，单位J$\cdot $K$^{-1}$</li>
<li>$A$，亥姆霍兹自由能，定义为$A=U-TS$，为状态函数，无法求出$A$的值，但可以求出$\Delta A$的值，单位为J；</li>
<li>$G$，吉布斯自由能，定义为$G=H-TS$，为状态函数，无法求出$G$的值，但可以求出$\Delta G$的值，单位为J；</li>
</ol>
<p>以上说明中，状态函数是指当系统状态一定时，其值即确定，亦即在某个过程中其变化量$\Delta f$只与始末状态有关，与过程细节无关。这个性质<strong>非常重要</strong>，物理化学常见的设计过程求解热力学量的理论基础即在于此。</p>
<h2 id="热力学四大定律"><a href="#热力学四大定律" class="headerlink" title="热力学四大定律"></a>热力学四大定律</h2><p>是的，热力学有四大定律，分别为热力学第零定律、热力学第一定律、热力学第二定律和热力学第三定律。</p>
<h3 id="热力学第零定律"><a href="#热力学第零定律" class="headerlink" title="热力学第零定律"></a>热力学第零定律</h3><p><strong>如果两个系统分别与处于确定状态的第三个系统达到热平衡，则这两个系统彼此也将处于热平衡。</strong></p>
<p>这个定律定义了温度的概念，当两个系统相互接触处于热平衡后，它们的性质不再变化，我们称之具有相同的温度。而定义中提到的第三系统为温度计的产生奠定了理论基础。</p>
<h3 id="热力学第一定律"><a href="#热力学第一定律" class="headerlink" title="热力学第一定律"></a>热力学第一定律</h3><p><strong>在变化过程中，系统的热力学能变化量表示为系统和环境的热交换量与外界对系统所做功的总和。</strong><br>写成公式即为 $ \Delta U = Q + W $，<br>或者写成微分形式$ \mathrm{d}U = \delta Q + \delta W $</p>
<h3 id="热力学第二定律"><a href="#热力学第二定律" class="headerlink" title="热力学第二定律"></a>热力学第二定律</h3><p>文字可表述为：</p>
<blockquote>
<p>克劳修斯表述：不可能把热从低温物体传到高温物体，而不引起其他变化；<br>开尔文表述：不可能从单一热源取出热使之完全变为功，而不发生其他变化。</p>
</blockquote>
<p>数学形式：</p>
<ul>
<li>克劳修斯不等式表述形式：$ \Delta S_{A\to B}-\sum_A^B \dfrac{\delta Q}{T} \geq 0 $</li>
<li>常用表述形式：$ \mathrm{d}S - \dfrac{\delta Q}{T} \geq 0 $</li>
</ul>
<p>上式表明，在一个隔离系统中，熵永不减少。 隔离系统是绝热的，即$\delta Q=0$，因此$\mathrm{d}S_{\mathrm{iso}} \geq 0$。</p>
<h3 id="热力学第三定律"><a href="#热力学第三定律" class="headerlink" title="热力学第三定律"></a>热力学第三定律</h3><p>可以表述为<strong>在温度趋于热力学温度0K的等温过程中，系统的熵值不变 </strong>，也可以表述为“<strong>在0K时，任何完美晶体的熵等于零</strong>”，还可以表述为”<strong>绝对零度不可能达到</strong>“。</p>
<h2 id="特殊过程的热力学量求值"><a href="#特殊过程的热力学量求值" class="headerlink" title="特殊过程的热力学量求值"></a>特殊过程的热力学量求值</h2><p><strong>本节所有过程均为$p$,$V$,$T$过程，不考虑非体积功！</strong></p>
<p>常见的变化过程（均为理想气体的变化过程）有：</p>
<ol>
<li>等温过程：系统由状态1变到状态2，变化过程中以及始态和终态的温度不变，<strong>且等于环境温度</strong>；</li>
<li>等压过程：系统在变化过程中，始态和终态压力相等，且等于环境压力；</li>
<li>等容过程：系统在变化过程中保持体积不变。在刚性容器中发生的变化一般是等容过程；</li>
<li>绝热过程：系统在变化过程中与环境之间没有热的交换，或者是由于有绝热壁的存在，或者是因为变化太快而与环境来不及热交换，或者热交换量极少可近似看作是绝热过程；</li>
<li>环状过程：系统从始态出发，经过一系列变化后又回到了原来状态。经此过程，所有状态函数的变化量都为零。</li>
</ol>
<p>另外，自由膨胀过程可以看为外压恒为0的等压膨胀过程；节流膨胀过程属于实际气体的不可逆过程，不在本札记讨论范围内。</p>
<h3 id="自由膨胀过程"><a href="#自由膨胀过程" class="headerlink" title="自由膨胀过程"></a>自由膨胀过程</h3><p>此过程不可逆，可看作外压恒为零的等压过程。</p>
<ul>
<li>$\Delta U=0$，由<code>Gay-Lussac-Joule</code>实验得出，而$U=f(T)$，故此过程中气体$T$不变；</li>
<li>$W=0$，显然，自由膨胀时外压恒为零，也无非体积功，故$W=0$；</li>
<li>$Q=0$，由热力学第一定律，$\Delta U=Q+W$，式中$\Delta U=0$，$W=0$，因此$Q=0$；</li>
<li>$\Delta H=0$，$H$是状态函数，由上文气体$T$不变可以推出$H$不变。 另外也可由公式$\Delta H=\Delta U + \Delta(pV)$，$pV=nRT$（n、T不变，所以$pV$不变）推出$\Delta H=0$；</li>
<li>$\Delta S&gt;0$，显然该过程不可逆，其对应的可逆过程为等温可逆膨胀，计算得$\Delta S=\int\dfrac{\delta Q}{T} = \dfrac{Q}{T} = nR\ln\dfrac{V_2}{V_1} = -nR\ln\dfrac{p_2}{p_1}$；</li>
<li>$\Delta G&lt;0​$，由公式$\Delta G=\Delta H-\Delta (TS)​$，并且$\Delta H=0​$、$T​$不变得出$\Delta G=-T\Delta S​$；</li>
<li>$\Delta A&lt;0$，与计算$\Delta G$的过程类似，$\Delta A=-T\Delta S$。</li>
</ul>
<h3 id="等温可逆过程"><a href="#等温可逆过程" class="headerlink" title="等温可逆过程"></a>等温可逆过程</h3><p>此过程满足 $pV=nRT=\mathrm{Constant}$。</p>
<ul>
<li>$\Delta U=0$，$U$为状态函数，等温过程系统温度不变，因此$U$不变、$\Delta U=0$；</li>
<li>$W$，由公式$W=-\int_{V_1}^{V_2}p_{\mathrm{e}}\mathrm{d}V$，且$p_e=p=\dfrac{nRT}{V}$（可逆过程中环境压力始终近似于系统压力），所以$W=-nRT\int_{V_1}^{V^2} \dfrac{1}{V} \mathrm{d}V=-nRT\ln\dfrac{V_2}{V_1}$；此外，若已知系统的始末压力，也可以将前式变换为$W=nRT\dfrac{p_1}{p_2}$</li>
<li>$Q$，由热力学第一定律，$\Delta U=W+Q$，得$Q=-W=nRT\ln\dfrac{V_2}{V_1}$；</li>
<li>$\Delta H$，与$U$类似，为状态函数，$\Delta H=0$；</li>
<li>$\Delta S$，此过程已经为可逆过程，不必再设计可逆过程。因此$\Delta S=\int\dfrac{\delta Q}{T} = \dfrac{Q}{T} = nR\ln\dfrac{V_2}{V_1} = -nR\ln\dfrac{p_2}{p_1}$；</li>
<li>$\Delta G$，直接代入公式$\Delta G=\Delta H-\Delta(TS)$，得$\Delta G=-nRT\ln\dfrac{V_2}{V_1}=nRT\ln\dfrac{p_2}{p_1}=W $；</li>
<li>$\Delta A$，同$\Delta G$，得到$\Delta A=\Delta G=W=-nRT\ln\dfrac{V_2}{V_1}=nRT\ln\dfrac{p_2}{p_1} $。</li>
</ul>
<h3 id="等压过程"><a href="#等压过程" class="headerlink" title="等压过程"></a>等压过程</h3><p>此过程满足 $\dfrac{nRT}{V}=\text{Constant}$</p>
<ul>
<li>$\Delta U$，此时$\Delta U\neq 0$，应用公式$\Delta U=Q_{\mathrm{V}}=nC_{\mathrm{V,m}} (T_2 - T_1)=\dfrac{p}{R}C_{\mathrm{V,m}} (V_2-V_1)$计算。单原子分子理想气体的$C_\mathrm{V,m}=\dfrac{3}{2}R$。</li>
<li>$W​$，显然 $W=-\int_{V_1}^{V_2}p_e\mathrm{d}V=p(V_2 - V_1)​$；</li>
<li>$Q$，等压过程中的热交换量用$Q_\mathrm{p}$表示，并且$Q_\mathrm{p}=nC_\mathrm{p,m}\Delta T$或者使用$C_\mathrm{p,m}=C_\mathrm{V,m}+R$以及$Q=\Delta U-W$求解。</li>
<li>$\Delta H$，直接使用公式$\Delta H = \Delta U + \Delta(pV) = nC_\mathrm{P,m}(T_2-T_1)$</li>
<li>$\Delta S$，等压过程对应的可逆过程为物体的可逆加热或冷却，有$\delta Q_R=C\mathrm{d}T=nC_\mathrm{p,m}\mathrm{d}T$，因此，$\Delta S = \int_{T_A}^{T_B} \dfrac{nC_\mathrm{p,m}}{T}\mathrm{d}T=nC_\mathrm{p,m}\ln\dfrac{T_{B}}{T_{A}} $，根据公式$pV=nRT$可以求出$T$，这里不再对式子进行展开；</li>
<li>$\Delta G$，直接代入式子$\Delta G=\Delta H-\Delta(TS)$即可（题目会给出气体的标准摩尔熵，结合上面的$\Delta S$可以使用$\Delta (TS)=T_2 n(S_m+\Delta S) - T_1 nS_m$求出$\Delta G$）；</li>
<li>$\Delta A$，同$\Delta G$，直接代入$\Delta A=\Delta U-\Delta (TS)$求解。</li>
</ul>
<h3 id="等容过程"><a href="#等容过程" class="headerlink" title="等容过程"></a>等容过程</h3><p>此过程满足$\dfrac{nRT}{p}=\mathrm{Constant}$。</p>
<ul>
<li>$\Delta U$，与等压过程一样，直接使用公式$\Delta U=Q_\mathrm{V}=nC_\mathrm{V,m}\Delta T$。单原子分子理想气体的$C_\mathrm{V,m}=\dfrac{3}{2}R $；</li>
<li>$W$，因为体积无变化，$\mathrm{d}V=0$，故$W=\int_{V_1}^{V_2} p\mathrm{d}V=0$；</li>
<li>$Q$，等容过程的热交换量也成为恒容热$Q_\mathrm{V}$，$Q_\mathrm{V}=nC_\mathrm{V,m}\Delta T$；</li>
<li>$\Delta H$，可以结合式子$pV=nRT$求出$\Delta (pV)=nR\Delta T$，最后代入$\Delta H=\Delta U-\Delta (PV)$求出$\Delta H$；</li>
<li>$\Delta S$，等容过程对应的可逆过程为物体的可逆加热或冷却，有$\delta Q_R=C\mathrm{d}T=nC_\mathrm{V,m}\mathrm{d}T$，因此，$\Delta S = \int_{T_A}^{T_B} \dfrac{nC_\mathrm{V,m}}{T}\mathrm{d}T=\Delta S=nC_\mathrm{V,m}\ln\dfrac{T_{B}}{T_{A}} $，根据公式$pV=nRT$可以求出$T$，这里不再对式子进行展开；</li>
<li>$\Delta G$，同等压过程，因为温度发生改变，必须知道$S$的初始值才能计算出$\Delta (TS)$，所以题目会给出或间接给出$S$，此时直接代入公式$\Delta  G=\Delta H-\Delta (TS)$即可求出吉布斯自由能的变化值；</li>
<li>$\Delta A$，与$\Delta G$类似，仅将$\Delta H$替换为$\Delta U$其余不变，即可计算出亥姆霍兹自由能的变化值。</li>
</ul>
<h3 id="绝热可逆过程"><a href="#绝热可逆过程" class="headerlink" title="绝热可逆过程"></a>绝热可逆过程</h3><p>这是一个非常重要的过程，可逆，满足方程$pV^\gamma=K=\mathrm{Constant}$，式中$\gamma=\dfrac{C_\mathrm{p,m}}{C_\mathrm{V,m}}$，对于理想气体$\gamma=\dfrac{5}{3}$。</p>
<ul>
<li>$\Delta U$，由热力学第一定律，$\Delta U=Q+W$，$Q=0$，故$\Delta U=W=nC_\mathrm{V,m}\Delta T$；</li>
<li>$Q$，绝热过程定义直接表明$Q=0$；</li>
<li>$W​$，$W=-\int_{V_1}^{V_2}p\mathrm{d}V = -\int_{V_1}^{V_2}\dfrac{K}{V^\gamma}\mathrm{d}V = -\big[ \dfrac{K}{(1-\gamma)V^{\gamma-1}} \big]_{V_1}^{V_2} = -\dfrac{K}{1-\gamma} \big[ \dfrac{1}{V_2^{\gamma-1}} - \dfrac{1}{V_1^{\gamma-1}} \big] $<br> 因为$p_1 V_1^\gamma = p_2 V_2^\gamma = K$，上式写为$ W=\dfrac{p_2 V_2- p_1 V_1}{\gamma -1}=\dfrac{nR(T_2 - T_1)}{\gamma -1}  $，又因为$\dfrac{nR}{C_V}=\gamma-1$，所以$W=C_V(T_2 -T_1)$</li>
<li>$\Delta H$，计算$\Delta H$必须知道$\Delta (pV)$，此时没有更加简单的办法，只能分别求出$p_1$，$V_1$，$p_2$，$V_2$然后计算出$p_2 V_2 - p_1 V_1$最后代入$\Delta H=\Delta U +p_2 V_2 - p_1 V_1$即可求出$\Delta H$；</li>
<li>$\Delta S$，该过程为绝热可逆过程，$\delta Q_R=0$，故熵变为０，即$\Delta S=0$；</li>
<li>$\Delta G$，该过程为变温过程，故题目会直接或间接给出$S$的初始值，然后利用$\Delta G=\Delta H-\Delta (TS)=\Delta H-S\Delta T$计算出$\Delta G$即可；</li>
<li>$\Delta A$，与$\Delta G$类似，将$\Delta G$中的$\Delta H$换为$\Delta U$即可。</li>
</ul>
<h3 id="环状过程"><a href="#环状过程" class="headerlink" title="环状过程"></a>环状过程</h3><p>此过程没有具体的方程，但可以多个过程组成，系统最终状态与初始状态相同。</p>
<ul>
<li>由于系统初始状态与终末状态相同，故<strong>系统</strong>中所有状态函数的变化量为零，即$\Delta U=\Delta H=\Delta S=\Delta G=\Delta A=0$，<strong>注意，此式子描述的是系统的热力学量，而此系统与外界有能量交换，故为非孤立体系，熵变可以为０</strong>。</li>
<li>$W$与$Q$，计算这两个热力学量时<strong>不能</strong>设计过程来求，只能按照过程的具体细节，分解成容易求出$W$和$Q$的过程分别计算出两者，然后求和。</li>
</ul>
<p>以上为本渣的总结，如有纰漏，还请大神指正。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://ionizing.science/2017/06/22/PAT题解-B-1035/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ionizing Radiation">
      <meta itemprop="description" content="伪化生的小窝">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ionizing's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2017/06/22/PAT题解-B-1035/" class="post-title-link" itemprop="url">PAT题解 B 1035</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2017-06-22 13:33:59" itemprop="dateCreated datePublished" datetime="2017-06-22T13:33:59+08:00">2017-06-22</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2018-12-31 19:47:25" itemprop="dateModified" datetime="2018-12-31T19:47:25+08:00">2018-12-31</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Data-Structure-Algorithm/" itemprop="url" rel="index"><span itemprop="name">Data Structure & Algorithm</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          
            <span id="/2017/06/22/PAT题解-B-1035/" class="leancloud_visitors" data-flag-title="PAT题解 B 1035">
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              
                <span class="post-meta-item-text">Views: </span>
              
                <span class="leancloud-visitors-count"></span>
            </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="题解-PAT-B-1035-插入与归并"><a href="#题解-PAT-B-1035-插入与归并" class="headerlink" title="题解:PAT-B 1035 插入与归并"></a>题解:PAT-B 1035 插入与归并</h1><p>这是一篇测试用文章，欢迎围观.</p>
<h2 id="题目全文："><a href="#题目全文：" class="headerlink" title="题目全文："></a>题目全文：</h2><p>题目地址在<a href="https://www.patest.cn/contests/pat-b-practise/1035" target="_blank" rel="noopener">这里</a></p>
<blockquote>
<p>根据维基百科的定义：</p>
</blockquote>
<blockquote>
<p>插入排序是迭代算法，逐一获得输入数据，逐步产生有序的输出序列。每步迭代中，算法从输入序列中取出一元素，将之插入有序序列中正确的位置。如此迭代直到全部元素有序。</p>
</blockquote>
<blockquote>
<p>归并排序进行如下迭代操作：首先将原始序列看成N个只包含1个元素的有序子序列，然后每次迭代归并两个相邻的有序子序列，直到最后只剩下1个有序的序列。</p>
</blockquote>
<blockquote>
<p>现给定原始序列和由某排序算法产生的中间序列，请你判断该算法究竟是哪种排序算法？</p>
</blockquote>
<blockquote>
<p>输入格式：</p>
</blockquote>
<blockquote>
<p>输入在第一行给出正整数N (&lt;=100)；随后一行给出原始序列的N个整数；最后一行给出由某排序算法产生的中间序列。这里假设排序的目标序列是升序。数字间以空格分隔。</p>
</blockquote>
<blockquote>
<p>输出格式：</p>
</blockquote>
<blockquote>
<p>首先在第1行中输出“Insertion Sort”表示插入排序、或“Merge Sort”表示归并排序；然后在第2行中输出用该排序算法再迭代一轮的结果序列。题目保证每组测试的结果是唯一的。数字间以空格分隔，且行末不得有多余空格。</p>
</blockquote>
<p>输入样例1：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">10</span><br><span class="line">3 1 2 8 7 5 9 4 6 0</span><br><span class="line">1 2 3 7 8 5 9 4 6 0</span><br></pre></td></tr></table></figure></p>
<p>输出样例1：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Insertion Sort</span><br><span class="line">1 2 3 5 7 8 9 4 6 0</span><br></pre></td></tr></table></figure></p>
<p>输入样例2：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">10</span><br><span class="line">3 1 2 8 7 5 9 4 0 6</span><br><span class="line">1 3 2 8 5 7 4 9 0 6</span><br></pre></td></tr></table></figure></p>
<p>输出样例2：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Merge Sort</span><br><span class="line">1 2 3 8 4 5 7 9 0 6</span><br></pre></td></tr></table></figure></p>
<h2 id="题目解读"><a href="#题目解读" class="headerlink" title="题目解读"></a>题目解读</h2><p>这是我刷乙级题时比较头疼的一道题，前后查阅了很多别人的代码，后又观看了陈越姥姥的<a href="http://www.icourse163.org/learn/ZJU-93001?tid=1002019005#/learn/content?type=detail&amp;id=1002635050" target="_blank" rel="noopener">视频</a>总算弄明白了这道题需要注意哪些.</p>
<ol>
<li>如何区分简单插入排序和<strong>非递归</strong>的归并排序;</li>
<li>如何根据测试用例的类型再迭代一次运算;</li>
<li>如何处理边界测试.</li>
</ol>
<p>这里要强调一下本题使用递归的归并排序是<strong>无法AC</strong>的，本渣使用递归的归并排序最多只能得到17分. 关于递归的归并与迭代归并区别请围观<a href="https://en.wikipedia.org/wiki/Merge_sort" target="_blank" rel="noopener">这里</a> (中文版省去了很多分析过程，强烈建议读英文原版)，另外，关于插入排序算法的Wiki在<a href="https://en.wikipedia.org/wiki/Insertion_sort" target="_blank" rel="noopener">这里</a>.</p>
<h2 id="解题过程"><a href="#解题过程" class="headerlink" title="解题过程"></a>解题过程</h2><h3 id="如何区分简单插入排序和非递归的归并排序"><a href="#如何区分简单插入排序和非递归的归并排序" class="headerlink" title="如何区分简单插入排序和非递归的归并排序"></a>如何区分简单插入排序和非递归的归并排序</h3><p>只要抓住两个关键点即可：</p>
<ol>
<li><strong>使用插入排序序列的开头一部分一定是有序的</strong>;</li>
<li><strong>无序部分与原文一致</strong>．</li>
</ol>
<p>比如下面这个例子:</p>
<blockquote>
<p>10<br>3 1 2 8 7 <code>5 9 4 6 0</code><br><strong>1 2 3 7 8</strong> <code>5 9 4 6 0</code></p>
</blockquote>
<p>我们可以这样来判断:</p>
<ol>
<li>首先扫描 <code>1 2 3 7 8</code> 为有序序列，当读取到<code>5</code>时发现 <code>8 &gt; 5</code>暂停，执行步骤2;</li>
<li>从<code>5</code>开始对后面的序列与原序列进行比较，若发现全部是匹配的，则该序列的排序算法为插入排序,并记录下开始无序的位置;否则为归并排序.</li>
</ol>
<p>显然后面的部分与原文一致，因此这个序列排序使用的是插入排序. 注意这里必须满足以上<strong><em>两个</em></strong>条件才能推出插入排序算法．</p>
<p>这里不得不提到有同学使用从后向前寻找不匹配点的方法来判断排序算法，这个方法是不对的，比如下面这个例子:  </p>
<blockquote>
<p>3 1 2 8 7 5 9 4 <code>0 6</code><br>1 3 2 8 5 7 4 9 <code>0 6</code>  </p>
</blockquote>
<p>虽然这里的后面一部分<code>0　6</code>与原题一致，但它并不满足前置子序列有序，因此它不是插入排序，后面的测试用例就有一个测试点来卡这种情况。</p>
<p>对于如何判断是否使用归并排序则相对麻烦，考虑到题目中明确指出测试用例是合法的并且只能是归并和插入排序两种之一，所以这里使用排除法来确定归并排序．</p>
<h3 id="如何根据测试用例的类型再迭代一次运算"><a href="#如何根据测试用例的类型再迭代一次运算" class="headerlink" title="如何根据测试用例的类型再迭代一次运算"></a>如何根据测试用例的类型再迭代一次运算</h3><h4 id="对于插入排序"><a href="#对于插入排序" class="headerlink" title="对于插入排序"></a>对于插入排序</h4><p>这个就非常简单了，如果明白了插入排序的算法，直接从上面记录下的点进行再迭代一次即可。</p>
<h4 id="对于归并排序"><a href="#对于归并排序" class="headerlink" title="对于归并排序"></a>对于归并排序</h4><p>这个相对要麻烦一些，其关键步骤是确定归并段的长度。有的同学想到像插入排序一样从头开始寻找最长有序子序列，这是不对的，因为题意中归并排序是迭代一轮后才得到题目序列，即题目序列被分为若干归并段，<strong>每一小段都是有序的</strong>，因此若原文前一段本身已经有序，那么进行归并后得到的序列一定也是整体有序的，那么也就无法通过通过前置子序列的最大有序长度来代表所有归并段的长度。比如下面这个例子:</p>
<blockquote>
<p>10<br><code>2 1 8 3</code> <code>7 5</code> <code>9 4</code> <code>0 6</code><br><code>1 2 3 8</code> <code>5 7</code> <code>4 9</code> <code>0 6</code></p>
</blockquote>
<p>显然我们无法从<code>1 3 2 8</code>是最长前置有序子列就判断出归并段的长度为<code>4</code>。正确答案应该是<code>2</code>。</p>
<p>有的同学使用模拟法，即对原序列进行分步归并排序，每迭代一次都与题目序列进行比较，直到发现匹配的情况为止。　这种方法在题目所给的时间限制下也能通过，但本着认真负责的态度，我们应该寻找一种更加<strong>聪明</strong>的办法来确定</p>
<p>通过陈越姥姥的启发，我们总结出一下步骤判断最大归并段的长度：</p>
<ol>
<li>假设每个归并段的长度为<code>l</code>, (<code>l</code>的初始值为<code>2</code>，因为一个元素不存在有序无序的概念);</li>
<li>对所有相邻两个归并段相连的两个元素进行比较，若该两元素仍有序，则归并段的长度<code>l *= 2</code>; 否则终止循环，<code>l</code>即为要确定的最大归并段长度。</li>
</ol>
<p>程序实现起来就是通过<code>for(l=2; l&lt;=N; l*=2)</code>这个大循环内部完成的。  </p>
<p>当确定了最大归并段长度，余下的工作就变得简单了，直接再迭代归并一次即可。<br>具体代码可以参考最后的AC代码。</p>
<h3 id="如何处理边界测试"><a href="#如何处理边界测试" class="headerlink" title="如何处理边界测试"></a>如何处理边界测试</h3><p>PAT的题目测试不给出测试数据以及测试提示，比较考验同学们的程序测试能力，本渣在通过这道题时前后想了很久，也提交了很多次，还是在看了陈越姥姥的讲解后才知道测试数据的提示，测试数据包含一下几类：</p>
<ol>
<li>最小<code>N</code>(<code>N = 4</code>，因为只有当<code>N &gt;= 4</code>时才能区分出归并排序与插入排序中间子列).<ul>
<li>插入排序第<code>1</code>步，什么都没改变;</li>
<li>归并排序第<code>1</code>步，什么都变了;</li>
</ul>
</li>
<li>尾部子列无变化，但是前面变了(归并).</li>
<li>最大<code>N</code>.</li>
</ol>
<p>有了如上提示，加上前面的讲解，相信读者一定能够独立AC这道题了。</p>
<h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码:"></a>AC代码:</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">//#include &lt;fstream&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    std::ifstream cin("in.txt");</span></span><br><span class="line">    <span class="keyword">int</span> N;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N;</span><br><span class="line">    <span class="keyword">int</span> *Orig = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i!=N; ++i)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; Orig[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> *tmp = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i!=N; ++i)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; tmp[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">k</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=k; i!=N<span class="number">-1</span>; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>( tmp[i] &gt; tmp[i+<span class="number">1</span>] )&#123;</span><br><span class="line">            k = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">IsInsertion</span><span class="params">(<span class="literal">true</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=++k; i!=N; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>( tmp[i] != Orig[i] )&#123;</span><br><span class="line">            IsInsertion = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>( IsInsertion )&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Insertion Sort"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=k; i!=<span class="number">0</span>; --i)&#123;</span><br><span class="line">            <span class="keyword">if</span>( tmp[i] &lt; tmp[i<span class="number">-1</span>] )&#123;</span><br><span class="line">                <span class="keyword">int</span> t = tmp[i];</span><br><span class="line">                tmp[i] = tmp[i<span class="number">-1</span>];</span><br><span class="line">                tmp[i<span class="number">-1</span>] = t;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i!=N<span class="number">-1</span>; ++i)&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; tmp[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        &#125;<span class="built_in">cout</span> &lt;&lt; tmp[N<span class="number">-1</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Merge Sort"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">bool</span> Identified = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">2</span>; l&lt;=N; l*=<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=l; i&lt;N; i += <span class="number">2</span>*l)&#123;</span><br><span class="line">                <span class="keyword">if</span>( tmp[i<span class="number">-1</span>] &gt; tmp[i] )&#123;</span><br><span class="line">                    Identified = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>( Identified )&#123;</span><br><span class="line">                k = l;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        cout &lt;&lt; "k = " &lt;&lt; k &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N; i+=k*<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> *tmpArr = <span class="keyword">new</span> <span class="keyword">int</span>[k*<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">int</span> lef = i;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">int</span> mid = ( lef+k &lt; N ) ? lef+k : N;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">int</span> rig = ( mid+k &lt; N ) ? mid+k : N;</span><br><span class="line">            <span class="keyword">int</span> cur = mid;</span><br><span class="line">            <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>( lef &lt; mid <span class="keyword">and</span> cur &lt; rig )&#123;</span><br><span class="line">                <span class="keyword">if</span>( tmp[lef] &lt; tmp[cur] )&#123;</span><br><span class="line">                    tmpArr[j++] = tmp[lef++];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    tmpArr[j++] = tmp[cur++];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>( lef &lt; mid )&#123;</span><br><span class="line">                tmpArr[j++] = tmp[lef++];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>( cur &lt; rig )&#123;</span><br><span class="line">                tmpArr[j++] = tmp[cur++];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> t=<span class="number">0</span>; t!=j; ++t)&#123;</span><br><span class="line">                tmp[i+t] = tmpArr[t];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">delete</span>[] tmpArr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i!=N<span class="number">-1</span>; ++i)&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; tmp[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        &#125;<span class="built_in">cout</span> &lt;&lt; tmp[N<span class="number">-1</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Ionizing Radiation</p>
              <div class="site-description motion-element" itemprop="description">伪化生的小窝</div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">9</span>
                    <span class="site-state-item-name">posts</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/categories/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">6</span>
                    <span class="site-state-item-name">categories</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/tags/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">19</span>
                    <span class="site-state-item-name">tags</span>
                  </a>
                </div>
              
            </nav>
          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://github.com/IonizingRadiation" title="GitHub &rarr; https://github.com/IonizingRadiation" rel="noopener" target="_blank"><i class="fa fa-fw fa-globe"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="mailto:PeterSmith_9@outlook.com" title="E-Mail &rarr; mailto:PeterSmith_9@outlook.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                </span>
              
            </div>
          

          

          
          

          
            
          
          

        </div>
      </div>

      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Ionizing Radiation</span>

  

  
</div>


  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> v7.0.1</div>



  <div class="footer-custom">Hosted by <a href="https://pages.coding.me" class="theme-link" rel="noopener" target="_blank">Coding Pages</a></div>


        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/src/utils.js?v=7.0.1"></script>

  <script src="/js/src/motion.js?v=7.0.1"></script>



  
  


  <script src="/js/src/schemes/muse.js?v=7.0.1"></script>




  

  


  <script src="/js/src/next-boot.js?v=7.0.1"></script>


  

  

  

  



  




  
  
  <script>
    
    function showTime(Counter) {
      var entries = [];
      var $visitors = $('.leancloud_visitors');

      $visitors.each(function() {
        entries.push( $(this).attr('id').trim() );
      });

      Counter('get', '/classes/Counter', { where: JSON.stringify({ url: { '$in': entries } }) })
        .done(function({ results }) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.url;
            var time = item.time;
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for (var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if (countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function ({ responseJSON }) {
          console.log('LeanCloud Counter Error: ' + responseJSON.code + ' ' + responseJSON.error);
        });
    }
    

    $(function() {
      $.get('https://app-router.leancloud.cn/2/route?appId=' + 'kURCdXShfgSCB7irfk4pHjlg-gzGzoHsz')
        .done(function({ api_server }) {
          var Counter = function(method, url, data) {
            return $.ajax({
              method: method,
              url: 'https://' + api_server + '/1.1' + url,
              headers: {
                'X-LC-Id': 'kURCdXShfgSCB7irfk4pHjlg-gzGzoHsz',
                'X-LC-Key': 'ljdTAbOpN7Tm1gubHSMAxuHu',
                'Content-Type': 'application/json',
              },
              data: data
            });
          };
          
            if ($('.post-title-link').length >= 1) {
              showTime(Counter);
            }
          
        });
    });
  </script>



  

  
  

  
  
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
  

  


  

  

  

  

  

  

  

  

  

</body>
</html>
