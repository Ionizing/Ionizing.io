#+BEGIN_COMMENT
.. title: N 皇后问题
.. slug: n-queens
.. date: 2020-02-06 20:31:37 UTC+08:00
.. tags: draft
.. category: ComputerProgramming
.. link: 
.. description: 
.. type: text

#+END_COMMENT


* 问题背景
在国际象棋中，皇后的移动范围最大：她既可以横竖移动任意长度（不能跨过棋子，其他
移动同理），也可以沿对角线和反对角线方向移动任意长度，一旦在皇后移动的范围内存
在对方的棋子，皇后便可以攻击消灭对方。由此产生一个问题，在一个 =N x N= 的棋盘上，
放置 =N= 个皇后时有多少种放置方案使得所有的皇后不能够相互攻击？

{{{TEASER_END}}}

[[../../images/n-queens/8-queens.png]]

上图中每一个皇后的横竖斜的方向上都没有其他皇后。

* 求解思路
本文使用回溯法求解这个问题。

所谓回溯法，即先沿着一条路尽可能延伸，如果遇到与条件冲突的情况，则退回到上一个路
口，选择下一个分支继续延伸，直到找到解，后面会在代码中体会如何延伸，以及如何退回
到上一个节点。

显然，根据皇后能够横竖移动的特点，并且 =N x N= 的棋盘上有 =N= 个皇后，我们应该能
至少保证每一列只有一个皇后，此时使用一个一维数组即可存储一个解：

#+BEGIN_SRC
   [ 1, 3, 5, 7, 2, 0, 6, 4 ]
               ||
               \/
    ------------------------
 7 | .  .  .  Q  .  .  .  . |
 6 | .  .  .  .  .  .  .  . |
 5 | .  .  Q  .  .  .  .  . |
 4 | .  .  .  .  .  .  .  Q |
 3 | .  Q  .  .  .  .  .  . |
 2 | .  .  .  .  Q  .  .  . |
 1 | Q  .  .  .  .  .  .  . |
 0 | .  .  .  .  .  Q  .  . |
    ------------------------
     0  1  2  3  4  5  6  7
#+END_SRC

这里用 =ans= 表示这个解

** 判断解是否有效
当我们放置一个皇后到棋盘上时便可以判断这个放置方案是否合理，如果是放置第一个皇后，
那么她在第 =0= 列的任意一个位置都可以，从第二列开始放置皇后时，首先判断她是否与前
面放置的皇后在同一行：

#+BEGIN_SRC
   [ 1, 1, -, -, -, -, -, - ]
               ||
               \/
    ------------------------
 7 | .  .  .  .  .  .  .  . |
 6 | .  .  .  .  .  .  .  . |
 5 | .  .  .  .  .  .  .  . |
 4 | .  .  .  .  .  .  .  . |
 3 | .  .  .  .  .  .  .  . |
 2 | .  .  .  .  .  .  .  . |
 1 | Q  Q  .  .  .  .  .  . |
 0 | .  .  .  .  .  .  .  . |
    ------------------------
     0  1  2  3  4  5  6  7
#+END_SRC

即， =ans.back()= 是否等于数组前面已经存在的一个数，如果存在，则该解无效，否则暂
时接受该解。上面示例中，第二个放置的皇后 =ans.back() = ans[1] = 1= ，存在
=ans[1] == ans[0]= ，所以这个解无效。这里给出检查解是否有效的代码示例：

下面来判断是否有两个皇后处于同一斜线上。

#+BEGIN_SRC
   [ 1, 6, 3, 5, 0, 2, -, - ]
               ||
               \/
    ------------------------
 7 | .  .  .  .  .  .  .  . |
 6 | .  Q  .  .  .  .  .  . |
 5 | .  .  \  Q  .  .  .  . |
 4 | .  .  .  \  .  .  .  . |
 3 | .  .  Q  .  \  .  .  . |
 2 | .  /  .  .  .  Q  .  . |
 1 | Q  .  .  .  .  .  .  . |
 0 | .  .  .  .  0  .  .  . |
    ------------------------
     0  1  2  3  4  5  6  7
#+END_SRC

由于在棋盘上，只认为对角线和反对角线为斜线，它们的斜率为 1 和 -1 ，这样就
有了判断的方法：如果存在 =i<j= 使得 =abs(ans[j] - ans[i]) == j-i= ，此时
=ans[i]= 和 =ans[j]= 一定处于同一斜线上。在上面的示例中 =ans[0]= 和 =ans[2]= 在
同一斜线上， =ans[1]= 和 =ans[5]= 在同一斜线上，我们验证一下
=ans[2] - ans[0] = 3 - 1 == 2 - 0 == 0= ，
=ans[5] = ans[1] = 2 - 6 == -(5 - 1) = -4= 。

此时可以得到判断解是否有效的代码如下

#+BEGIN_SRC C++
bool check(const std::vector<int>& ans) { // ans 是动态增长的，最后一个值即为刚刚放置的皇后位置
    if (ans.size() <= 1) {
        return true;
    }
    const int back = ans.back();
    const int len = static_cast<int>(ans.size());
    for (int i=0; i!=len-1; ++i) {
        if (ans[i] == back or
            std::abs(ans[i] - back) == len - 1 - i) {
            return false;
        }
    }
    return true;
}
#+END_SRC

** 回溯
回溯的本质是对一颗树进行遍历，树的节点代表求解的状态。在本问题中，树的节点即为
=ans= ，当遍历的节点深度等于 =N= 且这个节点仍符合 =N= 皇后互不攻击时，这个节点即
为一个可行的解。那么回溯的代码模版就是：

#+BEGIN_SRC c++
void helper(std::vector<int>& ans, const int N) { // requires N >= 0
    if (!check(ans)) {
        return; // invalid solution
    }

    if (ans.size() >= N) {
        return; // a valid solution found
    }

    for (int i=0; i!=N; ++i) {
        ans.push_back(i);
        helper(ans); // taverse
        ans.pop_back();
    }
}
#+END_SRC

上面代码清单中 =if(!check(ans))= 在遍历深度未达到 =N= 时即提前去除了不合理的子
树，大大节省了递归的时间。
