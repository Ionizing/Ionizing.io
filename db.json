{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":1,"renderable":0},{"_id":"source/images/2017-7-1/fig1.svg","path":"images/2017-7-1/fig1.svg","modified":1,"renderable":0}],"Cache":[{"_id":"source/.DS_Store","hash":"0b719a11266d85b61ee73ef06c69c18049da487f","modified":1505830078000},{"_id":"source/CNAME","hash":"5213b9a2e96cef6ecc10fb4fd7fa10b81819f758","modified":1505830078000},{"_id":"source/_drafts/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1505830078000},{"_id":"source/_drafts/Quantum-Physics-Learning-Log-2.md","hash":"81b9c03be590c2a983a17b28f5304b01dc5e75dd","modified":1505830078000},{"_id":"source/_posts/.DS_Store","hash":"7227d0c478776028c925e8d5c445b18d1947bb82","modified":1505830078000},{"_id":"source/_posts/Coriolis-Force.md","hash":"64e679f2d382204c5a0ac9e8bb6e033b41d43306","modified":1505830078000},{"_id":"source/_posts/PAT题解-B-1035.md","hash":"aff0b0601427a1821e481a8977ea33e834ae872d","modified":1505830078000},{"_id":"source/_posts/PhysChem-Revise-1.md","hash":"3935ce61849f90b64d47af024946469e4998dd14","modified":1505830078000},{"_id":"source/_posts/Quantum-Physics-Learning-Log-1.md","hash":"6e6ac4ed8901b49347c0eb579ff288e409278cc6","modified":1505830078000},{"_id":"source/about/.DS_Store","hash":"566419fb885998da8e0cc982a223d3e197d5696d","modified":1505830078000},{"_id":"source/about/index.md","hash":"f465647256abe3c375de3fdfde55780bffdb164f","modified":1505830078000},{"_id":"source/categories/index.md","hash":"fbc6a1b6407790a9500047ae87b88bbc7d73d200","modified":1505830078000},{"_id":"source/tags/index.md","hash":"3f6646b75d49097b05293d24683b188867a2dce4","modified":1505830078000},{"_id":"source/_posts/Coriolis-Force/Sagiri.jpg","hash":"9487482a1afd9950afa873966c9d981d90257718","modified":1505830078000},{"_id":"source/_posts/Coriolis-Force/fig1.ggb","hash":"53a661e27c39efc0adfbe41139f67bf86f249eba","modified":1505830078000},{"_id":"source/_posts/Coriolis-Force/fig1.png","hash":"585a6530adf1c4fddc913c06eccaae834b5df760","modified":1505830078000},{"_id":"source/_posts/Coriolis-Force/fig2.ggb","hash":"17f1b68399857c67bdd181bbd561bd2db33814f6","modified":1505830078000},{"_id":"source/_posts/Coriolis-Force/fig2.png","hash":"35f34c021f4c31864310ca1e1b4a842c6201caf6","modified":1505830078000},{"_id":"source/_posts/Coriolis-Force/fig2.svg","hash":"105def3bfdbbf5d0ed38a68b94ee0e204b6cc8c9","modified":1505830078000},{"_id":"source/_posts/Coriolis-Force/fig3.ggb","hash":"f4e48c1dcaca0a8fb832a017288ffd73d98a500f","modified":1505830078000},{"_id":"source/_posts/Coriolis-Force/fig3.png","hash":"ebbc22b5e562274ac25dfcd61d054efff186946b","modified":1505830078000},{"_id":"source/_posts/Coriolis-Force/fig4.ggb","hash":"3de20a287bb4c98f7b5c9dd0818387052a763eff","modified":1505830078000},{"_id":"source/_posts/Coriolis-Force/fig4.png","hash":"64c40e0b7e71bda265cf1d9346301511edd29f57","modified":1505830078000},{"_id":"source/_posts/Coriolis-Force/fig5.ggb","hash":"23d6e2b0ccd1fd833a233865fa0212202aa114c7","modified":1505830078000},{"_id":"source/_posts/Coriolis-Force/fig6.ggb","hash":"38d6f1504116699e92d481262beed875d40355e7","modified":1505830078000},{"_id":"source/_posts/Coriolis-Force/fig6_2.pdf","hash":"a34907fe9ee1fc4ffb63e3dd930a411501db9295","modified":1505830078000},{"_id":"source/_posts/Coriolis-Force/fig6_2.svg","hash":"dfe0b3b491a73091eb179d78bda7cd89ade71183","modified":1505830078000},{"_id":"source/_posts/Coriolis-Force/fig6_3.pdf","hash":"710dfcec26925b2485a9889aab9565908c99e511","modified":1505830078000},{"_id":"source/_posts/Coriolis-Force/fig6_3.svg","hash":"4b38faa9ad9b773b9878111226e6776defb135b1","modified":1505830078000},{"_id":"source/_posts/Quantum-Physics-Learning-Log-1/.DS_Store","hash":"ef0b49ffff4cd3af0b74765a420db5a1f1ae2e1b","modified":1505830078000},{"_id":"source/_posts/Quantum-Physics-Learning-Log-1/fig.svg","hash":"340f4f32acc6728db7953fae0e05a2b855b0d1eb","modified":1505830078000},{"_id":"source/images/2017-7-1/fig1.svg","hash":"340f4f32acc6728db7953fae0e05a2b855b0d1eb","modified":1505830078000},{"_id":"source/_posts/Coriolis-Force/fig5.png","hash":"2e6a309ad30e43be3a338ad9ea09a88949cea19c","modified":1505830078000},{"_id":"source/_posts/Coriolis-Force/fig6_1.png","hash":"e14d92f9475048343e813ab265520e11f93428a3","modified":1505830078000},{"_id":"source/_posts/Coriolis-Force/animated.gif","hash":"341a59cdf86c0b674aea57a89a660c31099d17f6","modified":1505830078000},{"_id":"source/_posts/Coriolis-Force/fig5.gif","hash":"6620991bce153782b46e3d3b404dca7adaeb0db7","modified":1505830078000},{"_id":"public/about/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1505830775701},{"_id":"public/categories/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1505830775701},{"_id":"public/2017/08/23/Coriolis-Force/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1505830775701},{"_id":"public/2017/06/30/Quantum-Physics-Learning-Log-1/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1505830775701},{"_id":"public/tags/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1505830775701},{"_id":"public/2017/06/26/PhysChem-Revise-1/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1505830775701},{"_id":"public/2017/06/22/PAT题解-B-1035/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1505830775701},{"_id":"public/archives/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1505830775702},{"_id":"public/archives/2017/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1505830775702},{"_id":"public/archives/2017/06/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1505830775702},{"_id":"public/archives/2017/08/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1505830775702},{"_id":"public/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1505830775702},{"_id":"public/categories/Quantum-Mechanics/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1505830775702},{"_id":"public/categories/Data-Structure-Algorithm/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1505830775702},{"_id":"public/categories/Physics/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1505830775702},{"_id":"public/categories/Physical-Chemistry/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1505830775702},{"_id":"public/tags/量子力学/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1505830775702},{"_id":"public/tags/物理学/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1505830775702},{"_id":"public/tags/经典力学/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1505830775702},{"_id":"public/tags/科里奥利力/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1505830775702},{"_id":"public/tags/C/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1505830775703},{"_id":"public/tags/PAT/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1505830775703},{"_id":"public/tags/排序/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1505830775703},{"_id":"public/tags/线性代数/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1505830775703},{"_id":"public/tags/数学基础/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1505830775703},{"_id":"public/tags/物理化学/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1505830775703},{"_id":"public/tags/化学/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1505830775703},{"_id":"public/CNAME","hash":"5213b9a2e96cef6ecc10fb4fd7fa10b81819f758","modified":1505830775708},{"_id":"public/images/2017-7-1/fig1.svg","hash":"340f4f32acc6728db7953fae0e05a2b855b0d1eb","modified":1505830775708},{"_id":"public/2017/08/23/Coriolis-Force/Sagiri.jpg","hash":"9487482a1afd9950afa873966c9d981d90257718","modified":1505830775708},{"_id":"public/2017/08/23/Coriolis-Force/fig2.ggb","hash":"17f1b68399857c67bdd181bbd561bd2db33814f6","modified":1505830775708},{"_id":"public/2017/08/23/Coriolis-Force/fig1.ggb","hash":"53a661e27c39efc0adfbe41139f67bf86f249eba","modified":1505830775708},{"_id":"public/2017/08/23/Coriolis-Force/fig1.png","hash":"585a6530adf1c4fddc913c06eccaae834b5df760","modified":1505830775708},{"_id":"public/2017/08/23/Coriolis-Force/fig2.png","hash":"35f34c021f4c31864310ca1e1b4a842c6201caf6","modified":1505830775708},{"_id":"public/2017/08/23/Coriolis-Force/fig3.ggb","hash":"f4e48c1dcaca0a8fb832a017288ffd73d98a500f","modified":1505830775708},{"_id":"public/2017/08/23/Coriolis-Force/fig2.svg","hash":"105def3bfdbbf5d0ed38a68b94ee0e204b6cc8c9","modified":1505830775709},{"_id":"public/2017/08/23/Coriolis-Force/fig3.png","hash":"ebbc22b5e562274ac25dfcd61d054efff186946b","modified":1505830775709},{"_id":"public/2017/08/23/Coriolis-Force/fig4.ggb","hash":"3de20a287bb4c98f7b5c9dd0818387052a763eff","modified":1505830775709},{"_id":"public/2017/08/23/Coriolis-Force/fig4.png","hash":"64c40e0b7e71bda265cf1d9346301511edd29f57","modified":1505830775709},{"_id":"public/2017/08/23/Coriolis-Force/fig5.ggb","hash":"23d6e2b0ccd1fd833a233865fa0212202aa114c7","modified":1505830775709},{"_id":"public/2017/08/23/Coriolis-Force/fig6_2.pdf","hash":"a34907fe9ee1fc4ffb63e3dd930a411501db9295","modified":1505830775709},{"_id":"public/2017/08/23/Coriolis-Force/fig6.ggb","hash":"38d6f1504116699e92d481262beed875d40355e7","modified":1505830775709},{"_id":"public/2017/08/23/Coriolis-Force/fig6_2.svg","hash":"dfe0b3b491a73091eb179d78bda7cd89ade71183","modified":1505830775709},{"_id":"public/2017/08/23/Coriolis-Force/fig6_3.pdf","hash":"710dfcec26925b2485a9889aab9565908c99e511","modified":1505830775709},{"_id":"public/2017/06/30/Quantum-Physics-Learning-Log-1/fig.svg","hash":"340f4f32acc6728db7953fae0e05a2b855b0d1eb","modified":1505830775709},{"_id":"public/2017/08/23/Coriolis-Force/fig6_3.svg","hash":"4b38faa9ad9b773b9878111226e6776defb135b1","modified":1505830775709},{"_id":"public/2017/08/23/Coriolis-Force/fig5.png","hash":"2e6a309ad30e43be3a338ad9ea09a88949cea19c","modified":1505830775713},{"_id":"public/2017/08/23/Coriolis-Force/fig6_1.png","hash":"e14d92f9475048343e813ab265520e11f93428a3","modified":1505830775716},{"_id":"public/2017/08/23/Coriolis-Force/animated.gif","hash":"341a59cdf86c0b674aea57a89a660c31099d17f6","modified":1505830775757},{"_id":"public/2017/08/23/Coriolis-Force/fig5.gif","hash":"6620991bce153782b46e3d3b404dca7adaeb0db7","modified":1505830775763}],"Category":[{"name":"Quantum Mechanics","_id":"cj7rorijl0004tcjmzhrw4kxp"},{"name":"Physics","_id":"cj7rorijs0009tcjmezl6l7k3"},{"name":"Data Structure & Algorithm","_id":"cj7roriju000dtcjmp7ufr5lo"},{"name":"Physical Chemistry","_id":"cj7roriju000htcjmascbhlwu"}],"Data":[],"Page":[{"title":"关于","date":"2017-06-22T09:35:05.000Z","type":"about","comments":0,"_content":"\n# 关于本渣\n即将毕业去搬砖的伪化生，就读于帝国能源男子高中应用化学专业。\n\n# 计算机\n曾梦想成为一名黑客，现在只是想低调地搬砖写代码。`C++`、`MATLAB`、`Mathematica`入门水平。\n\n酷爱折腾，并无数次拆开手机更换零件；也喜欢折腾电脑工作环境。忠实的`Vim`党、大括号不换行党以及驼峰党。\n\n正版 `Micro$oft Window$` 的受害者以及 `Arch Linux` 的受益者。\n\n# 化学\n有机化学学渣，物理化学学渣。　嗯，还是众多具有帝国能源男子高中特色课程的学渣。\n\n# 职业生涯\n未来只想低调做科研，少装X，多做事。\n\n# 为什么没有贴出头像？\n因为太丑。\n\n# 联系方式\nEmail: `PeterSmith_9@outlook.com`","source":"about/index.md","raw":"---\ntitle: 关于\ndate: 2017-06-22 17:35:05\ntype: \"about\"\ncomments: false\n---\n\n# 关于本渣\n即将毕业去搬砖的伪化生，就读于帝国能源男子高中应用化学专业。\n\n# 计算机\n曾梦想成为一名黑客，现在只是想低调地搬砖写代码。`C++`、`MATLAB`、`Mathematica`入门水平。\n\n酷爱折腾，并无数次拆开手机更换零件；也喜欢折腾电脑工作环境。忠实的`Vim`党、大括号不换行党以及驼峰党。\n\n正版 `Micro$oft Window$` 的受害者以及 `Arch Linux` 的受益者。\n\n# 化学\n有机化学学渣，物理化学学渣。　嗯，还是众多具有帝国能源男子高中特色课程的学渣。\n\n# 职业生涯\n未来只想低调做科研，少装X，多做事。\n\n# 为什么没有贴出头像？\n因为太丑。\n\n# 联系方式\nEmail: `PeterSmith_9@outlook.com`","updated":"2017-09-19T14:07:58.000Z","path":"about/index.html","layout":"page","_id":"cj7roriji0001tcjmh595si6q","content":"<h1 id=\"关于本渣\"><a href=\"#关于本渣\" class=\"headerlink\" title=\"关于本渣\"></a>关于本渣</h1><p>即将毕业去搬砖的伪化生，就读于帝国能源男子高中应用化学专业。</p>\n<h1 id=\"计算机\"><a href=\"#计算机\" class=\"headerlink\" title=\"计算机\"></a>计算机</h1><p>曾梦想成为一名黑客，现在只是想低调地搬砖写代码。<code>C++</code>、<code>MATLAB</code>、<code>Mathematica</code>入门水平。</p>\n<p>酷爱折腾，并无数次拆开手机更换零件；也喜欢折腾电脑工作环境。忠实的<code>Vim</code>党、大括号不换行党以及驼峰党。</p>\n<p>正版 <code>Micro$oft Window$</code> 的受害者以及 <code>Arch Linux</code> 的受益者。</p>\n<h1 id=\"化学\"><a href=\"#化学\" class=\"headerlink\" title=\"化学\"></a>化学</h1><p>有机化学学渣，物理化学学渣。　嗯，还是众多具有帝国能源男子高中特色课程的学渣。</p>\n<h1 id=\"职业生涯\"><a href=\"#职业生涯\" class=\"headerlink\" title=\"职业生涯\"></a>职业生涯</h1><p>未来只想低调做科研，少装X，多做事。</p>\n<h1 id=\"为什么没有贴出头像？\"><a href=\"#为什么没有贴出头像？\" class=\"headerlink\" title=\"为什么没有贴出头像？\"></a>为什么没有贴出头像？</h1><p>因为太丑。</p>\n<h1 id=\"联系方式\"><a href=\"#联系方式\" class=\"headerlink\" title=\"联系方式\"></a>联系方式</h1><p>Email: <code>PeterSmith_9@outlook.com</code></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"关于本渣\"><a href=\"#关于本渣\" class=\"headerlink\" title=\"关于本渣\"></a>关于本渣</h1><p>即将毕业去搬砖的伪化生，就读于帝国能源男子高中应用化学专业。</p>\n<h1 id=\"计算机\"><a href=\"#计算机\" class=\"headerlink\" title=\"计算机\"></a>计算机</h1><p>曾梦想成为一名黑客，现在只是想低调地搬砖写代码。<code>C++</code>、<code>MATLAB</code>、<code>Mathematica</code>入门水平。</p>\n<p>酷爱折腾，并无数次拆开手机更换零件；也喜欢折腾电脑工作环境。忠实的<code>Vim</code>党、大括号不换行党以及驼峰党。</p>\n<p>正版 <code>Micro$oft Window$</code> 的受害者以及 <code>Arch Linux</code> 的受益者。</p>\n<h1 id=\"化学\"><a href=\"#化学\" class=\"headerlink\" title=\"化学\"></a>化学</h1><p>有机化学学渣，物理化学学渣。　嗯，还是众多具有帝国能源男子高中特色课程的学渣。</p>\n<h1 id=\"职业生涯\"><a href=\"#职业生涯\" class=\"headerlink\" title=\"职业生涯\"></a>职业生涯</h1><p>未来只想低调做科研，少装X，多做事。</p>\n<h1 id=\"为什么没有贴出头像？\"><a href=\"#为什么没有贴出头像？\" class=\"headerlink\" title=\"为什么没有贴出头像？\"></a>为什么没有贴出头像？</h1><p>因为太丑。</p>\n<h1 id=\"联系方式\"><a href=\"#联系方式\" class=\"headerlink\" title=\"联系方式\"></a>联系方式</h1><p>Email: <code>PeterSmith_9@outlook.com</code></p>\n"},{"title":"分类","date":"2017-06-22T08:39:46.000Z","type":"categories","comments":0,"_content":"","source":"categories/index.md","raw":"---\ntitle: 分类\ndate: 2017-06-22 16:39:46\ntype: \"categories\"\ncomments: false\n---\n","updated":"2017-09-19T14:07:58.000Z","path":"categories/index.html","layout":"page","_id":"cj7rorijk0003tcjmq0exzi3h","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"标签","date":"2017-06-22T08:33:53.000Z","type":"tags","comments":0,"_content":"","source":"tags/index.md","raw":"---\ntitle: 标签 \ndate: 2017-06-22 16:33:53\ntype: \"tags\"\ncomments: false\n---\n","updated":"2017-09-19T14:07:58.000Z","path":"tags/index.html","layout":"page","_id":"cj7rorijz0013tcjm2l0yjnbc","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"量子力学学习手记（二）——量子力学假设","date":"2017-08-15T08:08:32.000Z","_content":"\n# 量子力学学习手记（2）—量子力学假设\n\n**以下是在不考虑相对论的情况下进行的量子力学假设。** \n\n为了使问题简化，我们会先讨论自由度为 **1** 的系统状况，很自然地，这个系统包含一个粒子，并且该粒子存在于一维空间中，此时我们会进行一些假设，根据假设对这个系统进行相应的计算，取其结果与经典力学的结果进行对比；之后，我们会将假设推广到多维系统以及多个粒子的系统中去。\n\n-----\n\n接下来要阐述的是量子力学的四个基本假设与经典力学假设的对比：\n\n## 假设 I\n\n经典力学：\t一个粒子在任意时刻下的状态由两个变量决定：$x(t)$ 和 $p(t)$ ，这就像在一个二维空间确定一个点需要两个坐标一样；\n\n量子力学：\t粒子的状态用希尔伯特空间中的向量 $\\mid \\psi(t) \\rangle$ 表示。\n\n## 假设 II\n\n经典力学：\t任何动力学变量 $\\omega$ 都是 $x$ 和 $p$ 的函数： $\\omega = \\omega(x,p)$ ；\n\n量子力学：\t经典力学中的独立变量 $x$ 和 $p$ 在量子力学中由厄米算符 $X$ , $P$ 以及下面矩阵的元素代替：\n$$\n\\langle x\\mid X\\mid x'\\rangle = x\\delta(x-x') \\\\\\\\\n\\langle x\\mid P\\mid x'\\rangle = -i\\hbar\\delta(x-x')\n$$\n​\t\t\t而经典力学中的非独立变量如$\\omega(x,p)$ 则用下面的厄米算符表示：\n$$\n\\Omega(X,P) = \\omega(x\\rightarrow X, p\\rightarrow P)\n$$\n\n## 假设 III\n\n经典力学：\t如果粒子的状态由给定的 $x$ 和 $p$ 所确定，则对 $\\omega$ 的测量将产生一个值 $\\omega(x,p)$ ，并且该系统的状态不会被改变；\n\n量子力学：\t如果粒子的状态为 $\\mid \\psi \\rangle$ ，则外界对于 $\\Omega$ 的测量行为有 $P(\\omega) \\propto |\\langle \\omega \\mid \\psi\\rangle|^2$ 的概率得到 $\\Omega$ 的一个特征值 $\\omega$ 。**并且由于测量行为，该系统的状态将会从 $\\mid\\psi\\rangle$ 变为 $\\mid \\omega \\rangle$ **。\n\n## 假设 IV\n\n经典力学：\t变量随时间的变化规律满足哈密顿方程：\n$$\n\\dot{x} = \\frac{\\partial \\mathscr{H} }{\\partial p} \\\\\\\\\n\\dot{p} = -\\frac{\\partial \\mathscr{H} }{\\partial x}\n$$\n量子力学：\t状态向量 $\\mid \\psi(t) \\rangle$ 服从薛定谔方程：\n$$\ni\\hbar \\frac{d}{dt}\\mid \\psi(t) \\rangle = H\\mid\\psi(t)\\rangle\n$$\n​\t\t\t其中 $H(X,P) = \\mathscr{H}(x\\rightarrow X, p\\rightarrow P)$ 是量子力学中的哈密顿算符，而 $\\mathscr{H}$ 是经典理论中的哈密顿算符。\n\n\n\n以上四个假设对于量子力学 **非常重要** ，每天早起背一遍都不为过。\n\n------\n\n下面我们来讨论这些假设。\n\n## ","source":"_drafts/Quantum-Physics-Learning-Log-2.md","raw":"---\ntitle: 量子力学学习手记（二）——量子力学假设\ndate: 2017-08-15 16:08:32\ntags:\n   - 量子力学\ncategories: Quantum Mechanics\n---\n\n# 量子力学学习手记（2）—量子力学假设\n\n**以下是在不考虑相对论的情况下进行的量子力学假设。** \n\n为了使问题简化，我们会先讨论自由度为 **1** 的系统状况，很自然地，这个系统包含一个粒子，并且该粒子存在于一维空间中，此时我们会进行一些假设，根据假设对这个系统进行相应的计算，取其结果与经典力学的结果进行对比；之后，我们会将假设推广到多维系统以及多个粒子的系统中去。\n\n-----\n\n接下来要阐述的是量子力学的四个基本假设与经典力学假设的对比：\n\n## 假设 I\n\n经典力学：\t一个粒子在任意时刻下的状态由两个变量决定：$x(t)$ 和 $p(t)$ ，这就像在一个二维空间确定一个点需要两个坐标一样；\n\n量子力学：\t粒子的状态用希尔伯特空间中的向量 $\\mid \\psi(t) \\rangle$ 表示。\n\n## 假设 II\n\n经典力学：\t任何动力学变量 $\\omega$ 都是 $x$ 和 $p$ 的函数： $\\omega = \\omega(x,p)$ ；\n\n量子力学：\t经典力学中的独立变量 $x$ 和 $p$ 在量子力学中由厄米算符 $X$ , $P$ 以及下面矩阵的元素代替：\n$$\n\\langle x\\mid X\\mid x'\\rangle = x\\delta(x-x') \\\\\\\\\n\\langle x\\mid P\\mid x'\\rangle = -i\\hbar\\delta(x-x')\n$$\n​\t\t\t而经典力学中的非独立变量如$\\omega(x,p)$ 则用下面的厄米算符表示：\n$$\n\\Omega(X,P) = \\omega(x\\rightarrow X, p\\rightarrow P)\n$$\n\n## 假设 III\n\n经典力学：\t如果粒子的状态由给定的 $x$ 和 $p$ 所确定，则对 $\\omega$ 的测量将产生一个值 $\\omega(x,p)$ ，并且该系统的状态不会被改变；\n\n量子力学：\t如果粒子的状态为 $\\mid \\psi \\rangle$ ，则外界对于 $\\Omega$ 的测量行为有 $P(\\omega) \\propto |\\langle \\omega \\mid \\psi\\rangle|^2$ 的概率得到 $\\Omega$ 的一个特征值 $\\omega$ 。**并且由于测量行为，该系统的状态将会从 $\\mid\\psi\\rangle$ 变为 $\\mid \\omega \\rangle$ **。\n\n## 假设 IV\n\n经典力学：\t变量随时间的变化规律满足哈密顿方程：\n$$\n\\dot{x} = \\frac{\\partial \\mathscr{H} }{\\partial p} \\\\\\\\\n\\dot{p} = -\\frac{\\partial \\mathscr{H} }{\\partial x}\n$$\n量子力学：\t状态向量 $\\mid \\psi(t) \\rangle$ 服从薛定谔方程：\n$$\ni\\hbar \\frac{d}{dt}\\mid \\psi(t) \\rangle = H\\mid\\psi(t)\\rangle\n$$\n​\t\t\t其中 $H(X,P) = \\mathscr{H}(x\\rightarrow X, p\\rightarrow P)$ 是量子力学中的哈密顿算符，而 $\\mathscr{H}$ 是经典理论中的哈密顿算符。\n\n\n\n以上四个假设对于量子力学 **非常重要** ，每天早起背一遍都不为过。\n\n------\n\n下面我们来讨论这些假设。\n\n## ","slug":"Quantum-Physics-Learning-Log-2","published":0,"updated":"2017-09-19T14:07:58.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj7rorijf0000tcjmvgd89yxv","content":"<h1 id=\"量子力学学习手记（2）—量子力学假设\"><a href=\"#量子力学学习手记（2）—量子力学假设\" class=\"headerlink\" title=\"量子力学学习手记（2）—量子力学假设\"></a>量子力学学习手记（2）—量子力学假设</h1><p><strong>以下是在不考虑相对论的情况下进行的量子力学假设。</strong> </p>\n<p>为了使问题简化，我们会先讨论自由度为 <strong>1</strong> 的系统状况，很自然地，这个系统包含一个粒子，并且该粒子存在于一维空间中，此时我们会进行一些假设，根据假设对这个系统进行相应的计算，取其结果与经典力学的结果进行对比；之后，我们会将假设推广到多维系统以及多个粒子的系统中去。</p>\n<hr>\n<p>接下来要阐述的是量子力学的四个基本假设与经典力学假设的对比：</p>\n<h2 id=\"假设-I\"><a href=\"#假设-I\" class=\"headerlink\" title=\"假设 I\"></a>假设 I</h2><p>经典力学：    一个粒子在任意时刻下的状态由两个变量决定：$x(t)$ 和 $p(t)$ ，这就像在一个二维空间确定一个点需要两个坐标一样；</p>\n<p>量子力学：    粒子的状态用希尔伯特空间中的向量 $\\mid \\psi(t) \\rangle$ 表示。</p>\n<h2 id=\"假设-II\"><a href=\"#假设-II\" class=\"headerlink\" title=\"假设 II\"></a>假设 II</h2><p>经典力学：    任何动力学变量 $\\omega$ 都是 $x$ 和 $p$ 的函数： $\\omega = \\omega(x,p)$ ；</p>\n<p>量子力学：    经典力学中的独立变量 $x$ 和 $p$ 在量子力学中由厄米算符 $X$ , $P$ 以及下面矩阵的元素代替：</p>\n<script type=\"math/tex; mode=display\">\n\\langle x\\mid X\\mid x'\\rangle = x\\delta(x-x') \\\\\\\\\n\\langle x\\mid P\\mid x'\\rangle = -i\\hbar\\delta(x-x')</script><p>​            而经典力学中的非独立变量如$\\omega(x,p)$ 则用下面的厄米算符表示：</p>\n<script type=\"math/tex; mode=display\">\n\\Omega(X,P) = \\omega(x\\rightarrow X, p\\rightarrow P)</script><h2 id=\"假设-III\"><a href=\"#假设-III\" class=\"headerlink\" title=\"假设 III\"></a>假设 III</h2><p>经典力学：    如果粒子的状态由给定的 $x$ 和 $p$ 所确定，则对 $\\omega$ 的测量将产生一个值 $\\omega(x,p)$ ，并且该系统的状态不会被改变；</p>\n<p>量子力学：    如果粒子的状态为 $\\mid \\psi \\rangle$ ，则外界对于 $\\Omega$ 的测量行为有 $P(\\omega) \\propto |\\langle \\omega \\mid \\psi\\rangle|^2$ 的概率得到 $\\Omega$ 的一个特征值 $\\omega$ 。<strong>并且由于测量行为，该系统的状态将会从 $\\mid\\psi\\rangle$ 变为 $\\mid \\omega \\rangle$ </strong>。</p>\n<h2 id=\"假设-IV\"><a href=\"#假设-IV\" class=\"headerlink\" title=\"假设 IV\"></a>假设 IV</h2><p>经典力学：    变量随时间的变化规律满足哈密顿方程：</p>\n<script type=\"math/tex; mode=display\">\n\\dot{x} = \\frac{\\partial \\mathscr{H} }{\\partial p} \\\\\\\\\n\\dot{p} = -\\frac{\\partial \\mathscr{H} }{\\partial x}</script><p>量子力学：    状态向量 $\\mid \\psi(t) \\rangle$ 服从薛定谔方程：</p>\n<script type=\"math/tex; mode=display\">\ni\\hbar \\frac{d}{dt}\\mid \\psi(t) \\rangle = H\\mid\\psi(t)\\rangle</script><p>​            其中 $H(X,P) = \\mathscr{H}(x\\rightarrow X, p\\rightarrow P)$ 是量子力学中的哈密顿算符，而 $\\mathscr{H}$ 是经典理论中的哈密顿算符。</p>\n<p>以上四个假设对于量子力学 <strong>非常重要</strong> ，每天早起背一遍都不为过。</p>\n<hr>\n<p>下面我们来讨论这些假设。</p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\" \"></a> </h2>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"量子力学学习手记（2）—量子力学假设\"><a href=\"#量子力学学习手记（2）—量子力学假设\" class=\"headerlink\" title=\"量子力学学习手记（2）—量子力学假设\"></a>量子力学学习手记（2）—量子力学假设</h1><p><strong>以下是在不考虑相对论的情况下进行的量子力学假设。</strong> </p>\n<p>为了使问题简化，我们会先讨论自由度为 <strong>1</strong> 的系统状况，很自然地，这个系统包含一个粒子，并且该粒子存在于一维空间中，此时我们会进行一些假设，根据假设对这个系统进行相应的计算，取其结果与经典力学的结果进行对比；之后，我们会将假设推广到多维系统以及多个粒子的系统中去。</p>\n<hr>\n<p>接下来要阐述的是量子力学的四个基本假设与经典力学假设的对比：</p>\n<h2 id=\"假设-I\"><a href=\"#假设-I\" class=\"headerlink\" title=\"假设 I\"></a>假设 I</h2><p>经典力学：    一个粒子在任意时刻下的状态由两个变量决定：$x(t)$ 和 $p(t)$ ，这就像在一个二维空间确定一个点需要两个坐标一样；</p>\n<p>量子力学：    粒子的状态用希尔伯特空间中的向量 $\\mid \\psi(t) \\rangle$ 表示。</p>\n<h2 id=\"假设-II\"><a href=\"#假设-II\" class=\"headerlink\" title=\"假设 II\"></a>假设 II</h2><p>经典力学：    任何动力学变量 $\\omega$ 都是 $x$ 和 $p$ 的函数： $\\omega = \\omega(x,p)$ ；</p>\n<p>量子力学：    经典力学中的独立变量 $x$ 和 $p$ 在量子力学中由厄米算符 $X$ , $P$ 以及下面矩阵的元素代替：</p>\n<script type=\"math/tex; mode=display\">\n\\langle x\\mid X\\mid x'\\rangle = x\\delta(x-x') \\\\\\\\\n\\langle x\\mid P\\mid x'\\rangle = -i\\hbar\\delta(x-x')</script><p>​            而经典力学中的非独立变量如$\\omega(x,p)$ 则用下面的厄米算符表示：</p>\n<script type=\"math/tex; mode=display\">\n\\Omega(X,P) = \\omega(x\\rightarrow X, p\\rightarrow P)</script><h2 id=\"假设-III\"><a href=\"#假设-III\" class=\"headerlink\" title=\"假设 III\"></a>假设 III</h2><p>经典力学：    如果粒子的状态由给定的 $x$ 和 $p$ 所确定，则对 $\\omega$ 的测量将产生一个值 $\\omega(x,p)$ ，并且该系统的状态不会被改变；</p>\n<p>量子力学：    如果粒子的状态为 $\\mid \\psi \\rangle$ ，则外界对于 $\\Omega$ 的测量行为有 $P(\\omega) \\propto |\\langle \\omega \\mid \\psi\\rangle|^2$ 的概率得到 $\\Omega$ 的一个特征值 $\\omega$ 。<strong>并且由于测量行为，该系统的状态将会从 $\\mid\\psi\\rangle$ 变为 $\\mid \\omega \\rangle$ </strong>。</p>\n<h2 id=\"假设-IV\"><a href=\"#假设-IV\" class=\"headerlink\" title=\"假设 IV\"></a>假设 IV</h2><p>经典力学：    变量随时间的变化规律满足哈密顿方程：</p>\n<script type=\"math/tex; mode=display\">\n\\dot{x} = \\frac{\\partial \\mathscr{H} }{\\partial p} \\\\\\\\\n\\dot{p} = -\\frac{\\partial \\mathscr{H} }{\\partial x}</script><p>量子力学：    状态向量 $\\mid \\psi(t) \\rangle$ 服从薛定谔方程：</p>\n<script type=\"math/tex; mode=display\">\ni\\hbar \\frac{d}{dt}\\mid \\psi(t) \\rangle = H\\mid\\psi(t)\\rangle</script><p>​            其中 $H(X,P) = \\mathscr{H}(x\\rightarrow X, p\\rightarrow P)$ 是量子力学中的哈密顿算符，而 $\\mathscr{H}$ 是经典理论中的哈密顿算符。</p>\n<p>以上四个假设对于量子力学 <strong>非常重要</strong> ，每天早起背一遍都不为过。</p>\n<hr>\n<p>下面我们来讨论这些假设。</p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\" \"></a> </h2>"},{"title":"浅谈科里奥利力","date":"2017-08-23T05:25:06.000Z","_content":"\n\n## 简介\n\n苯渣在补力学时卡在了科氏力这一节，经过 Mr. Ren , 物吧大佬以及 [Wikipedia](https://en.wikipedia.org/wiki/Coriolis_force) 上的详细解释，我总算稍稍弄懂了这个家伙到底是怎么产生的了，于是写下本文分享一下愚见。\n\n# 引子\n\n坐过旋转木马的同学应该会有这样的体验：当坐在绕轴旋转的座位上向轴扔一个纸团（乱扔垃圾什么的最讨厌啦）时，纸团并不会砸到轴上，似乎纸团总是会偏离半径方向，并且总是偏向一个方向，这是为什么呢？这就要涉及到这篇文章要讲到的主角——科里奥利力。\n\n\n\n# 什么是科里奥利力？\n\n引用 Wikipedia 上的描述就是：\n\n> **科里奥利力**（简称：**科氏力**）是对旋转体系中进行直线运动的[质点](https://zh.wikipedia.org/wiki/%E8%B4%A8%E7%82%B9)由于[惯性](https://zh.wikipedia.org/wiki/%E6%85%A3%E6%80%A7)相对于旋转体系产生的直线运动的偏移的一种描述。此现象由法国著名数学家兼物理学家[古斯塔夫・科里奥利](https://zh.wikipedia.org/wiki/%E7%A7%91%E9%87%8C%E5%A5%A7%E5%88%A9)发现，因而得名；同时由于这种力在[地球自转](https://zh.wikipedia.org/wiki/%E5%9C%B0%E7%90%83%E8%87%AA%E8%BD%AC)下产生，因此又称为“**地转偏向力**”。\n\n个人理解：\n\n> 以一个旋转体系为参考系时，若研究对象相对于参考系的有非轴向运动的分量（或在垂直轴的平面内有运动分量）时，这个方向的运动分量会受到一个法向惯性力的作用而偏离原来的运动，这个力就是科里奥利力。\n\n上面的描述有两个要点：\n\n1. 参考体系为旋转体系，这也就意味着该参考系是一个非惯性系，其中必然要考虑惯性力的作用；\n2. 研究对象相对于参考系有相对运动，并且这个运动在垂直轴向的平面内有分量。\n\n# 科里奥利力如何产生？\n\n## 粗略的理解\n\n就拿引子里旋转木马的例子：\n\n假设旋转木马是做匀速圆周运动，角速度为 $ \\vec{\\omega} $ ，读者轨迹半径为 $\\vec{r}$ ，那么读者的公转线速度为\n$$\n\\vec{v}_t = \\vec{\\omega} \\times \\vec{r} \\notag\n$$\n如同这样：\n\n<img src=\"fig1.png\" width=\"400\" />\n\n（**注意这里的变量用矢量表示**）\n\n朝径向，也就是 $-\\vec{r}$ 方向扔一个纸团时，这个纸团既有朝向径向的速度 $\\vec{v}_n$ ，又有线速度 $\\vec{\\omega}\\times\\vec{r}$ ，当其运动到圆内侧时，内侧的线速度 \n$$\n\\vec{v}'_t = \\vec{\\omega}\\times\\vec{r}' < \\vec{\\omega}\\times\\vec{r} = \\vec{v}_t\n$$\n很自然地，纸团此时的切向速度比其所在圆上的的线速度更大，也就偏移了所谓的“直线”，读者视角俯视图见下图：\n\n<img src=\"fig2.svg\" width=\"300\">\n\n从这里也可以看出，所谓的“力”事实上并不存在，纸团的偏转完全是纸团的切向速度大于圆周运动线速度而偏离原来的位置，平面内没有任何力的作用使其真正偏转——假如纸团不受空气阻力，在观众看来，纸团应该做抛体运动，自然其轨迹的俯视图为一条直线，但是当我们置身于旋转木马中时，它的确看起来有一个“力”使其“偏转”，这又如何解释呢？\n\n问题出在我们**置身于旋转木马中**。\n\n## 更严格的推导\n\n继承上面的假设，旋转木马做匀速圆周运动，其可以看成一个[非惯性系](https://en.wikipedia.org/wiki/Inertial_frame_of_reference)，在这个参考系中，牛顿第一定律并不成立，为了使牛顿第一定律看起来成立，我们引入了[惯性力](https://en.wikipedia.org/wiki/Fictitious_force)。\n\n现在，让我们做回观众：\n\n<img src=\"fig3.png\" width=\"500\">\n\n显然有\n\n$$\n\\vec{R}=\\vec{r}_\\perp = \\vec{r} - \\vec{r}_\\parallel = \\vec{r} - \\frac{(\\vec{r}\\cdot\\vec{\\omega}) \\cdot \\vec{\\omega}}{ {\\omega}^2}\n$$\n\n将其简单变形\n\n$$\n{\\omega}^2 \\vec{R} = {\\omega}^2 \\vec{r} -(\\vec{r}\\cdot\\vec{\\omega}) \\cdot \\vec{\\omega} = -\\vec{\\omega}\\times(\\vec{\\omega}\\times\\vec{r})\n$$\n\n此时的 ${\\omega}^2 \\vec{R}$ 就是我们熟知的惯性离心加速度，方向与 $\\vec{R}$ 一致，它也是惯性加速度的一种，但不是我们今天要研究的主角。\n\n取一小段时间 $\\Delta t$ ：\n\n<img src=\"fig4.png\" width=\"300\">\n\n矢量 $\\vec{P}$ 的增量为\n\n$$\n\\Delta P \\approx P\\sin\\theta\\omega\\Delta t=|\\vec{\\omega}\\times \\vec{P}|\\Delta t\n$$\n\n$\\Delta \\vec{P}$方向与 $\\vec{\\omega}$ 和 $\\vec{P}$ 的方向都垂直，即为 $\\vec{\\omega}\\times\\vec{P}$ 的方向，因此上式可以写为\n\n$$\n\\Delta \\vec{P} \\approx\\vec{\\omega}\\times \\vec{P}\\Delta t\n$$\n\n故 $\\vec{P}$ 的变化率可以表示为其对时间的导数\n\n$$\n\\frac{\\mathrm{D}\\vec{P}}{\\mathrm{D}t} = \\lim_{\\Delta t\\rightarrow0} \\frac{\\Delta\\vec{P}}{\\Delta t} = \\vec{\\omega} \\times \\vec{P}\n$$\n上式中大写的 $\\mathrm D$ 表示以静止系统为参考系时各变量的微分，而小写的 $\\mathrm d$ 则表示以旋转系统为参考系时变量的微分。上面式子中我们假定 $\\vec{P}$ 在旋转体系中都是恒矢量，否则 $\\vec{P}$ 的导数应该表示为\n\n$$\n\\frac{\\mathrm{D}\\vec{P}}{\\mathrm{D}t} = \\lim_{\\Delta t\\rightarrow0} \\frac{\\Delta\\vec{P}}{\\Delta t} = \\vec{\\omega} \\times \\vec{P} + \\frac{\\mathrm d \\vec{P}}{\\mathrm d t}\n$$\n\n上式适用于任何矢量 $\\vec{P}$ ，我们取一个质点的位矢 $\\vec{r} = \\vec{P}$ ，于是有\n\n$$\n\\frac{\\mathrm D \\vec{r}}{\\mathrm D t} = \\vec{\\omega}\\times \\vec{r} + \\frac{\\mathrm d\\vec{r}}{\\mathrm d t} = \\vec{\\omega}\\times \\vec{r} + \\vec{v}\n$$\n\n其中的 $\\vec{v}$ 表示质点相对于旋转体系的速度矢量。对上式再次求导，即得到加速度\n\n$$\n\\begin{aligned}\n\n\\vec{A} = \\frac{\\mathrm D^2 \\vec{r}}{\\mathrm D t^2} &= \\vec{\\omega}\\times\\frac{\\mathrm D\\vec{r}}{\\mathrm D t} + \\frac{\\mathrm d \\vec{v}}{\\mathrm dt} \\\\\n\t&= \\vec{\\omega}\\times(\\vec{\\omega}\\times \\vec{r} + \\vec{v}) + (\\vec{\\omega}\\times\\vec{v} + \\frac{\\mathrm d\\vec{v}}{\\mathrm d t}) \\\\\n\t&= \\vec{\\omega}\\times(\\vec{\\omega}\\times \\vec{r} ) + 2\\vec{\\omega}\\times\\vec{v} + \\vec{a}\n\n\\end{aligned}\n$$\n\n因此\n\n$$\n\\vec{a} =\\vec{A} - \\vec{\\omega}\\times(\\vec{\\omega}\\times\\vec{r}) - 2\\vec{\\omega}\\times\\vec{v}\n$$\n上式中 $\\vec{a}$ 表示质点相对于旋转体系的加速度，$\\vec{A}$ 是由真实的力提供的加速度，后面两项都是“假想”存在的加速度，即惯性加速度。其中 $-\\vec{\\omega}\\times(\\vec{\\omega}\\times\\vec{r})$ 是我们已知的惯性离心加速度，另一项 $-2\\vec{\\omega}\\times\\vec{r}$ 就是**科里奥利加速度**，我们用 $\\vec{a}_c$ 表示，有了科里奥利加速度，就得到科里奥利力 $\\vec{f}_c = m\\vec{a}_c$ 。\n\n根据右手定则，可以判断出其始终垂直于质点相对于旋转体系的速度，因此，质点相对于旋转体系运动时出现偏转也就很自然了。\n\n# 实际应用\n\n既然知道了科里奥利力是如何产生，那么知道这个东西对我们有什么用处呢？~~（可以拿来装X）~~ \n\n## 可以拿来侧纬度啦~\n\n我们所置身的地球就是一个旋转体系，只是它旋转得太慢了，平时难以察觉到科里奥利力的存在，但是有一种东西可以反映出科里奥利力的存在，那就是[傅科摆](https://en.wikipedia.org/wiki/Foucault_pendulum) ，如果你有足够的耐心观察它足够长的时间并确定它进动周期，你就可以很容易算出你所在位置的纬度，后面我们会给上推导这个公式的过程。\n\n为了理解如何通过傅科摆的进动角速度确定纬度，我们先来看一个简单的例子：\n\n<img src=\"fig5.png\" width=\"500\">\n\n一个可以旋转的圆盘上有一个单摆，当缓慢旋转圆盘时，我们假设惯性离心力很小，只有科里奥利力作用于单摆运动的切向。 当我们旋转圆盘 $90^\\circ$ 时，在静止体系观看单摆的摆平面没有任何变化，只是单纯的平移而已，没有任何转动，但是当以圆盘为参考系时（坐在 $C'$ 的位置向 $A$ 看），单摆的摆平面已经旋转了 $90^\\circ$ ，因此以圆盘的视角来观察这个现象时单摆进动的角速度就是圆盘转动的角速度。\n\n下面的动画应该很形象了：\n\n<img src=\"fig5.gif\">\n\n现在，我们让将摆线放大到67m长；将圆盘换成南极点的地面（相信这么做一定会有一群好奇的企鹅来围观）；讲缓慢转动圆盘换成地球大大的缓慢自转，这个上面的结论依然成立（当然如果你有上帝视角来看极点上的单摆进动，会更容易明白，就像看懂上面小圆盘上的单摆一样）。\n\n接下来，让我们把情况更加一般化，将这个巨大的单摆放到地球的任何可行的位置，问题变成了旋转球面上直线运动的进动问题，话不多说，看图：\n\n<img src=\"fig6_1.png\" width=\"400\"/>\n\n假设有一单摆在 $C$ 点（三个蓝点中最下面的那个），且在 $C$ 点建立一个坐标系（为了不使图更乱，我就不画了），平面 $CAE$ ~~（说得装X一些叫“C点所在子午面”）~~如下：\n\n<img src=\"fig6_2.svg\" width=\"150\">\n\n其中 $A$ 是球心， $AC$ 是半径， $CE \\perp CA$ 并且 $E$ 落在自转轴上，$\\angle \\psi$ 表示纬度，$\\angle \\theta$ 则是 $\\angle \\psi$ 的余角。\n\n我们取一小段时间 $\\Delta t$ ，由于地球的自转，单摆从 $C$ 点运动到 $D$ 点，那么 $D$ 点出坐标系的 $y'$ 轴与 $C$ 点处 $y$ 轴所成夹角即为坐标系偏转的角度 $\\angle \\text{看这里}$ （如下图），这个角度也就是在 $\\Delta t$ 时间内单摆进动的角度，现在只要求出 $\\angle \\text{看这里}$ 与 $\\omega \\Delta t$ 之间的关系即可求出单摆进动角速度与地球自转角速度的关系。\n\n<img src=\"fig6_3.svg\" width=\"300\">\n\n下面来求这个关系：\n\n$$\n\\begin{aligned}\n\n\\angle \\text{看这里} = \\angle CED  &=  \\frac {\\widehat{CD}}{CE} \\\\\\\\\n\t\t\t\t\t& = \\frac{ CE \\times \\sin\\psi \\times \\omega\\Delta t }{ CE } \\\\\\\\\n\t\t\t\t\t& = \\omega\\Delta t \\sin\\psi\n\n\\end{aligned}\n$$\n\n于是，单摆进动的角速度为\n\n$$\n\\begin{aligned}\n\n\\varOmega & = \\lim_{\\Delta t \\rightarrow 0} \\frac{\\angle \\text{看这里}} {\\Delta t} \\\\\\\\\n\t\t& = \\omega \\sin \\psi\n\n\\end{aligned}\n$$\n\n上面式子表明，当 $\\psi = \\pm 90 ^ \\circ$ 时，$\\varOmega = \\omega$ ，即当单摆处于极点时，其进动角速度等于地球自转角速度，也就是我们开始时提到单摆在圆盘时的情形。\n\n好了，现在回到傅科摆，只要我们观察足够长的时间，测量出其轨迹的进动角速度，又已知地球自转角速度，便可以轻松算出傅科摆所在的纬度。\n\n# 结语\n\n这是我在补《力学》时卡住的一个知识点，之前心中总把科里奥利力想象成惯性离心力那样，导致看到傅科摆时完全不知道如何理解，经过请教群友，老师以及动手画图实验，总算稍稍理解了，上面便是本渣的一点愚见，如有疏漏，还请在评论区指出，或邮件联系（联系方式见关于页面）。\n\n另外，如果有小伙伴有在2017年4月份之前注册的 B 站账号，还请在 8 月 24 日给和泉纱雾 [投票](https://bangumi.bilibili.com/moe/2017/jp/index/#/) 感激不尽。\n\n![Sagiri](Sagiri.jpg)\n\n以上","source":"_posts/Coriolis-Force.md","raw":"---\ntitle: 浅谈科里奥利力\ntags:\n  - 物理学\n  - 经典力学\n  - 科里奥利力\ncategories:\n  - Physics\ndate: 2017-08-23 13:25:06\n---\n\n\n## 简介\n\n苯渣在补力学时卡在了科氏力这一节，经过 Mr. Ren , 物吧大佬以及 [Wikipedia](https://en.wikipedia.org/wiki/Coriolis_force) 上的详细解释，我总算稍稍弄懂了这个家伙到底是怎么产生的了，于是写下本文分享一下愚见。\n\n# 引子\n\n坐过旋转木马的同学应该会有这样的体验：当坐在绕轴旋转的座位上向轴扔一个纸团（乱扔垃圾什么的最讨厌啦）时，纸团并不会砸到轴上，似乎纸团总是会偏离半径方向，并且总是偏向一个方向，这是为什么呢？这就要涉及到这篇文章要讲到的主角——科里奥利力。\n\n\n\n# 什么是科里奥利力？\n\n引用 Wikipedia 上的描述就是：\n\n> **科里奥利力**（简称：**科氏力**）是对旋转体系中进行直线运动的[质点](https://zh.wikipedia.org/wiki/%E8%B4%A8%E7%82%B9)由于[惯性](https://zh.wikipedia.org/wiki/%E6%85%A3%E6%80%A7)相对于旋转体系产生的直线运动的偏移的一种描述。此现象由法国著名数学家兼物理学家[古斯塔夫・科里奥利](https://zh.wikipedia.org/wiki/%E7%A7%91%E9%87%8C%E5%A5%A7%E5%88%A9)发现，因而得名；同时由于这种力在[地球自转](https://zh.wikipedia.org/wiki/%E5%9C%B0%E7%90%83%E8%87%AA%E8%BD%AC)下产生，因此又称为“**地转偏向力**”。\n\n个人理解：\n\n> 以一个旋转体系为参考系时，若研究对象相对于参考系的有非轴向运动的分量（或在垂直轴的平面内有运动分量）时，这个方向的运动分量会受到一个法向惯性力的作用而偏离原来的运动，这个力就是科里奥利力。\n\n上面的描述有两个要点：\n\n1. 参考体系为旋转体系，这也就意味着该参考系是一个非惯性系，其中必然要考虑惯性力的作用；\n2. 研究对象相对于参考系有相对运动，并且这个运动在垂直轴向的平面内有分量。\n\n# 科里奥利力如何产生？\n\n## 粗略的理解\n\n就拿引子里旋转木马的例子：\n\n假设旋转木马是做匀速圆周运动，角速度为 $ \\vec{\\omega} $ ，读者轨迹半径为 $\\vec{r}$ ，那么读者的公转线速度为\n$$\n\\vec{v}_t = \\vec{\\omega} \\times \\vec{r} \\notag\n$$\n如同这样：\n\n<img src=\"fig1.png\" width=\"400\" />\n\n（**注意这里的变量用矢量表示**）\n\n朝径向，也就是 $-\\vec{r}$ 方向扔一个纸团时，这个纸团既有朝向径向的速度 $\\vec{v}_n$ ，又有线速度 $\\vec{\\omega}\\times\\vec{r}$ ，当其运动到圆内侧时，内侧的线速度 \n$$\n\\vec{v}'_t = \\vec{\\omega}\\times\\vec{r}' < \\vec{\\omega}\\times\\vec{r} = \\vec{v}_t\n$$\n很自然地，纸团此时的切向速度比其所在圆上的的线速度更大，也就偏移了所谓的“直线”，读者视角俯视图见下图：\n\n<img src=\"fig2.svg\" width=\"300\">\n\n从这里也可以看出，所谓的“力”事实上并不存在，纸团的偏转完全是纸团的切向速度大于圆周运动线速度而偏离原来的位置，平面内没有任何力的作用使其真正偏转——假如纸团不受空气阻力，在观众看来，纸团应该做抛体运动，自然其轨迹的俯视图为一条直线，但是当我们置身于旋转木马中时，它的确看起来有一个“力”使其“偏转”，这又如何解释呢？\n\n问题出在我们**置身于旋转木马中**。\n\n## 更严格的推导\n\n继承上面的假设，旋转木马做匀速圆周运动，其可以看成一个[非惯性系](https://en.wikipedia.org/wiki/Inertial_frame_of_reference)，在这个参考系中，牛顿第一定律并不成立，为了使牛顿第一定律看起来成立，我们引入了[惯性力](https://en.wikipedia.org/wiki/Fictitious_force)。\n\n现在，让我们做回观众：\n\n<img src=\"fig3.png\" width=\"500\">\n\n显然有\n\n$$\n\\vec{R}=\\vec{r}_\\perp = \\vec{r} - \\vec{r}_\\parallel = \\vec{r} - \\frac{(\\vec{r}\\cdot\\vec{\\omega}) \\cdot \\vec{\\omega}}{ {\\omega}^2}\n$$\n\n将其简单变形\n\n$$\n{\\omega}^2 \\vec{R} = {\\omega}^2 \\vec{r} -(\\vec{r}\\cdot\\vec{\\omega}) \\cdot \\vec{\\omega} = -\\vec{\\omega}\\times(\\vec{\\omega}\\times\\vec{r})\n$$\n\n此时的 ${\\omega}^2 \\vec{R}$ 就是我们熟知的惯性离心加速度，方向与 $\\vec{R}$ 一致，它也是惯性加速度的一种，但不是我们今天要研究的主角。\n\n取一小段时间 $\\Delta t$ ：\n\n<img src=\"fig4.png\" width=\"300\">\n\n矢量 $\\vec{P}$ 的增量为\n\n$$\n\\Delta P \\approx P\\sin\\theta\\omega\\Delta t=|\\vec{\\omega}\\times \\vec{P}|\\Delta t\n$$\n\n$\\Delta \\vec{P}$方向与 $\\vec{\\omega}$ 和 $\\vec{P}$ 的方向都垂直，即为 $\\vec{\\omega}\\times\\vec{P}$ 的方向，因此上式可以写为\n\n$$\n\\Delta \\vec{P} \\approx\\vec{\\omega}\\times \\vec{P}\\Delta t\n$$\n\n故 $\\vec{P}$ 的变化率可以表示为其对时间的导数\n\n$$\n\\frac{\\mathrm{D}\\vec{P}}{\\mathrm{D}t} = \\lim_{\\Delta t\\rightarrow0} \\frac{\\Delta\\vec{P}}{\\Delta t} = \\vec{\\omega} \\times \\vec{P}\n$$\n上式中大写的 $\\mathrm D$ 表示以静止系统为参考系时各变量的微分，而小写的 $\\mathrm d$ 则表示以旋转系统为参考系时变量的微分。上面式子中我们假定 $\\vec{P}$ 在旋转体系中都是恒矢量，否则 $\\vec{P}$ 的导数应该表示为\n\n$$\n\\frac{\\mathrm{D}\\vec{P}}{\\mathrm{D}t} = \\lim_{\\Delta t\\rightarrow0} \\frac{\\Delta\\vec{P}}{\\Delta t} = \\vec{\\omega} \\times \\vec{P} + \\frac{\\mathrm d \\vec{P}}{\\mathrm d t}\n$$\n\n上式适用于任何矢量 $\\vec{P}$ ，我们取一个质点的位矢 $\\vec{r} = \\vec{P}$ ，于是有\n\n$$\n\\frac{\\mathrm D \\vec{r}}{\\mathrm D t} = \\vec{\\omega}\\times \\vec{r} + \\frac{\\mathrm d\\vec{r}}{\\mathrm d t} = \\vec{\\omega}\\times \\vec{r} + \\vec{v}\n$$\n\n其中的 $\\vec{v}$ 表示质点相对于旋转体系的速度矢量。对上式再次求导，即得到加速度\n\n$$\n\\begin{aligned}\n\n\\vec{A} = \\frac{\\mathrm D^2 \\vec{r}}{\\mathrm D t^2} &= \\vec{\\omega}\\times\\frac{\\mathrm D\\vec{r}}{\\mathrm D t} + \\frac{\\mathrm d \\vec{v}}{\\mathrm dt} \\\\\n\t&= \\vec{\\omega}\\times(\\vec{\\omega}\\times \\vec{r} + \\vec{v}) + (\\vec{\\omega}\\times\\vec{v} + \\frac{\\mathrm d\\vec{v}}{\\mathrm d t}) \\\\\n\t&= \\vec{\\omega}\\times(\\vec{\\omega}\\times \\vec{r} ) + 2\\vec{\\omega}\\times\\vec{v} + \\vec{a}\n\n\\end{aligned}\n$$\n\n因此\n\n$$\n\\vec{a} =\\vec{A} - \\vec{\\omega}\\times(\\vec{\\omega}\\times\\vec{r}) - 2\\vec{\\omega}\\times\\vec{v}\n$$\n上式中 $\\vec{a}$ 表示质点相对于旋转体系的加速度，$\\vec{A}$ 是由真实的力提供的加速度，后面两项都是“假想”存在的加速度，即惯性加速度。其中 $-\\vec{\\omega}\\times(\\vec{\\omega}\\times\\vec{r})$ 是我们已知的惯性离心加速度，另一项 $-2\\vec{\\omega}\\times\\vec{r}$ 就是**科里奥利加速度**，我们用 $\\vec{a}_c$ 表示，有了科里奥利加速度，就得到科里奥利力 $\\vec{f}_c = m\\vec{a}_c$ 。\n\n根据右手定则，可以判断出其始终垂直于质点相对于旋转体系的速度，因此，质点相对于旋转体系运动时出现偏转也就很自然了。\n\n# 实际应用\n\n既然知道了科里奥利力是如何产生，那么知道这个东西对我们有什么用处呢？~~（可以拿来装X）~~ \n\n## 可以拿来侧纬度啦~\n\n我们所置身的地球就是一个旋转体系，只是它旋转得太慢了，平时难以察觉到科里奥利力的存在，但是有一种东西可以反映出科里奥利力的存在，那就是[傅科摆](https://en.wikipedia.org/wiki/Foucault_pendulum) ，如果你有足够的耐心观察它足够长的时间并确定它进动周期，你就可以很容易算出你所在位置的纬度，后面我们会给上推导这个公式的过程。\n\n为了理解如何通过傅科摆的进动角速度确定纬度，我们先来看一个简单的例子：\n\n<img src=\"fig5.png\" width=\"500\">\n\n一个可以旋转的圆盘上有一个单摆，当缓慢旋转圆盘时，我们假设惯性离心力很小，只有科里奥利力作用于单摆运动的切向。 当我们旋转圆盘 $90^\\circ$ 时，在静止体系观看单摆的摆平面没有任何变化，只是单纯的平移而已，没有任何转动，但是当以圆盘为参考系时（坐在 $C'$ 的位置向 $A$ 看），单摆的摆平面已经旋转了 $90^\\circ$ ，因此以圆盘的视角来观察这个现象时单摆进动的角速度就是圆盘转动的角速度。\n\n下面的动画应该很形象了：\n\n<img src=\"fig5.gif\">\n\n现在，我们让将摆线放大到67m长；将圆盘换成南极点的地面（相信这么做一定会有一群好奇的企鹅来围观）；讲缓慢转动圆盘换成地球大大的缓慢自转，这个上面的结论依然成立（当然如果你有上帝视角来看极点上的单摆进动，会更容易明白，就像看懂上面小圆盘上的单摆一样）。\n\n接下来，让我们把情况更加一般化，将这个巨大的单摆放到地球的任何可行的位置，问题变成了旋转球面上直线运动的进动问题，话不多说，看图：\n\n<img src=\"fig6_1.png\" width=\"400\"/>\n\n假设有一单摆在 $C$ 点（三个蓝点中最下面的那个），且在 $C$ 点建立一个坐标系（为了不使图更乱，我就不画了），平面 $CAE$ ~~（说得装X一些叫“C点所在子午面”）~~如下：\n\n<img src=\"fig6_2.svg\" width=\"150\">\n\n其中 $A$ 是球心， $AC$ 是半径， $CE \\perp CA$ 并且 $E$ 落在自转轴上，$\\angle \\psi$ 表示纬度，$\\angle \\theta$ 则是 $\\angle \\psi$ 的余角。\n\n我们取一小段时间 $\\Delta t$ ，由于地球的自转，单摆从 $C$ 点运动到 $D$ 点，那么 $D$ 点出坐标系的 $y'$ 轴与 $C$ 点处 $y$ 轴所成夹角即为坐标系偏转的角度 $\\angle \\text{看这里}$ （如下图），这个角度也就是在 $\\Delta t$ 时间内单摆进动的角度，现在只要求出 $\\angle \\text{看这里}$ 与 $\\omega \\Delta t$ 之间的关系即可求出单摆进动角速度与地球自转角速度的关系。\n\n<img src=\"fig6_3.svg\" width=\"300\">\n\n下面来求这个关系：\n\n$$\n\\begin{aligned}\n\n\\angle \\text{看这里} = \\angle CED  &=  \\frac {\\widehat{CD}}{CE} \\\\\\\\\n\t\t\t\t\t& = \\frac{ CE \\times \\sin\\psi \\times \\omega\\Delta t }{ CE } \\\\\\\\\n\t\t\t\t\t& = \\omega\\Delta t \\sin\\psi\n\n\\end{aligned}\n$$\n\n于是，单摆进动的角速度为\n\n$$\n\\begin{aligned}\n\n\\varOmega & = \\lim_{\\Delta t \\rightarrow 0} \\frac{\\angle \\text{看这里}} {\\Delta t} \\\\\\\\\n\t\t& = \\omega \\sin \\psi\n\n\\end{aligned}\n$$\n\n上面式子表明，当 $\\psi = \\pm 90 ^ \\circ$ 时，$\\varOmega = \\omega$ ，即当单摆处于极点时，其进动角速度等于地球自转角速度，也就是我们开始时提到单摆在圆盘时的情形。\n\n好了，现在回到傅科摆，只要我们观察足够长的时间，测量出其轨迹的进动角速度，又已知地球自转角速度，便可以轻松算出傅科摆所在的纬度。\n\n# 结语\n\n这是我在补《力学》时卡住的一个知识点，之前心中总把科里奥利力想象成惯性离心力那样，导致看到傅科摆时完全不知道如何理解，经过请教群友，老师以及动手画图实验，总算稍稍理解了，上面便是本渣的一点愚见，如有疏漏，还请在评论区指出，或邮件联系（联系方式见关于页面）。\n\n另外，如果有小伙伴有在2017年4月份之前注册的 B 站账号，还请在 8 月 24 日给和泉纱雾 [投票](https://bangumi.bilibili.com/moe/2017/jp/index/#/) 感激不尽。\n\n![Sagiri](Sagiri.jpg)\n\n以上","slug":"Coriolis-Force","published":1,"updated":"2017-09-19T14:07:58.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj7rorijj0002tcjmjyn3m4ax","content":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>苯渣在补力学时卡在了科氏力这一节，经过 Mr. Ren , 物吧大佬以及 <a href=\"https://en.wikipedia.org/wiki/Coriolis_force\" target=\"_blank\" rel=\"external\">Wikipedia</a> 上的详细解释，我总算稍稍弄懂了这个家伙到底是怎么产生的了，于是写下本文分享一下愚见。</p>\n<h1 id=\"引子\"><a href=\"#引子\" class=\"headerlink\" title=\"引子\"></a>引子</h1><p>坐过旋转木马的同学应该会有这样的体验：当坐在绕轴旋转的座位上向轴扔一个纸团（乱扔垃圾什么的最讨厌啦）时，纸团并不会砸到轴上，似乎纸团总是会偏离半径方向，并且总是偏向一个方向，这是为什么呢？这就要涉及到这篇文章要讲到的主角——科里奥利力。</p>\n<h1 id=\"什么是科里奥利力？\"><a href=\"#什么是科里奥利力？\" class=\"headerlink\" title=\"什么是科里奥利力？\"></a>什么是科里奥利力？</h1><p>引用 Wikipedia 上的描述就是：</p>\n<blockquote>\n<p><strong>科里奥利力</strong>（简称：<strong>科氏力</strong>）是对旋转体系中进行直线运动的<a href=\"https://zh.wikipedia.org/wiki/%E8%B4%A8%E7%82%B9\" target=\"_blank\" rel=\"external\">质点</a>由于<a href=\"https://zh.wikipedia.org/wiki/%E6%85%A3%E6%80%A7\" target=\"_blank\" rel=\"external\">惯性</a>相对于旋转体系产生的直线运动的偏移的一种描述。此现象由法国著名数学家兼物理学家<a href=\"https://zh.wikipedia.org/wiki/%E7%A7%91%E9%87%8C%E5%A5%A7%E5%88%A9\" target=\"_blank\" rel=\"external\">古斯塔夫・科里奥利</a>发现，因而得名；同时由于这种力在<a href=\"https://zh.wikipedia.org/wiki/%E5%9C%B0%E7%90%83%E8%87%AA%E8%BD%AC\" target=\"_blank\" rel=\"external\">地球自转</a>下产生，因此又称为“<strong>地转偏向力</strong>”。</p>\n</blockquote>\n<p>个人理解：</p>\n<blockquote>\n<p>以一个旋转体系为参考系时，若研究对象相对于参考系的有非轴向运动的分量（或在垂直轴的平面内有运动分量）时，这个方向的运动分量会受到一个法向惯性力的作用而偏离原来的运动，这个力就是科里奥利力。</p>\n</blockquote>\n<p>上面的描述有两个要点：</p>\n<ol>\n<li>参考体系为旋转体系，这也就意味着该参考系是一个非惯性系，其中必然要考虑惯性力的作用；</li>\n<li>研究对象相对于参考系有相对运动，并且这个运动在垂直轴向的平面内有分量。</li>\n</ol>\n<h1 id=\"科里奥利力如何产生？\"><a href=\"#科里奥利力如何产生？\" class=\"headerlink\" title=\"科里奥利力如何产生？\"></a>科里奥利力如何产生？</h1><h2 id=\"粗略的理解\"><a href=\"#粗略的理解\" class=\"headerlink\" title=\"粗略的理解\"></a>粗略的理解</h2><p>就拿引子里旋转木马的例子：</p>\n<p>假设旋转木马是做匀速圆周运动，角速度为 $ \\vec{\\omega} $ ，读者轨迹半径为 $\\vec{r}$ ，那么读者的公转线速度为</p>\n<script type=\"math/tex; mode=display\">\n\\vec{v}_t = \\vec{\\omega} \\times \\vec{r} \\notag</script><p>如同这样：</p>\n<p><img src=\"fig1.png\" width=\"400\"></p>\n<p>（<strong>注意这里的变量用矢量表示</strong>）</p>\n<p>朝径向，也就是 $-\\vec{r}$ 方向扔一个纸团时，这个纸团既有朝向径向的速度 $\\vec{v}_n$ ，又有线速度 $\\vec{\\omega}\\times\\vec{r}$ ，当其运动到圆内侧时，内侧的线速度 </p>\n<script type=\"math/tex; mode=display\">\n\\vec{v}'_t = \\vec{\\omega}\\times\\vec{r}' < \\vec{\\omega}\\times\\vec{r} = \\vec{v}_t</script><p>很自然地，纸团此时的切向速度比其所在圆上的的线速度更大，也就偏移了所谓的“直线”，读者视角俯视图见下图：</p>\n<p><img src=\"fig2.svg\" width=\"300\"></p>\n<p>从这里也可以看出，所谓的“力”事实上并不存在，纸团的偏转完全是纸团的切向速度大于圆周运动线速度而偏离原来的位置，平面内没有任何力的作用使其真正偏转——假如纸团不受空气阻力，在观众看来，纸团应该做抛体运动，自然其轨迹的俯视图为一条直线，但是当我们置身于旋转木马中时，它的确看起来有一个“力”使其“偏转”，这又如何解释呢？</p>\n<p>问题出在我们<strong>置身于旋转木马中</strong>。</p>\n<h2 id=\"更严格的推导\"><a href=\"#更严格的推导\" class=\"headerlink\" title=\"更严格的推导\"></a>更严格的推导</h2><p>继承上面的假设，旋转木马做匀速圆周运动，其可以看成一个<a href=\"https://en.wikipedia.org/wiki/Inertial_frame_of_reference\" target=\"_blank\" rel=\"external\">非惯性系</a>，在这个参考系中，牛顿第一定律并不成立，为了使牛顿第一定律看起来成立，我们引入了<a href=\"https://en.wikipedia.org/wiki/Fictitious_force\" target=\"_blank\" rel=\"external\">惯性力</a>。</p>\n<p>现在，让我们做回观众：</p>\n<p><img src=\"fig3.png\" width=\"500\"></p>\n<p>显然有</p>\n<script type=\"math/tex; mode=display\">\n\\vec{R}=\\vec{r}_\\perp = \\vec{r} - \\vec{r}_\\parallel = \\vec{r} - \\frac{(\\vec{r}\\cdot\\vec{\\omega}) \\cdot \\vec{\\omega}}{ {\\omega}^2}</script><p>将其简单变形</p>\n<script type=\"math/tex; mode=display\">\n{\\omega}^2 \\vec{R} = {\\omega}^2 \\vec{r} -(\\vec{r}\\cdot\\vec{\\omega}) \\cdot \\vec{\\omega} = -\\vec{\\omega}\\times(\\vec{\\omega}\\times\\vec{r})</script><p>此时的 ${\\omega}^2 \\vec{R}$ 就是我们熟知的惯性离心加速度，方向与 $\\vec{R}$ 一致，它也是惯性加速度的一种，但不是我们今天要研究的主角。</p>\n<p>取一小段时间 $\\Delta t$ ：</p>\n<p><img src=\"fig4.png\" width=\"300\"></p>\n<p>矢量 $\\vec{P}$ 的增量为</p>\n<script type=\"math/tex; mode=display\">\n\\Delta P \\approx P\\sin\\theta\\omega\\Delta t=|\\vec{\\omega}\\times \\vec{P}|\\Delta t</script><p>$\\Delta \\vec{P}$方向与 $\\vec{\\omega}$ 和 $\\vec{P}$ 的方向都垂直，即为 $\\vec{\\omega}\\times\\vec{P}$ 的方向，因此上式可以写为</p>\n<script type=\"math/tex; mode=display\">\n\\Delta \\vec{P} \\approx\\vec{\\omega}\\times \\vec{P}\\Delta t</script><p>故 $\\vec{P}$ 的变化率可以表示为其对时间的导数</p>\n<script type=\"math/tex; mode=display\">\n\\frac{\\mathrm{D}\\vec{P}}{\\mathrm{D}t} = \\lim_{\\Delta t\\rightarrow0} \\frac{\\Delta\\vec{P}}{\\Delta t} = \\vec{\\omega} \\times \\vec{P}</script><p>上式中大写的 $\\mathrm D$ 表示以静止系统为参考系时各变量的微分，而小写的 $\\mathrm d$ 则表示以旋转系统为参考系时变量的微分。上面式子中我们假定 $\\vec{P}$ 在旋转体系中都是恒矢量，否则 $\\vec{P}$ 的导数应该表示为</p>\n<script type=\"math/tex; mode=display\">\n\\frac{\\mathrm{D}\\vec{P}}{\\mathrm{D}t} = \\lim_{\\Delta t\\rightarrow0} \\frac{\\Delta\\vec{P}}{\\Delta t} = \\vec{\\omega} \\times \\vec{P} + \\frac{\\mathrm d \\vec{P}}{\\mathrm d t}</script><p>上式适用于任何矢量 $\\vec{P}$ ，我们取一个质点的位矢 $\\vec{r} = \\vec{P}$ ，于是有</p>\n<script type=\"math/tex; mode=display\">\n\\frac{\\mathrm D \\vec{r}}{\\mathrm D t} = \\vec{\\omega}\\times \\vec{r} + \\frac{\\mathrm d\\vec{r}}{\\mathrm d t} = \\vec{\\omega}\\times \\vec{r} + \\vec{v}</script><p>其中的 $\\vec{v}$ 表示质点相对于旋转体系的速度矢量。对上式再次求导，即得到加速度</p>\n<script type=\"math/tex; mode=display\">\n\\begin{aligned}\n\n\\vec{A} = \\frac{\\mathrm D^2 \\vec{r}}{\\mathrm D t^2} &= \\vec{\\omega}\\times\\frac{\\mathrm D\\vec{r}}{\\mathrm D t} + \\frac{\\mathrm d \\vec{v}}{\\mathrm dt} \\\\\n    &= \\vec{\\omega}\\times(\\vec{\\omega}\\times \\vec{r} + \\vec{v}) + (\\vec{\\omega}\\times\\vec{v} + \\frac{\\mathrm d\\vec{v}}{\\mathrm d t}) \\\\\n    &= \\vec{\\omega}\\times(\\vec{\\omega}\\times \\vec{r} ) + 2\\vec{\\omega}\\times\\vec{v} + \\vec{a}\n\n\\end{aligned}</script><p>因此</p>\n<script type=\"math/tex; mode=display\">\n\\vec{a} =\\vec{A} - \\vec{\\omega}\\times(\\vec{\\omega}\\times\\vec{r}) - 2\\vec{\\omega}\\times\\vec{v}</script><p>上式中 $\\vec{a}$ 表示质点相对于旋转体系的加速度，$\\vec{A}$ 是由真实的力提供的加速度，后面两项都是“假想”存在的加速度，即惯性加速度。其中 $-\\vec{\\omega}\\times(\\vec{\\omega}\\times\\vec{r})$ 是我们已知的惯性离心加速度，另一项 $-2\\vec{\\omega}\\times\\vec{r}$ 就是<strong>科里奥利加速度</strong>，我们用 $\\vec{a}_c$ 表示，有了科里奥利加速度，就得到科里奥利力 $\\vec{f}_c = m\\vec{a}_c$ 。</p>\n<p>根据右手定则，可以判断出其始终垂直于质点相对于旋转体系的速度，因此，质点相对于旋转体系运动时出现偏转也就很自然了。</p>\n<h1 id=\"实际应用\"><a href=\"#实际应用\" class=\"headerlink\" title=\"实际应用\"></a>实际应用</h1><p>既然知道了科里奥利力是如何产生，那么知道这个东西对我们有什么用处呢？<del>（可以拿来装X）</del> </p>\n<h2 id=\"可以拿来侧纬度啦\"><a href=\"#可以拿来侧纬度啦\" class=\"headerlink\" title=\"可以拿来侧纬度啦~\"></a>可以拿来侧纬度啦~</h2><p>我们所置身的地球就是一个旋转体系，只是它旋转得太慢了，平时难以察觉到科里奥利力的存在，但是有一种东西可以反映出科里奥利力的存在，那就是<a href=\"https://en.wikipedia.org/wiki/Foucault_pendulum\" target=\"_blank\" rel=\"external\">傅科摆</a> ，如果你有足够的耐心观察它足够长的时间并确定它进动周期，你就可以很容易算出你所在位置的纬度，后面我们会给上推导这个公式的过程。</p>\n<p>为了理解如何通过傅科摆的进动角速度确定纬度，我们先来看一个简单的例子：</p>\n<p><img src=\"fig5.png\" width=\"500\"></p>\n<p>一个可以旋转的圆盘上有一个单摆，当缓慢旋转圆盘时，我们假设惯性离心力很小，只有科里奥利力作用于单摆运动的切向。 当我们旋转圆盘 $90^\\circ$ 时，在静止体系观看单摆的摆平面没有任何变化，只是单纯的平移而已，没有任何转动，但是当以圆盘为参考系时（坐在 $C’$ 的位置向 $A$ 看），单摆的摆平面已经旋转了 $90^\\circ$ ，因此以圆盘的视角来观察这个现象时单摆进动的角速度就是圆盘转动的角速度。</p>\n<p>下面的动画应该很形象了：</p>\n<p><img src=\"fig5.gif\"></p>\n<p>现在，我们让将摆线放大到67m长；将圆盘换成南极点的地面（相信这么做一定会有一群好奇的企鹅来围观）；讲缓慢转动圆盘换成地球大大的缓慢自转，这个上面的结论依然成立（当然如果你有上帝视角来看极点上的单摆进动，会更容易明白，就像看懂上面小圆盘上的单摆一样）。</p>\n<p>接下来，让我们把情况更加一般化，将这个巨大的单摆放到地球的任何可行的位置，问题变成了旋转球面上直线运动的进动问题，话不多说，看图：</p>\n<p><img src=\"fig6_1.png\" width=\"400\"></p>\n<p>假设有一单摆在 $C$ 点（三个蓝点中最下面的那个），且在 $C$ 点建立一个坐标系（为了不使图更乱，我就不画了），平面 $CAE$ <del>（说得装X一些叫“C点所在子午面”）</del>如下：</p>\n<p><img src=\"fig6_2.svg\" width=\"150\"></p>\n<p>其中 $A$ 是球心， $AC$ 是半径， $CE \\perp CA$ 并且 $E$ 落在自转轴上，$\\angle \\psi$ 表示纬度，$\\angle \\theta$ 则是 $\\angle \\psi$ 的余角。</p>\n<p>我们取一小段时间 $\\Delta t$ ，由于地球的自转，单摆从 $C$ 点运动到 $D$ 点，那么 $D$ 点出坐标系的 $y’$ 轴与 $C$ 点处 $y$ 轴所成夹角即为坐标系偏转的角度 $\\angle \\text{看这里}$ （如下图），这个角度也就是在 $\\Delta t$ 时间内单摆进动的角度，现在只要求出 $\\angle \\text{看这里}$ 与 $\\omega \\Delta t$ 之间的关系即可求出单摆进动角速度与地球自转角速度的关系。</p>\n<p><img src=\"fig6_3.svg\" width=\"300\"></p>\n<p>下面来求这个关系：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{aligned}\n\n\\angle \\text{看这里} = \\angle CED  &=  \\frac {\\widehat{CD}}{CE} \\\\\\\\\n                    & = \\frac{ CE \\times \\sin\\psi \\times \\omega\\Delta t }{ CE } \\\\\\\\\n                    & = \\omega\\Delta t \\sin\\psi\n\n\\end{aligned}</script><p>于是，单摆进动的角速度为</p>\n<script type=\"math/tex; mode=display\">\n\\begin{aligned}\n\n\\varOmega & = \\lim_{\\Delta t \\rightarrow 0} \\frac{\\angle \\text{看这里}} {\\Delta t} \\\\\\\\\n        & = \\omega \\sin \\psi\n\n\\end{aligned}</script><p>上面式子表明，当 $\\psi = \\pm 90 ^ \\circ$ 时，$\\varOmega = \\omega$ ，即当单摆处于极点时，其进动角速度等于地球自转角速度，也就是我们开始时提到单摆在圆盘时的情形。</p>\n<p>好了，现在回到傅科摆，只要我们观察足够长的时间，测量出其轨迹的进动角速度，又已知地球自转角速度，便可以轻松算出傅科摆所在的纬度。</p>\n<h1 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h1><p>这是我在补《力学》时卡住的一个知识点，之前心中总把科里奥利力想象成惯性离心力那样，导致看到傅科摆时完全不知道如何理解，经过请教群友，老师以及动手画图实验，总算稍稍理解了，上面便是本渣的一点愚见，如有疏漏，还请在评论区指出，或邮件联系（联系方式见关于页面）。</p>\n<p>另外，如果有小伙伴有在2017年4月份之前注册的 B 站账号，还请在 8 月 24 日给和泉纱雾 <a href=\"https://bangumi.bilibili.com/moe/2017/jp/index/#/\" target=\"_blank\" rel=\"external\">投票</a> 感激不尽。</p>\n<p><img src=\"Sagiri.jpg\" alt=\"Sagiri\"></p>\n<p>以上</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>苯渣在补力学时卡在了科氏力这一节，经过 Mr. Ren , 物吧大佬以及 <a href=\"https://en.wikipedia.org/wiki/Coriolis_force\" target=\"_blank\" rel=\"external\">Wikipedia</a> 上的详细解释，我总算稍稍弄懂了这个家伙到底是怎么产生的了，于是写下本文分享一下愚见。</p>\n<h1 id=\"引子\"><a href=\"#引子\" class=\"headerlink\" title=\"引子\"></a>引子</h1><p>坐过旋转木马的同学应该会有这样的体验：当坐在绕轴旋转的座位上向轴扔一个纸团（乱扔垃圾什么的最讨厌啦）时，纸团并不会砸到轴上，似乎纸团总是会偏离半径方向，并且总是偏向一个方向，这是为什么呢？这就要涉及到这篇文章要讲到的主角——科里奥利力。</p>\n<h1 id=\"什么是科里奥利力？\"><a href=\"#什么是科里奥利力？\" class=\"headerlink\" title=\"什么是科里奥利力？\"></a>什么是科里奥利力？</h1><p>引用 Wikipedia 上的描述就是：</p>\n<blockquote>\n<p><strong>科里奥利力</strong>（简称：<strong>科氏力</strong>）是对旋转体系中进行直线运动的<a href=\"https://zh.wikipedia.org/wiki/%E8%B4%A8%E7%82%B9\" target=\"_blank\" rel=\"external\">质点</a>由于<a href=\"https://zh.wikipedia.org/wiki/%E6%85%A3%E6%80%A7\" target=\"_blank\" rel=\"external\">惯性</a>相对于旋转体系产生的直线运动的偏移的一种描述。此现象由法国著名数学家兼物理学家<a href=\"https://zh.wikipedia.org/wiki/%E7%A7%91%E9%87%8C%E5%A5%A7%E5%88%A9\" target=\"_blank\" rel=\"external\">古斯塔夫・科里奥利</a>发现，因而得名；同时由于这种力在<a href=\"https://zh.wikipedia.org/wiki/%E5%9C%B0%E7%90%83%E8%87%AA%E8%BD%AC\" target=\"_blank\" rel=\"external\">地球自转</a>下产生，因此又称为“<strong>地转偏向力</strong>”。</p>\n</blockquote>\n<p>个人理解：</p>\n<blockquote>\n<p>以一个旋转体系为参考系时，若研究对象相对于参考系的有非轴向运动的分量（或在垂直轴的平面内有运动分量）时，这个方向的运动分量会受到一个法向惯性力的作用而偏离原来的运动，这个力就是科里奥利力。</p>\n</blockquote>\n<p>上面的描述有两个要点：</p>\n<ol>\n<li>参考体系为旋转体系，这也就意味着该参考系是一个非惯性系，其中必然要考虑惯性力的作用；</li>\n<li>研究对象相对于参考系有相对运动，并且这个运动在垂直轴向的平面内有分量。</li>\n</ol>\n<h1 id=\"科里奥利力如何产生？\"><a href=\"#科里奥利力如何产生？\" class=\"headerlink\" title=\"科里奥利力如何产生？\"></a>科里奥利力如何产生？</h1><h2 id=\"粗略的理解\"><a href=\"#粗略的理解\" class=\"headerlink\" title=\"粗略的理解\"></a>粗略的理解</h2><p>就拿引子里旋转木马的例子：</p>\n<p>假设旋转木马是做匀速圆周运动，角速度为 $ \\vec{\\omega} $ ，读者轨迹半径为 $\\vec{r}$ ，那么读者的公转线速度为</p>\n<script type=\"math/tex; mode=display\">\n\\vec{v}_t = \\vec{\\omega} \\times \\vec{r} \\notag</script><p>如同这样：</p>\n<p><img src=\"fig1.png\" width=\"400\"></p>\n<p>（<strong>注意这里的变量用矢量表示</strong>）</p>\n<p>朝径向，也就是 $-\\vec{r}$ 方向扔一个纸团时，这个纸团既有朝向径向的速度 $\\vec{v}_n$ ，又有线速度 $\\vec{\\omega}\\times\\vec{r}$ ，当其运动到圆内侧时，内侧的线速度 </p>\n<script type=\"math/tex; mode=display\">\n\\vec{v}'_t = \\vec{\\omega}\\times\\vec{r}' < \\vec{\\omega}\\times\\vec{r} = \\vec{v}_t</script><p>很自然地，纸团此时的切向速度比其所在圆上的的线速度更大，也就偏移了所谓的“直线”，读者视角俯视图见下图：</p>\n<p><img src=\"fig2.svg\" width=\"300\"></p>\n<p>从这里也可以看出，所谓的“力”事实上并不存在，纸团的偏转完全是纸团的切向速度大于圆周运动线速度而偏离原来的位置，平面内没有任何力的作用使其真正偏转——假如纸团不受空气阻力，在观众看来，纸团应该做抛体运动，自然其轨迹的俯视图为一条直线，但是当我们置身于旋转木马中时，它的确看起来有一个“力”使其“偏转”，这又如何解释呢？</p>\n<p>问题出在我们<strong>置身于旋转木马中</strong>。</p>\n<h2 id=\"更严格的推导\"><a href=\"#更严格的推导\" class=\"headerlink\" title=\"更严格的推导\"></a>更严格的推导</h2><p>继承上面的假设，旋转木马做匀速圆周运动，其可以看成一个<a href=\"https://en.wikipedia.org/wiki/Inertial_frame_of_reference\" target=\"_blank\" rel=\"external\">非惯性系</a>，在这个参考系中，牛顿第一定律并不成立，为了使牛顿第一定律看起来成立，我们引入了<a href=\"https://en.wikipedia.org/wiki/Fictitious_force\" target=\"_blank\" rel=\"external\">惯性力</a>。</p>\n<p>现在，让我们做回观众：</p>\n<p><img src=\"fig3.png\" width=\"500\"></p>\n<p>显然有</p>\n<script type=\"math/tex; mode=display\">\n\\vec{R}=\\vec{r}_\\perp = \\vec{r} - \\vec{r}_\\parallel = \\vec{r} - \\frac{(\\vec{r}\\cdot\\vec{\\omega}) \\cdot \\vec{\\omega}}{ {\\omega}^2}</script><p>将其简单变形</p>\n<script type=\"math/tex; mode=display\">\n{\\omega}^2 \\vec{R} = {\\omega}^2 \\vec{r} -(\\vec{r}\\cdot\\vec{\\omega}) \\cdot \\vec{\\omega} = -\\vec{\\omega}\\times(\\vec{\\omega}\\times\\vec{r})</script><p>此时的 ${\\omega}^2 \\vec{R}$ 就是我们熟知的惯性离心加速度，方向与 $\\vec{R}$ 一致，它也是惯性加速度的一种，但不是我们今天要研究的主角。</p>\n<p>取一小段时间 $\\Delta t$ ：</p>\n<p><img src=\"fig4.png\" width=\"300\"></p>\n<p>矢量 $\\vec{P}$ 的增量为</p>\n<script type=\"math/tex; mode=display\">\n\\Delta P \\approx P\\sin\\theta\\omega\\Delta t=|\\vec{\\omega}\\times \\vec{P}|\\Delta t</script><p>$\\Delta \\vec{P}$方向与 $\\vec{\\omega}$ 和 $\\vec{P}$ 的方向都垂直，即为 $\\vec{\\omega}\\times\\vec{P}$ 的方向，因此上式可以写为</p>\n<script type=\"math/tex; mode=display\">\n\\Delta \\vec{P} \\approx\\vec{\\omega}\\times \\vec{P}\\Delta t</script><p>故 $\\vec{P}$ 的变化率可以表示为其对时间的导数</p>\n<script type=\"math/tex; mode=display\">\n\\frac{\\mathrm{D}\\vec{P}}{\\mathrm{D}t} = \\lim_{\\Delta t\\rightarrow0} \\frac{\\Delta\\vec{P}}{\\Delta t} = \\vec{\\omega} \\times \\vec{P}</script><p>上式中大写的 $\\mathrm D$ 表示以静止系统为参考系时各变量的微分，而小写的 $\\mathrm d$ 则表示以旋转系统为参考系时变量的微分。上面式子中我们假定 $\\vec{P}$ 在旋转体系中都是恒矢量，否则 $\\vec{P}$ 的导数应该表示为</p>\n<script type=\"math/tex; mode=display\">\n\\frac{\\mathrm{D}\\vec{P}}{\\mathrm{D}t} = \\lim_{\\Delta t\\rightarrow0} \\frac{\\Delta\\vec{P}}{\\Delta t} = \\vec{\\omega} \\times \\vec{P} + \\frac{\\mathrm d \\vec{P}}{\\mathrm d t}</script><p>上式适用于任何矢量 $\\vec{P}$ ，我们取一个质点的位矢 $\\vec{r} = \\vec{P}$ ，于是有</p>\n<script type=\"math/tex; mode=display\">\n\\frac{\\mathrm D \\vec{r}}{\\mathrm D t} = \\vec{\\omega}\\times \\vec{r} + \\frac{\\mathrm d\\vec{r}}{\\mathrm d t} = \\vec{\\omega}\\times \\vec{r} + \\vec{v}</script><p>其中的 $\\vec{v}$ 表示质点相对于旋转体系的速度矢量。对上式再次求导，即得到加速度</p>\n<script type=\"math/tex; mode=display\">\n\\begin{aligned}\n\n\\vec{A} = \\frac{\\mathrm D^2 \\vec{r}}{\\mathrm D t^2} &= \\vec{\\omega}\\times\\frac{\\mathrm D\\vec{r}}{\\mathrm D t} + \\frac{\\mathrm d \\vec{v}}{\\mathrm dt} \\\\\n    &= \\vec{\\omega}\\times(\\vec{\\omega}\\times \\vec{r} + \\vec{v}) + (\\vec{\\omega}\\times\\vec{v} + \\frac{\\mathrm d\\vec{v}}{\\mathrm d t}) \\\\\n    &= \\vec{\\omega}\\times(\\vec{\\omega}\\times \\vec{r} ) + 2\\vec{\\omega}\\times\\vec{v} + \\vec{a}\n\n\\end{aligned}</script><p>因此</p>\n<script type=\"math/tex; mode=display\">\n\\vec{a} =\\vec{A} - \\vec{\\omega}\\times(\\vec{\\omega}\\times\\vec{r}) - 2\\vec{\\omega}\\times\\vec{v}</script><p>上式中 $\\vec{a}$ 表示质点相对于旋转体系的加速度，$\\vec{A}$ 是由真实的力提供的加速度，后面两项都是“假想”存在的加速度，即惯性加速度。其中 $-\\vec{\\omega}\\times(\\vec{\\omega}\\times\\vec{r})$ 是我们已知的惯性离心加速度，另一项 $-2\\vec{\\omega}\\times\\vec{r}$ 就是<strong>科里奥利加速度</strong>，我们用 $\\vec{a}_c$ 表示，有了科里奥利加速度，就得到科里奥利力 $\\vec{f}_c = m\\vec{a}_c$ 。</p>\n<p>根据右手定则，可以判断出其始终垂直于质点相对于旋转体系的速度，因此，质点相对于旋转体系运动时出现偏转也就很自然了。</p>\n<h1 id=\"实际应用\"><a href=\"#实际应用\" class=\"headerlink\" title=\"实际应用\"></a>实际应用</h1><p>既然知道了科里奥利力是如何产生，那么知道这个东西对我们有什么用处呢？<del>（可以拿来装X）</del> </p>\n<h2 id=\"可以拿来侧纬度啦\"><a href=\"#可以拿来侧纬度啦\" class=\"headerlink\" title=\"可以拿来侧纬度啦~\"></a>可以拿来侧纬度啦~</h2><p>我们所置身的地球就是一个旋转体系，只是它旋转得太慢了，平时难以察觉到科里奥利力的存在，但是有一种东西可以反映出科里奥利力的存在，那就是<a href=\"https://en.wikipedia.org/wiki/Foucault_pendulum\" target=\"_blank\" rel=\"external\">傅科摆</a> ，如果你有足够的耐心观察它足够长的时间并确定它进动周期，你就可以很容易算出你所在位置的纬度，后面我们会给上推导这个公式的过程。</p>\n<p>为了理解如何通过傅科摆的进动角速度确定纬度，我们先来看一个简单的例子：</p>\n<p><img src=\"fig5.png\" width=\"500\"></p>\n<p>一个可以旋转的圆盘上有一个单摆，当缓慢旋转圆盘时，我们假设惯性离心力很小，只有科里奥利力作用于单摆运动的切向。 当我们旋转圆盘 $90^\\circ$ 时，在静止体系观看单摆的摆平面没有任何变化，只是单纯的平移而已，没有任何转动，但是当以圆盘为参考系时（坐在 $C’$ 的位置向 $A$ 看），单摆的摆平面已经旋转了 $90^\\circ$ ，因此以圆盘的视角来观察这个现象时单摆进动的角速度就是圆盘转动的角速度。</p>\n<p>下面的动画应该很形象了：</p>\n<p><img src=\"fig5.gif\"></p>\n<p>现在，我们让将摆线放大到67m长；将圆盘换成南极点的地面（相信这么做一定会有一群好奇的企鹅来围观）；讲缓慢转动圆盘换成地球大大的缓慢自转，这个上面的结论依然成立（当然如果你有上帝视角来看极点上的单摆进动，会更容易明白，就像看懂上面小圆盘上的单摆一样）。</p>\n<p>接下来，让我们把情况更加一般化，将这个巨大的单摆放到地球的任何可行的位置，问题变成了旋转球面上直线运动的进动问题，话不多说，看图：</p>\n<p><img src=\"fig6_1.png\" width=\"400\"></p>\n<p>假设有一单摆在 $C$ 点（三个蓝点中最下面的那个），且在 $C$ 点建立一个坐标系（为了不使图更乱，我就不画了），平面 $CAE$ <del>（说得装X一些叫“C点所在子午面”）</del>如下：</p>\n<p><img src=\"fig6_2.svg\" width=\"150\"></p>\n<p>其中 $A$ 是球心， $AC$ 是半径， $CE \\perp CA$ 并且 $E$ 落在自转轴上，$\\angle \\psi$ 表示纬度，$\\angle \\theta$ 则是 $\\angle \\psi$ 的余角。</p>\n<p>我们取一小段时间 $\\Delta t$ ，由于地球的自转，单摆从 $C$ 点运动到 $D$ 点，那么 $D$ 点出坐标系的 $y’$ 轴与 $C$ 点处 $y$ 轴所成夹角即为坐标系偏转的角度 $\\angle \\text{看这里}$ （如下图），这个角度也就是在 $\\Delta t$ 时间内单摆进动的角度，现在只要求出 $\\angle \\text{看这里}$ 与 $\\omega \\Delta t$ 之间的关系即可求出单摆进动角速度与地球自转角速度的关系。</p>\n<p><img src=\"fig6_3.svg\" width=\"300\"></p>\n<p>下面来求这个关系：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{aligned}\n\n\\angle \\text{看这里} = \\angle CED  &=  \\frac {\\widehat{CD}}{CE} \\\\\\\\\n                    & = \\frac{ CE \\times \\sin\\psi \\times \\omega\\Delta t }{ CE } \\\\\\\\\n                    & = \\omega\\Delta t \\sin\\psi\n\n\\end{aligned}</script><p>于是，单摆进动的角速度为</p>\n<script type=\"math/tex; mode=display\">\n\\begin{aligned}\n\n\\varOmega & = \\lim_{\\Delta t \\rightarrow 0} \\frac{\\angle \\text{看这里}} {\\Delta t} \\\\\\\\\n        & = \\omega \\sin \\psi\n\n\\end{aligned}</script><p>上面式子表明，当 $\\psi = \\pm 90 ^ \\circ$ 时，$\\varOmega = \\omega$ ，即当单摆处于极点时，其进动角速度等于地球自转角速度，也就是我们开始时提到单摆在圆盘时的情形。</p>\n<p>好了，现在回到傅科摆，只要我们观察足够长的时间，测量出其轨迹的进动角速度，又已知地球自转角速度，便可以轻松算出傅科摆所在的纬度。</p>\n<h1 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h1><p>这是我在补《力学》时卡住的一个知识点，之前心中总把科里奥利力想象成惯性离心力那样，导致看到傅科摆时完全不知道如何理解，经过请教群友，老师以及动手画图实验，总算稍稍理解了，上面便是本渣的一点愚见，如有疏漏，还请在评论区指出，或邮件联系（联系方式见关于页面）。</p>\n<p>另外，如果有小伙伴有在2017年4月份之前注册的 B 站账号，还请在 8 月 24 日给和泉纱雾 <a href=\"https://bangumi.bilibili.com/moe/2017/jp/index/#/\" target=\"_blank\" rel=\"external\">投票</a> 感激不尽。</p>\n<p><img src=\"Sagiri.jpg\" alt=\"Sagiri\"></p>\n<p>以上</p>\n"},{"title":"PAT题解 B 1035","date":"2017-06-22T05:33:59.000Z","_content":"\n# 题解:PAT-B 1035 插入与归并\n\n这是一篇测试用文章，欢迎围观.\n\n## 题目全文：\n题目地址在[这里](https://www.patest.cn/contests/pat-b-practise/1035)\n> 根据维基百科的定义：\n\n> 插入排序是迭代算法，逐一获得输入数据，逐步产生有序的输出序列。每步迭代中，算法从输入序列中取出一元素，将之插入有序序列中正确的位置。如此迭代直到全部元素有序。\n\n> 归并排序进行如下迭代操作：首先将原始序列看成N个只包含1个元素的有序子序列，然后每次迭代归并两个相邻的有序子序列，直到最后只剩下1个有序的序列。\n\n> 现给定原始序列和由某排序算法产生的中间序列，请你判断该算法究竟是哪种排序算法？\n\n> 输入格式：\n\n> 输入在第一行给出正整数N (<=100)；随后一行给出原始序列的N个整数；最后一行给出由某排序算法产生的中间序列。这里假设排序的目标序列是升序。数字间以空格分隔。\n\n> 输出格式：\n\n> 首先在第1行中输出“Insertion Sort”表示插入排序、或“Merge Sort”表示归并排序；然后在第2行中输出用该排序算法再迭代一轮的结果序列。题目保证每组测试的结果是唯一的。数字间以空格分隔，且行末不得有多余空格。\n\n输入样例1：\n```\n10\n3 1 2 8 7 5 9 4 6 0\n1 2 3 7 8 5 9 4 6 0\n```\n输出样例1：\n```\nInsertion Sort\n1 2 3 5 7 8 9 4 6 0\n```\n输入样例2：\n```\n10\n3 1 2 8 7 5 9 4 0 6\n1 3 2 8 5 7 4 9 0 6\n```\n输出样例2：\n```\nMerge Sort\n1 2 3 8 4 5 7 9 0 6\n```\n\n\n## 题目解读\n这是我刷乙级题时比较头疼的一道题，前后查阅了很多别人的代码，后又观看了陈越姥姥的[视频](http://www.icourse163.org/learn/ZJU-93001?tid=1002019005#/learn/content?type=detail&id=1002635050)总算弄明白了这道题需要注意哪些.\n\n1. 如何区分简单插入排序和**非递归**的归并排序;\n2. 如何根据测试用例的类型再迭代一次运算;\n3. 如何处理边界测试.\n\n这里要强调一下本题使用递归的归并排序是**无法AC**的，本渣使用递归的归并排序最多只能得到17分. 关于递归的归并与迭代归并区别请围观[这里](https://en.wikipedia.org/wiki/Merge_sort) (中文版省去了很多分析过程，强烈建议读英文原版)，另外，关于插入排序算法的Wiki在[这里](https://en.wikipedia.org/wiki/Insertion_sort).\n\n## 解题过程\n\n### 如何区分简单插入排序和非递归的归并排序\n只要抓住两个关键点即可：\n1. **使用插入排序序列的开头一部分一定是有序的**;\n2. **无序部分与原文一致**．\n\n比如下面这个例子:\n> 10  \n3 1 2 8 7 `5 9 4 6 0`  \n**1 2 3 7 8** `5 9 4 6 0`\n\n我们可以这样来判断:\n1. 首先扫描 `1 2 3 7 8` 为有序序列，当读取到`5`时发现 `8 > 5`暂停，执行步骤2;\n2. 从`5`开始对后面的序列与原序列进行比较，若发现全部是匹配的，则该序列的排序算法为插入排序,并记录下开始无序的位置;否则为归并排序.\n\n显然后面的部分与原文一致，因此这个序列排序使用的是插入排序. 注意这里必须满足以上***两个***条件才能推出插入排序算法．\n\n这里不得不提到有同学使用从后向前寻找不匹配点的方法来判断排序算法，这个方法是不对的，比如下面这个例子:  \n>3 1 2 8 7 5 9 4 `0 6`  \n1 3 2 8 5 7 4 9 `0 6`  \n\n虽然这里的后面一部分`0　6`与原题一致，但它并不满足前置子序列有序，因此它不是插入排序，后面的测试用例就有一个测试点来卡这种情况。\n\n对于如何判断是否使用归并排序则相对麻烦，考虑到题目中明确指出测试用例是合法的并且只能是归并和插入排序两种之一，所以这里使用排除法来确定归并排序．\n\n### 如何根据测试用例的类型再迭代一次运算\n#### 对于插入排序\n这个就非常简单了，如果明白了插入排序的算法，直接从上面记录下的点进行再迭代一次即可。\n\n#### 对于归并排序\n这个相对要麻烦一些，其关键步骤是确定归并段的长度。有的同学想到像插入排序一样从头开始寻找最长有序子序列，这是不对的，因为题意中归并排序是迭代一轮后才得到题目序列，即题目序列被分为若干归并段，**每一小段都是有序的**，因此若原文前一段本身已经有序，那么进行归并后得到的序列一定也是整体有序的，那么也就无法通过通过前置子序列的最大有序长度来代表所有归并段的长度。比如下面这个例子:\n\n> 10  \n`2 1 8 3` `7 5` `9 4` `0 6`  \n`1 2 3 8` `5 7` `4 9` `0 6`\n\n显然我们无法从`1 3 2 8`是最长前置有序子列就判断出归并段的长度为`4`。正确答案应该是`2`。\n\n有的同学使用模拟法，即对原序列进行分步归并排序，每迭代一次都与题目序列进行比较，直到发现匹配的情况为止。　这种方法在题目所给的时间限制下也能通过，但本着认真负责的态度，我们应该寻找一种更加**聪明**的办法来确定\n\n通过陈越姥姥的启发，我们总结出一下步骤判断最大归并段的长度：\n1. 假设每个归并段的长度为`l`, (`l`的初始值为`2`，因为一个元素不存在有序无序的概念);\n2. 对所有相邻两个归并段相连的两个元素进行比较，若该两元素仍有序，则归并段的长度`l *= 2`; 否则终止循环，`l`即为要确定的最大归并段长度。\n\n程序实现起来就是通过`for(l=2; l<=N; l*=2)`这个大循环内部完成的。  \n\n当确定了最大归并段长度，余下的工作就变得简单了，直接再迭代归并一次即可。\n具体代码可以参考最后的AC代码。\n### 如何处理边界测试\nPAT的题目测试不给出测试数据以及测试提示，比较考验同学们的程序测试能力，本渣在通过这道题时前后想了很久，也提交了很多次，还是在看了陈越姥姥的讲解后才知道测试数据的提示，测试数据包含一下几类：\n\n1. 最小`N`(`N = 4`，因为只有当`N >= 4`时才能区分出归并排序与插入排序中间子列).\n    * 插入排序第`1`步，什么都没改变;\n    * 归并排序第`1`步，什么都变了;\n2. 尾部子列无变化，但是前面变了(归并).\n3. 最大`N`.\n\n有了如上提示，加上前面的讲解，相信读者一定能够独立AC这道题了。\n\n## AC代码:\n```cpp\n#include <iostream>\n//#include <fstream>\n\nusing std::cin;\nusing std::cout;\nusing std::endl;\n\nint main()\n{\n//    std::ifstream cin(\"in.txt\");\n    int N;\n    cin >> N;\n    int *Orig = new int[N];\n    for(int i=0; i!=N; ++i){\n        cin >> Orig[i];\n    }\n    int *tmp = new int[N];\n    for(int i=0; i!=N; ++i){\n        cin >> tmp[i];\n    }\n    int k(0);\n    for(int i=k; i!=N-1; ++i){\n        if( tmp[i] > tmp[i+1] ){\n            k = i;\n            break;\n        }\n    }\n    bool IsInsertion(true);\n    for(int i=++k; i!=N; ++i){\n        if( tmp[i] != Orig[i] ){\n            IsInsertion = false;\n            break;\n        }\n    }\n    if( IsInsertion ){\n        cout << \"Insertion Sort\" << endl;\n        for(int i=k; i!=0; --i){\n            if( tmp[i] < tmp[i-1] ){\n                int t = tmp[i];\n                tmp[i] = tmp[i-1];\n                tmp[i-1] = t;\n            }else break;\n        }\n        for(int i=0; i!=N-1; ++i){\n            cout << tmp[i] << \" \";\n        }cout << tmp[N-1] << endl;\n    }else{\n        cout << \"Merge Sort\" << endl;\n        bool Identified = false;\n        for(int l=2; l<=N; l*=2){\n            for(int i=l; i<N; i += 2*l){\n                if( tmp[i-1] > tmp[i] ){\n                    Identified = true;\n                    break;\n                }\n            }\n            if( Identified ){\n                k = l;\n                break;\n            }\n        }\n//        cout << \"k = \" << k << endl;\n        for(int i=0; i<N; i+=k*2){\n            int *tmpArr = new int[k*2];\n            int lef = i;\n            const int mid = ( lef+k < N ) ? lef+k : N;\n            const int rig = ( mid+k < N ) ? mid+k : N;\n            int cur = mid;\n            int j=0;\n            while( lef < mid and cur < rig ){\n                if( tmp[lef] < tmp[cur] ){\n                    tmpArr[j++] = tmp[lef++];\n                }else{\n                    tmpArr[j++] = tmp[cur++];\n                }\n            }\n            while( lef < mid ){\n                tmpArr[j++] = tmp[lef++];\n            }\n            while( cur < rig ){\n                tmpArr[j++] = tmp[cur++];\n            }\n            for(int t=0; t!=j; ++t){\n                tmp[i+t] = tmpArr[t];\n            }\n            delete[] tmpArr;\n        }\n        for(int i=0; i!=N-1; ++i){\n            cout << tmp[i] << \" \";\n        }cout << tmp[N-1] << endl;\n    }\n    return 0;\n}\n\n```\n","source":"_posts/PAT题解-B-1035.md","raw":"---\ntitle: PAT题解 B 1035\ndate: 2017-06-22 13:33:59\ntags:\n    - C++\n    - PAT\n    - 排序\ncategories: Data Structure & Algorithm\n---\n\n# 题解:PAT-B 1035 插入与归并\n\n这是一篇测试用文章，欢迎围观.\n\n## 题目全文：\n题目地址在[这里](https://www.patest.cn/contests/pat-b-practise/1035)\n> 根据维基百科的定义：\n\n> 插入排序是迭代算法，逐一获得输入数据，逐步产生有序的输出序列。每步迭代中，算法从输入序列中取出一元素，将之插入有序序列中正确的位置。如此迭代直到全部元素有序。\n\n> 归并排序进行如下迭代操作：首先将原始序列看成N个只包含1个元素的有序子序列，然后每次迭代归并两个相邻的有序子序列，直到最后只剩下1个有序的序列。\n\n> 现给定原始序列和由某排序算法产生的中间序列，请你判断该算法究竟是哪种排序算法？\n\n> 输入格式：\n\n> 输入在第一行给出正整数N (<=100)；随后一行给出原始序列的N个整数；最后一行给出由某排序算法产生的中间序列。这里假设排序的目标序列是升序。数字间以空格分隔。\n\n> 输出格式：\n\n> 首先在第1行中输出“Insertion Sort”表示插入排序、或“Merge Sort”表示归并排序；然后在第2行中输出用该排序算法再迭代一轮的结果序列。题目保证每组测试的结果是唯一的。数字间以空格分隔，且行末不得有多余空格。\n\n输入样例1：\n```\n10\n3 1 2 8 7 5 9 4 6 0\n1 2 3 7 8 5 9 4 6 0\n```\n输出样例1：\n```\nInsertion Sort\n1 2 3 5 7 8 9 4 6 0\n```\n输入样例2：\n```\n10\n3 1 2 8 7 5 9 4 0 6\n1 3 2 8 5 7 4 9 0 6\n```\n输出样例2：\n```\nMerge Sort\n1 2 3 8 4 5 7 9 0 6\n```\n\n\n## 题目解读\n这是我刷乙级题时比较头疼的一道题，前后查阅了很多别人的代码，后又观看了陈越姥姥的[视频](http://www.icourse163.org/learn/ZJU-93001?tid=1002019005#/learn/content?type=detail&id=1002635050)总算弄明白了这道题需要注意哪些.\n\n1. 如何区分简单插入排序和**非递归**的归并排序;\n2. 如何根据测试用例的类型再迭代一次运算;\n3. 如何处理边界测试.\n\n这里要强调一下本题使用递归的归并排序是**无法AC**的，本渣使用递归的归并排序最多只能得到17分. 关于递归的归并与迭代归并区别请围观[这里](https://en.wikipedia.org/wiki/Merge_sort) (中文版省去了很多分析过程，强烈建议读英文原版)，另外，关于插入排序算法的Wiki在[这里](https://en.wikipedia.org/wiki/Insertion_sort).\n\n## 解题过程\n\n### 如何区分简单插入排序和非递归的归并排序\n只要抓住两个关键点即可：\n1. **使用插入排序序列的开头一部分一定是有序的**;\n2. **无序部分与原文一致**．\n\n比如下面这个例子:\n> 10  \n3 1 2 8 7 `5 9 4 6 0`  \n**1 2 3 7 8** `5 9 4 6 0`\n\n我们可以这样来判断:\n1. 首先扫描 `1 2 3 7 8` 为有序序列，当读取到`5`时发现 `8 > 5`暂停，执行步骤2;\n2. 从`5`开始对后面的序列与原序列进行比较，若发现全部是匹配的，则该序列的排序算法为插入排序,并记录下开始无序的位置;否则为归并排序.\n\n显然后面的部分与原文一致，因此这个序列排序使用的是插入排序. 注意这里必须满足以上***两个***条件才能推出插入排序算法．\n\n这里不得不提到有同学使用从后向前寻找不匹配点的方法来判断排序算法，这个方法是不对的，比如下面这个例子:  \n>3 1 2 8 7 5 9 4 `0 6`  \n1 3 2 8 5 7 4 9 `0 6`  \n\n虽然这里的后面一部分`0　6`与原题一致，但它并不满足前置子序列有序，因此它不是插入排序，后面的测试用例就有一个测试点来卡这种情况。\n\n对于如何判断是否使用归并排序则相对麻烦，考虑到题目中明确指出测试用例是合法的并且只能是归并和插入排序两种之一，所以这里使用排除法来确定归并排序．\n\n### 如何根据测试用例的类型再迭代一次运算\n#### 对于插入排序\n这个就非常简单了，如果明白了插入排序的算法，直接从上面记录下的点进行再迭代一次即可。\n\n#### 对于归并排序\n这个相对要麻烦一些，其关键步骤是确定归并段的长度。有的同学想到像插入排序一样从头开始寻找最长有序子序列，这是不对的，因为题意中归并排序是迭代一轮后才得到题目序列，即题目序列被分为若干归并段，**每一小段都是有序的**，因此若原文前一段本身已经有序，那么进行归并后得到的序列一定也是整体有序的，那么也就无法通过通过前置子序列的最大有序长度来代表所有归并段的长度。比如下面这个例子:\n\n> 10  \n`2 1 8 3` `7 5` `9 4` `0 6`  \n`1 2 3 8` `5 7` `4 9` `0 6`\n\n显然我们无法从`1 3 2 8`是最长前置有序子列就判断出归并段的长度为`4`。正确答案应该是`2`。\n\n有的同学使用模拟法，即对原序列进行分步归并排序，每迭代一次都与题目序列进行比较，直到发现匹配的情况为止。　这种方法在题目所给的时间限制下也能通过，但本着认真负责的态度，我们应该寻找一种更加**聪明**的办法来确定\n\n通过陈越姥姥的启发，我们总结出一下步骤判断最大归并段的长度：\n1. 假设每个归并段的长度为`l`, (`l`的初始值为`2`，因为一个元素不存在有序无序的概念);\n2. 对所有相邻两个归并段相连的两个元素进行比较，若该两元素仍有序，则归并段的长度`l *= 2`; 否则终止循环，`l`即为要确定的最大归并段长度。\n\n程序实现起来就是通过`for(l=2; l<=N; l*=2)`这个大循环内部完成的。  \n\n当确定了最大归并段长度，余下的工作就变得简单了，直接再迭代归并一次即可。\n具体代码可以参考最后的AC代码。\n### 如何处理边界测试\nPAT的题目测试不给出测试数据以及测试提示，比较考验同学们的程序测试能力，本渣在通过这道题时前后想了很久，也提交了很多次，还是在看了陈越姥姥的讲解后才知道测试数据的提示，测试数据包含一下几类：\n\n1. 最小`N`(`N = 4`，因为只有当`N >= 4`时才能区分出归并排序与插入排序中间子列).\n    * 插入排序第`1`步，什么都没改变;\n    * 归并排序第`1`步，什么都变了;\n2. 尾部子列无变化，但是前面变了(归并).\n3. 最大`N`.\n\n有了如上提示，加上前面的讲解，相信读者一定能够独立AC这道题了。\n\n## AC代码:\n```cpp\n#include <iostream>\n//#include <fstream>\n\nusing std::cin;\nusing std::cout;\nusing std::endl;\n\nint main()\n{\n//    std::ifstream cin(\"in.txt\");\n    int N;\n    cin >> N;\n    int *Orig = new int[N];\n    for(int i=0; i!=N; ++i){\n        cin >> Orig[i];\n    }\n    int *tmp = new int[N];\n    for(int i=0; i!=N; ++i){\n        cin >> tmp[i];\n    }\n    int k(0);\n    for(int i=k; i!=N-1; ++i){\n        if( tmp[i] > tmp[i+1] ){\n            k = i;\n            break;\n        }\n    }\n    bool IsInsertion(true);\n    for(int i=++k; i!=N; ++i){\n        if( tmp[i] != Orig[i] ){\n            IsInsertion = false;\n            break;\n        }\n    }\n    if( IsInsertion ){\n        cout << \"Insertion Sort\" << endl;\n        for(int i=k; i!=0; --i){\n            if( tmp[i] < tmp[i-1] ){\n                int t = tmp[i];\n                tmp[i] = tmp[i-1];\n                tmp[i-1] = t;\n            }else break;\n        }\n        for(int i=0; i!=N-1; ++i){\n            cout << tmp[i] << \" \";\n        }cout << tmp[N-1] << endl;\n    }else{\n        cout << \"Merge Sort\" << endl;\n        bool Identified = false;\n        for(int l=2; l<=N; l*=2){\n            for(int i=l; i<N; i += 2*l){\n                if( tmp[i-1] > tmp[i] ){\n                    Identified = true;\n                    break;\n                }\n            }\n            if( Identified ){\n                k = l;\n                break;\n            }\n        }\n//        cout << \"k = \" << k << endl;\n        for(int i=0; i<N; i+=k*2){\n            int *tmpArr = new int[k*2];\n            int lef = i;\n            const int mid = ( lef+k < N ) ? lef+k : N;\n            const int rig = ( mid+k < N ) ? mid+k : N;\n            int cur = mid;\n            int j=0;\n            while( lef < mid and cur < rig ){\n                if( tmp[lef] < tmp[cur] ){\n                    tmpArr[j++] = tmp[lef++];\n                }else{\n                    tmpArr[j++] = tmp[cur++];\n                }\n            }\n            while( lef < mid ){\n                tmpArr[j++] = tmp[lef++];\n            }\n            while( cur < rig ){\n                tmpArr[j++] = tmp[cur++];\n            }\n            for(int t=0; t!=j; ++t){\n                tmp[i+t] = tmpArr[t];\n            }\n            delete[] tmpArr;\n        }\n        for(int i=0; i!=N-1; ++i){\n            cout << tmp[i] << \" \";\n        }cout << tmp[N-1] << endl;\n    }\n    return 0;\n}\n\n```\n","slug":"PAT题解-B-1035","published":1,"updated":"2017-09-19T14:07:58.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj7rorijn0006tcjmg9y4nzmw","content":"<h1 id=\"题解-PAT-B-1035-插入与归并\"><a href=\"#题解-PAT-B-1035-插入与归并\" class=\"headerlink\" title=\"题解:PAT-B 1035 插入与归并\"></a>题解:PAT-B 1035 插入与归并</h1><p>这是一篇测试用文章，欢迎围观.</p>\n<h2 id=\"题目全文：\"><a href=\"#题目全文：\" class=\"headerlink\" title=\"题目全文：\"></a>题目全文：</h2><p>题目地址在<a href=\"https://www.patest.cn/contests/pat-b-practise/1035\" target=\"_blank\" rel=\"external\">这里</a></p>\n<blockquote>\n<p>根据维基百科的定义：</p>\n<p>插入排序是迭代算法，逐一获得输入数据，逐步产生有序的输出序列。每步迭代中，算法从输入序列中取出一元素，将之插入有序序列中正确的位置。如此迭代直到全部元素有序。</p>\n<p>归并排序进行如下迭代操作：首先将原始序列看成N个只包含1个元素的有序子序列，然后每次迭代归并两个相邻的有序子序列，直到最后只剩下1个有序的序列。</p>\n<p>现给定原始序列和由某排序算法产生的中间序列，请你判断该算法究竟是哪种排序算法？</p>\n<p>输入格式：</p>\n<p>输入在第一行给出正整数N (&lt;=100)；随后一行给出原始序列的N个整数；最后一行给出由某排序算法产生的中间序列。这里假设排序的目标序列是升序。数字间以空格分隔。</p>\n<p>输出格式：</p>\n<p>首先在第1行中输出“Insertion Sort”表示插入排序、或“Merge Sort”表示归并排序；然后在第2行中输出用该排序算法再迭代一轮的结果序列。题目保证每组测试的结果是唯一的。数字间以空格分隔，且行末不得有多余空格。</p>\n</blockquote>\n<p>输入样例1：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">10</div><div class=\"line\">3 1 2 8 7 5 9 4 6 0</div><div class=\"line\">1 2 3 7 8 5 9 4 6 0</div></pre></td></tr></table></figure></p>\n<p>输出样例1：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">Insertion Sort</div><div class=\"line\">1 2 3 5 7 8 9 4 6 0</div></pre></td></tr></table></figure></p>\n<p>输入样例2：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">10</div><div class=\"line\">3 1 2 8 7 5 9 4 0 6</div><div class=\"line\">1 3 2 8 5 7 4 9 0 6</div></pre></td></tr></table></figure></p>\n<p>输出样例2：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">Merge Sort</div><div class=\"line\">1 2 3 8 4 5 7 9 0 6</div></pre></td></tr></table></figure></p>\n<h2 id=\"题目解读\"><a href=\"#题目解读\" class=\"headerlink\" title=\"题目解读\"></a>题目解读</h2><p>这是我刷乙级题时比较头疼的一道题，前后查阅了很多别人的代码，后又观看了陈越姥姥的<a href=\"http://www.icourse163.org/learn/ZJU-93001?tid=1002019005#/learn/content?type=detail&amp;id=1002635050\" target=\"_blank\" rel=\"external\">视频</a>总算弄明白了这道题需要注意哪些.</p>\n<ol>\n<li>如何区分简单插入排序和<strong>非递归</strong>的归并排序;</li>\n<li>如何根据测试用例的类型再迭代一次运算;</li>\n<li>如何处理边界测试.</li>\n</ol>\n<p>这里要强调一下本题使用递归的归并排序是<strong>无法AC</strong>的，本渣使用递归的归并排序最多只能得到17分. 关于递归的归并与迭代归并区别请围观<a href=\"https://en.wikipedia.org/wiki/Merge_sort\" target=\"_blank\" rel=\"external\">这里</a> (中文版省去了很多分析过程，强烈建议读英文原版)，另外，关于插入排序算法的Wiki在<a href=\"https://en.wikipedia.org/wiki/Insertion_sort\" target=\"_blank\" rel=\"external\">这里</a>.</p>\n<h2 id=\"解题过程\"><a href=\"#解题过程\" class=\"headerlink\" title=\"解题过程\"></a>解题过程</h2><h3 id=\"如何区分简单插入排序和非递归的归并排序\"><a href=\"#如何区分简单插入排序和非递归的归并排序\" class=\"headerlink\" title=\"如何区分简单插入排序和非递归的归并排序\"></a>如何区分简单插入排序和非递归的归并排序</h3><p>只要抓住两个关键点即可：</p>\n<ol>\n<li><strong>使用插入排序序列的开头一部分一定是有序的</strong>;</li>\n<li><strong>无序部分与原文一致</strong>．</li>\n</ol>\n<p>比如下面这个例子:</p>\n<blockquote>\n<p>10<br>3 1 2 8 7 <code>5 9 4 6 0</code><br><strong>1 2 3 7 8</strong> <code>5 9 4 6 0</code></p>\n</blockquote>\n<p>我们可以这样来判断:</p>\n<ol>\n<li>首先扫描 <code>1 2 3 7 8</code> 为有序序列，当读取到<code>5</code>时发现 <code>8 &gt; 5</code>暂停，执行步骤2;</li>\n<li>从<code>5</code>开始对后面的序列与原序列进行比较，若发现全部是匹配的，则该序列的排序算法为插入排序,并记录下开始无序的位置;否则为归并排序.</li>\n</ol>\n<p>显然后面的部分与原文一致，因此这个序列排序使用的是插入排序. 注意这里必须满足以上<strong><em>两个</em></strong>条件才能推出插入排序算法．</p>\n<p>这里不得不提到有同学使用从后向前寻找不匹配点的方法来判断排序算法，这个方法是不对的，比如下面这个例子:  </p>\n<blockquote>\n<p>3 1 2 8 7 5 9 4 <code>0 6</code><br>1 3 2 8 5 7 4 9 <code>0 6</code>  </p>\n</blockquote>\n<p>虽然这里的后面一部分<code>0　6</code>与原题一致，但它并不满足前置子序列有序，因此它不是插入排序，后面的测试用例就有一个测试点来卡这种情况。</p>\n<p>对于如何判断是否使用归并排序则相对麻烦，考虑到题目中明确指出测试用例是合法的并且只能是归并和插入排序两种之一，所以这里使用排除法来确定归并排序．</p>\n<h3 id=\"如何根据测试用例的类型再迭代一次运算\"><a href=\"#如何根据测试用例的类型再迭代一次运算\" class=\"headerlink\" title=\"如何根据测试用例的类型再迭代一次运算\"></a>如何根据测试用例的类型再迭代一次运算</h3><h4 id=\"对于插入排序\"><a href=\"#对于插入排序\" class=\"headerlink\" title=\"对于插入排序\"></a>对于插入排序</h4><p>这个就非常简单了，如果明白了插入排序的算法，直接从上面记录下的点进行再迭代一次即可。</p>\n<h4 id=\"对于归并排序\"><a href=\"#对于归并排序\" class=\"headerlink\" title=\"对于归并排序\"></a>对于归并排序</h4><p>这个相对要麻烦一些，其关键步骤是确定归并段的长度。有的同学想到像插入排序一样从头开始寻找最长有序子序列，这是不对的，因为题意中归并排序是迭代一轮后才得到题目序列，即题目序列被分为若干归并段，<strong>每一小段都是有序的</strong>，因此若原文前一段本身已经有序，那么进行归并后得到的序列一定也是整体有序的，那么也就无法通过通过前置子序列的最大有序长度来代表所有归并段的长度。比如下面这个例子:</p>\n<blockquote>\n<p>10<br><code>2 1 8 3</code> <code>7 5</code> <code>9 4</code> <code>0 6</code><br><code>1 2 3 8</code> <code>5 7</code> <code>4 9</code> <code>0 6</code></p>\n</blockquote>\n<p>显然我们无法从<code>1 3 2 8</code>是最长前置有序子列就判断出归并段的长度为<code>4</code>。正确答案应该是<code>2</code>。</p>\n<p>有的同学使用模拟法，即对原序列进行分步归并排序，每迭代一次都与题目序列进行比较，直到发现匹配的情况为止。　这种方法在题目所给的时间限制下也能通过，但本着认真负责的态度，我们应该寻找一种更加<strong>聪明</strong>的办法来确定</p>\n<p>通过陈越姥姥的启发，我们总结出一下步骤判断最大归并段的长度：</p>\n<ol>\n<li>假设每个归并段的长度为<code>l</code>, (<code>l</code>的初始值为<code>2</code>，因为一个元素不存在有序无序的概念);</li>\n<li>对所有相邻两个归并段相连的两个元素进行比较，若该两元素仍有序，则归并段的长度<code>l *= 2</code>; 否则终止循环，<code>l</code>即为要确定的最大归并段长度。</li>\n</ol>\n<p>程序实现起来就是通过<code>for(l=2; l&lt;=N; l*=2)</code>这个大循环内部完成的。  </p>\n<p>当确定了最大归并段长度，余下的工作就变得简单了，直接再迭代归并一次即可。<br>具体代码可以参考最后的AC代码。</p>\n<h3 id=\"如何处理边界测试\"><a href=\"#如何处理边界测试\" class=\"headerlink\" title=\"如何处理边界测试\"></a>如何处理边界测试</h3><p>PAT的题目测试不给出测试数据以及测试提示，比较考验同学们的程序测试能力，本渣在通过这道题时前后想了很久，也提交了很多次，还是在看了陈越姥姥的讲解后才知道测试数据的提示，测试数据包含一下几类：</p>\n<ol>\n<li>最小<code>N</code>(<code>N = 4</code>，因为只有当<code>N &gt;= 4</code>时才能区分出归并排序与插入排序中间子列).<ul>\n<li>插入排序第<code>1</code>步，什么都没改变;</li>\n<li>归并排序第<code>1</code>步，什么都变了;</li>\n</ul>\n</li>\n<li>尾部子列无变化，但是前面变了(归并).</li>\n<li>最大<code>N</code>.</li>\n</ol>\n<p>有了如上提示，加上前面的讲解，相信读者一定能够独立AC这道题了。</p>\n<h2 id=\"AC代码\"><a href=\"#AC代码\" class=\"headerlink\" title=\"AC代码:\"></a>AC代码:</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"><span class=\"comment\">//#include &lt;fstream&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">cin</span>;</div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span>;</div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></div><div class=\"line\">&#123;</div><div class=\"line\"><span class=\"comment\">//    std::ifstream cin(\"in.txt\");</span></div><div class=\"line\">    <span class=\"keyword\">int</span> N;</div><div class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; N;</div><div class=\"line\">    <span class=\"keyword\">int</span> *Orig = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[N];</div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i!=N; ++i)&#123;</div><div class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; Orig[i];</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">int</span> *tmp = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[N];</div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i!=N; ++i)&#123;</div><div class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; tmp[i];</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">k</span><span class=\"params\">(<span class=\"number\">0</span>)</span></span>;</div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=k; i!=N<span class=\"number\">-1</span>; ++i)&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span>( tmp[i] &gt; tmp[i+<span class=\"number\">1</span>] )&#123;</div><div class=\"line\">            k = i;</div><div class=\"line\">            <span class=\"keyword\">break</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">IsInsertion</span><span class=\"params\">(<span class=\"literal\">true</span>)</span></span>;</div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=++k; i!=N; ++i)&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span>( tmp[i] != Orig[i] )&#123;</div><div class=\"line\">            IsInsertion = <span class=\"literal\">false</span>;</div><div class=\"line\">            <span class=\"keyword\">break</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span>( IsInsertion )&#123;</div><div class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Insertion Sort\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</div><div class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=k; i!=<span class=\"number\">0</span>; --i)&#123;</div><div class=\"line\">            <span class=\"keyword\">if</span>( tmp[i] &lt; tmp[i<span class=\"number\">-1</span>] )&#123;</div><div class=\"line\">                <span class=\"keyword\">int</span> t = tmp[i];</div><div class=\"line\">                tmp[i] = tmp[i<span class=\"number\">-1</span>];</div><div class=\"line\">                tmp[i<span class=\"number\">-1</span>] = t;</div><div class=\"line\">            &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">break</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i!=N<span class=\"number\">-1</span>; ++i)&#123;</div><div class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; tmp[i] &lt;&lt; <span class=\"string\">\" \"</span>;</div><div class=\"line\">        &#125;<span class=\"built_in\">cout</span> &lt;&lt; tmp[N<span class=\"number\">-1</span>] &lt;&lt; <span class=\"built_in\">endl</span>;</div><div class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</div><div class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Merge Sort\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</div><div class=\"line\">        <span class=\"keyword\">bool</span> Identified = <span class=\"literal\">false</span>;</div><div class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> l=<span class=\"number\">2</span>; l&lt;=N; l*=<span class=\"number\">2</span>)&#123;</div><div class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=l; i&lt;N; i += <span class=\"number\">2</span>*l)&#123;</div><div class=\"line\">                <span class=\"keyword\">if</span>( tmp[i<span class=\"number\">-1</span>] &gt; tmp[i] )&#123;</div><div class=\"line\">                    Identified = <span class=\"literal\">true</span>;</div><div class=\"line\">                    <span class=\"keyword\">break</span>;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"keyword\">if</span>( Identified )&#123;</div><div class=\"line\">                k = l;</div><div class=\"line\">                <span class=\"keyword\">break</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"><span class=\"comment\">//        cout &lt;&lt; \"k = \" &lt;&lt; k &lt;&lt; endl;</span></div><div class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;N; i+=k*<span class=\"number\">2</span>)&#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> *tmpArr = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[k*<span class=\"number\">2</span>];</div><div class=\"line\">            <span class=\"keyword\">int</span> lef = i;</div><div class=\"line\">            <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> mid = ( lef+k &lt; N ) ? lef+k : N;</div><div class=\"line\">            <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> rig = ( mid+k &lt; N ) ? mid+k : N;</div><div class=\"line\">            <span class=\"keyword\">int</span> cur = mid;</div><div class=\"line\">            <span class=\"keyword\">int</span> j=<span class=\"number\">0</span>;</div><div class=\"line\">            <span class=\"keyword\">while</span>( lef &lt; mid <span class=\"keyword\">and</span> cur &lt; rig )&#123;</div><div class=\"line\">                <span class=\"keyword\">if</span>( tmp[lef] &lt; tmp[cur] )&#123;</div><div class=\"line\">                    tmpArr[j++] = tmp[lef++];</div><div class=\"line\">                &#125;<span class=\"keyword\">else</span>&#123;</div><div class=\"line\">                    tmpArr[j++] = tmp[cur++];</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"keyword\">while</span>( lef &lt; mid )&#123;</div><div class=\"line\">                tmpArr[j++] = tmp[lef++];</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"keyword\">while</span>( cur &lt; rig )&#123;</div><div class=\"line\">                tmpArr[j++] = tmp[cur++];</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> t=<span class=\"number\">0</span>; t!=j; ++t)&#123;</div><div class=\"line\">                tmp[i+t] = tmpArr[t];</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"keyword\">delete</span>[] tmpArr;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i!=N<span class=\"number\">-1</span>; ++i)&#123;</div><div class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; tmp[i] &lt;&lt; <span class=\"string\">\" \"</span>;</div><div class=\"line\">        &#125;<span class=\"built_in\">cout</span> &lt;&lt; tmp[N<span class=\"number\">-1</span>] &lt;&lt; <span class=\"built_in\">endl</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"题解-PAT-B-1035-插入与归并\"><a href=\"#题解-PAT-B-1035-插入与归并\" class=\"headerlink\" title=\"题解:PAT-B 1035 插入与归并\"></a>题解:PAT-B 1035 插入与归并</h1><p>这是一篇测试用文章，欢迎围观.</p>\n<h2 id=\"题目全文：\"><a href=\"#题目全文：\" class=\"headerlink\" title=\"题目全文：\"></a>题目全文：</h2><p>题目地址在<a href=\"https://www.patest.cn/contests/pat-b-practise/1035\" target=\"_blank\" rel=\"external\">这里</a></p>\n<blockquote>\n<p>根据维基百科的定义：</p>\n<p>插入排序是迭代算法，逐一获得输入数据，逐步产生有序的输出序列。每步迭代中，算法从输入序列中取出一元素，将之插入有序序列中正确的位置。如此迭代直到全部元素有序。</p>\n<p>归并排序进行如下迭代操作：首先将原始序列看成N个只包含1个元素的有序子序列，然后每次迭代归并两个相邻的有序子序列，直到最后只剩下1个有序的序列。</p>\n<p>现给定原始序列和由某排序算法产生的中间序列，请你判断该算法究竟是哪种排序算法？</p>\n<p>输入格式：</p>\n<p>输入在第一行给出正整数N (&lt;=100)；随后一行给出原始序列的N个整数；最后一行给出由某排序算法产生的中间序列。这里假设排序的目标序列是升序。数字间以空格分隔。</p>\n<p>输出格式：</p>\n<p>首先在第1行中输出“Insertion Sort”表示插入排序、或“Merge Sort”表示归并排序；然后在第2行中输出用该排序算法再迭代一轮的结果序列。题目保证每组测试的结果是唯一的。数字间以空格分隔，且行末不得有多余空格。</p>\n</blockquote>\n<p>输入样例1：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">10</div><div class=\"line\">3 1 2 8 7 5 9 4 6 0</div><div class=\"line\">1 2 3 7 8 5 9 4 6 0</div></pre></td></tr></table></figure></p>\n<p>输出样例1：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">Insertion Sort</div><div class=\"line\">1 2 3 5 7 8 9 4 6 0</div></pre></td></tr></table></figure></p>\n<p>输入样例2：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">10</div><div class=\"line\">3 1 2 8 7 5 9 4 0 6</div><div class=\"line\">1 3 2 8 5 7 4 9 0 6</div></pre></td></tr></table></figure></p>\n<p>输出样例2：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">Merge Sort</div><div class=\"line\">1 2 3 8 4 5 7 9 0 6</div></pre></td></tr></table></figure></p>\n<h2 id=\"题目解读\"><a href=\"#题目解读\" class=\"headerlink\" title=\"题目解读\"></a>题目解读</h2><p>这是我刷乙级题时比较头疼的一道题，前后查阅了很多别人的代码，后又观看了陈越姥姥的<a href=\"http://www.icourse163.org/learn/ZJU-93001?tid=1002019005#/learn/content?type=detail&amp;id=1002635050\" target=\"_blank\" rel=\"external\">视频</a>总算弄明白了这道题需要注意哪些.</p>\n<ol>\n<li>如何区分简单插入排序和<strong>非递归</strong>的归并排序;</li>\n<li>如何根据测试用例的类型再迭代一次运算;</li>\n<li>如何处理边界测试.</li>\n</ol>\n<p>这里要强调一下本题使用递归的归并排序是<strong>无法AC</strong>的，本渣使用递归的归并排序最多只能得到17分. 关于递归的归并与迭代归并区别请围观<a href=\"https://en.wikipedia.org/wiki/Merge_sort\" target=\"_blank\" rel=\"external\">这里</a> (中文版省去了很多分析过程，强烈建议读英文原版)，另外，关于插入排序算法的Wiki在<a href=\"https://en.wikipedia.org/wiki/Insertion_sort\" target=\"_blank\" rel=\"external\">这里</a>.</p>\n<h2 id=\"解题过程\"><a href=\"#解题过程\" class=\"headerlink\" title=\"解题过程\"></a>解题过程</h2><h3 id=\"如何区分简单插入排序和非递归的归并排序\"><a href=\"#如何区分简单插入排序和非递归的归并排序\" class=\"headerlink\" title=\"如何区分简单插入排序和非递归的归并排序\"></a>如何区分简单插入排序和非递归的归并排序</h3><p>只要抓住两个关键点即可：</p>\n<ol>\n<li><strong>使用插入排序序列的开头一部分一定是有序的</strong>;</li>\n<li><strong>无序部分与原文一致</strong>．</li>\n</ol>\n<p>比如下面这个例子:</p>\n<blockquote>\n<p>10<br>3 1 2 8 7 <code>5 9 4 6 0</code><br><strong>1 2 3 7 8</strong> <code>5 9 4 6 0</code></p>\n</blockquote>\n<p>我们可以这样来判断:</p>\n<ol>\n<li>首先扫描 <code>1 2 3 7 8</code> 为有序序列，当读取到<code>5</code>时发现 <code>8 &gt; 5</code>暂停，执行步骤2;</li>\n<li>从<code>5</code>开始对后面的序列与原序列进行比较，若发现全部是匹配的，则该序列的排序算法为插入排序,并记录下开始无序的位置;否则为归并排序.</li>\n</ol>\n<p>显然后面的部分与原文一致，因此这个序列排序使用的是插入排序. 注意这里必须满足以上<strong><em>两个</em></strong>条件才能推出插入排序算法．</p>\n<p>这里不得不提到有同学使用从后向前寻找不匹配点的方法来判断排序算法，这个方法是不对的，比如下面这个例子:  </p>\n<blockquote>\n<p>3 1 2 8 7 5 9 4 <code>0 6</code><br>1 3 2 8 5 7 4 9 <code>0 6</code>  </p>\n</blockquote>\n<p>虽然这里的后面一部分<code>0　6</code>与原题一致，但它并不满足前置子序列有序，因此它不是插入排序，后面的测试用例就有一个测试点来卡这种情况。</p>\n<p>对于如何判断是否使用归并排序则相对麻烦，考虑到题目中明确指出测试用例是合法的并且只能是归并和插入排序两种之一，所以这里使用排除法来确定归并排序．</p>\n<h3 id=\"如何根据测试用例的类型再迭代一次运算\"><a href=\"#如何根据测试用例的类型再迭代一次运算\" class=\"headerlink\" title=\"如何根据测试用例的类型再迭代一次运算\"></a>如何根据测试用例的类型再迭代一次运算</h3><h4 id=\"对于插入排序\"><a href=\"#对于插入排序\" class=\"headerlink\" title=\"对于插入排序\"></a>对于插入排序</h4><p>这个就非常简单了，如果明白了插入排序的算法，直接从上面记录下的点进行再迭代一次即可。</p>\n<h4 id=\"对于归并排序\"><a href=\"#对于归并排序\" class=\"headerlink\" title=\"对于归并排序\"></a>对于归并排序</h4><p>这个相对要麻烦一些，其关键步骤是确定归并段的长度。有的同学想到像插入排序一样从头开始寻找最长有序子序列，这是不对的，因为题意中归并排序是迭代一轮后才得到题目序列，即题目序列被分为若干归并段，<strong>每一小段都是有序的</strong>，因此若原文前一段本身已经有序，那么进行归并后得到的序列一定也是整体有序的，那么也就无法通过通过前置子序列的最大有序长度来代表所有归并段的长度。比如下面这个例子:</p>\n<blockquote>\n<p>10<br><code>2 1 8 3</code> <code>7 5</code> <code>9 4</code> <code>0 6</code><br><code>1 2 3 8</code> <code>5 7</code> <code>4 9</code> <code>0 6</code></p>\n</blockquote>\n<p>显然我们无法从<code>1 3 2 8</code>是最长前置有序子列就判断出归并段的长度为<code>4</code>。正确答案应该是<code>2</code>。</p>\n<p>有的同学使用模拟法，即对原序列进行分步归并排序，每迭代一次都与题目序列进行比较，直到发现匹配的情况为止。　这种方法在题目所给的时间限制下也能通过，但本着认真负责的态度，我们应该寻找一种更加<strong>聪明</strong>的办法来确定</p>\n<p>通过陈越姥姥的启发，我们总结出一下步骤判断最大归并段的长度：</p>\n<ol>\n<li>假设每个归并段的长度为<code>l</code>, (<code>l</code>的初始值为<code>2</code>，因为一个元素不存在有序无序的概念);</li>\n<li>对所有相邻两个归并段相连的两个元素进行比较，若该两元素仍有序，则归并段的长度<code>l *= 2</code>; 否则终止循环，<code>l</code>即为要确定的最大归并段长度。</li>\n</ol>\n<p>程序实现起来就是通过<code>for(l=2; l&lt;=N; l*=2)</code>这个大循环内部完成的。  </p>\n<p>当确定了最大归并段长度，余下的工作就变得简单了，直接再迭代归并一次即可。<br>具体代码可以参考最后的AC代码。</p>\n<h3 id=\"如何处理边界测试\"><a href=\"#如何处理边界测试\" class=\"headerlink\" title=\"如何处理边界测试\"></a>如何处理边界测试</h3><p>PAT的题目测试不给出测试数据以及测试提示，比较考验同学们的程序测试能力，本渣在通过这道题时前后想了很久，也提交了很多次，还是在看了陈越姥姥的讲解后才知道测试数据的提示，测试数据包含一下几类：</p>\n<ol>\n<li>最小<code>N</code>(<code>N = 4</code>，因为只有当<code>N &gt;= 4</code>时才能区分出归并排序与插入排序中间子列).<ul>\n<li>插入排序第<code>1</code>步，什么都没改变;</li>\n<li>归并排序第<code>1</code>步，什么都变了;</li>\n</ul>\n</li>\n<li>尾部子列无变化，但是前面变了(归并).</li>\n<li>最大<code>N</code>.</li>\n</ol>\n<p>有了如上提示，加上前面的讲解，相信读者一定能够独立AC这道题了。</p>\n<h2 id=\"AC代码\"><a href=\"#AC代码\" class=\"headerlink\" title=\"AC代码:\"></a>AC代码:</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"><span class=\"comment\">//#include &lt;fstream&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">cin</span>;</div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span>;</div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></div><div class=\"line\">&#123;</div><div class=\"line\"><span class=\"comment\">//    std::ifstream cin(\"in.txt\");</span></div><div class=\"line\">    <span class=\"keyword\">int</span> N;</div><div class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; N;</div><div class=\"line\">    <span class=\"keyword\">int</span> *Orig = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[N];</div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i!=N; ++i)&#123;</div><div class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; Orig[i];</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">int</span> *tmp = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[N];</div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i!=N; ++i)&#123;</div><div class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; tmp[i];</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">k</span><span class=\"params\">(<span class=\"number\">0</span>)</span></span>;</div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=k; i!=N<span class=\"number\">-1</span>; ++i)&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span>( tmp[i] &gt; tmp[i+<span class=\"number\">1</span>] )&#123;</div><div class=\"line\">            k = i;</div><div class=\"line\">            <span class=\"keyword\">break</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">IsInsertion</span><span class=\"params\">(<span class=\"literal\">true</span>)</span></span>;</div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=++k; i!=N; ++i)&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span>( tmp[i] != Orig[i] )&#123;</div><div class=\"line\">            IsInsertion = <span class=\"literal\">false</span>;</div><div class=\"line\">            <span class=\"keyword\">break</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span>( IsInsertion )&#123;</div><div class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Insertion Sort\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</div><div class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=k; i!=<span class=\"number\">0</span>; --i)&#123;</div><div class=\"line\">            <span class=\"keyword\">if</span>( tmp[i] &lt; tmp[i<span class=\"number\">-1</span>] )&#123;</div><div class=\"line\">                <span class=\"keyword\">int</span> t = tmp[i];</div><div class=\"line\">                tmp[i] = tmp[i<span class=\"number\">-1</span>];</div><div class=\"line\">                tmp[i<span class=\"number\">-1</span>] = t;</div><div class=\"line\">            &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">break</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i!=N<span class=\"number\">-1</span>; ++i)&#123;</div><div class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; tmp[i] &lt;&lt; <span class=\"string\">\" \"</span>;</div><div class=\"line\">        &#125;<span class=\"built_in\">cout</span> &lt;&lt; tmp[N<span class=\"number\">-1</span>] &lt;&lt; <span class=\"built_in\">endl</span>;</div><div class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</div><div class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Merge Sort\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</div><div class=\"line\">        <span class=\"keyword\">bool</span> Identified = <span class=\"literal\">false</span>;</div><div class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> l=<span class=\"number\">2</span>; l&lt;=N; l*=<span class=\"number\">2</span>)&#123;</div><div class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=l; i&lt;N; i += <span class=\"number\">2</span>*l)&#123;</div><div class=\"line\">                <span class=\"keyword\">if</span>( tmp[i<span class=\"number\">-1</span>] &gt; tmp[i] )&#123;</div><div class=\"line\">                    Identified = <span class=\"literal\">true</span>;</div><div class=\"line\">                    <span class=\"keyword\">break</span>;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"keyword\">if</span>( Identified )&#123;</div><div class=\"line\">                k = l;</div><div class=\"line\">                <span class=\"keyword\">break</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"><span class=\"comment\">//        cout &lt;&lt; \"k = \" &lt;&lt; k &lt;&lt; endl;</span></div><div class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;N; i+=k*<span class=\"number\">2</span>)&#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> *tmpArr = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[k*<span class=\"number\">2</span>];</div><div class=\"line\">            <span class=\"keyword\">int</span> lef = i;</div><div class=\"line\">            <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> mid = ( lef+k &lt; N ) ? lef+k : N;</div><div class=\"line\">            <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> rig = ( mid+k &lt; N ) ? mid+k : N;</div><div class=\"line\">            <span class=\"keyword\">int</span> cur = mid;</div><div class=\"line\">            <span class=\"keyword\">int</span> j=<span class=\"number\">0</span>;</div><div class=\"line\">            <span class=\"keyword\">while</span>( lef &lt; mid <span class=\"keyword\">and</span> cur &lt; rig )&#123;</div><div class=\"line\">                <span class=\"keyword\">if</span>( tmp[lef] &lt; tmp[cur] )&#123;</div><div class=\"line\">                    tmpArr[j++] = tmp[lef++];</div><div class=\"line\">                &#125;<span class=\"keyword\">else</span>&#123;</div><div class=\"line\">                    tmpArr[j++] = tmp[cur++];</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"keyword\">while</span>( lef &lt; mid )&#123;</div><div class=\"line\">                tmpArr[j++] = tmp[lef++];</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"keyword\">while</span>( cur &lt; rig )&#123;</div><div class=\"line\">                tmpArr[j++] = tmp[cur++];</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> t=<span class=\"number\">0</span>; t!=j; ++t)&#123;</div><div class=\"line\">                tmp[i+t] = tmpArr[t];</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"keyword\">delete</span>[] tmpArr;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i!=N<span class=\"number\">-1</span>; ++i)&#123;</div><div class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; tmp[i] &lt;&lt; <span class=\"string\">\" \"</span>;</div><div class=\"line\">        &#125;<span class=\"built_in\">cout</span> &lt;&lt; tmp[N<span class=\"number\">-1</span>] &lt;&lt; <span class=\"built_in\">endl</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n"},{"title":"量子力学学习手记（一）","date":"2017-06-30T13:28:24.000Z","_content":"\n# 简介\n1. 这篇手记仅为自己学习记录而写。\n2. 虽然题目提到量子力学，但内容与量子力学关系不大，事实是这篇文章提到的某些概念以及方法在以后学习中十分普遍，因此有必要将其归为量子力学学习手记。\n3. 就当这是在打数学基础好了。\n\n# 符号说明\n\n| 符号                                 | 说明，以下符号表示的量是在 *复数范围* 内讨论的                |\n| ---------------------------------- | ---------------------------------------- |\n| $\\mid i\\rangle$                    | ket，也称列向量                                |\n| $\\langle i\\mid$                    | bra，也称行向量                                |\n| $\\langle i\\mid  j \\rangle $        | inner product，求向量$\\langle i\\mid $与向量$\\mid j\\rangle$的内积 |\n| $\\mid  i \\rangle \\langle j \\mid  $ | outer product，求向量$\\mid i\\rangle$与向量$\\langle j\\mid $的外积 |\n| $\\mid i\\rangle ^\\dagger$           | transpose conjugate，共轭转置，即向量每个元素取共轭复数后整体转置，$\\mid i\\rangle ^\\dagger = \\langle i^*\\mid $ |\n| $\\Omega$, $\\Lambda$                | 算子，或称算符，由函数组成的矩阵                         |\n| $\\Omega^\\dagger$                   | 对 $\\Omega$ 取共轭转置                         |\n\n# 题目重现\n\n如图，两个振子组成一维耦合振子，两质点的质量均为$m$，所有弹簧劲度系数均为$k$，以右为正方向，两者位移分别为$x_1$、$x_2$。若两振子初始速度均为零，设两个振子在各自平衡位置时的位移为０，且初始位置未知，求这两个振子的位移-时间函数即$x_i(t)$。\n\n![耦合振子示意图](fig.svg)\n\n# 题解\n\n​\t对两个振子分别分析，不妨设左边振子为1号，右边振子为2号。\n\n​\t对1号振子做受力分析：\n\n$$\nm \\frac{\\mathrm{d}^2 x_1}{\\mathrm{d}t^2} = k(x_2 - x_1) - k{x_1}\n$$\n​\t即\n\n$$\nm\\ddot{x_1} = -2kx_1+kx_2 \\notag\n$$\n\n​\t同理，2号振子满足\n$$\nm\\ddot{x_2} = k{x_1} - 2kx_2  \\notag\n$$\n​\t问题化简为求微分方程组\n$$\n\\begin{cases}\n\t\\ddot{x_1} = -\\frac{2k}{m}x_1 + \\frac{k}{m}x_2\\\\\\\\\n\t\\ddot{x_2} = \\frac{k}{m}x_1 - \\frac{2k}{m}x_2\n\\end{cases}\n$$\n​\t的解，写成矩阵形式即为\n$$\n\\begin{bmatrix}\n\t\\ddot{x_1}\\\\\\\\\n\t\\ddot{x_2}\n\\end{bmatrix} = \\begin{bmatrix}\n\t\\frac{-2k}{m} & \\frac{k}{m}\\\\\\\\\n\t\\frac{k}{m} & \\frac{-2k}{m}\n\\end{bmatrix} \\begin{bmatrix}\n\tx_1\\\\\\\\\n\tx_2\n\\end{bmatrix}\n$$\n​\t现令$\\Omega=\\begin{bmatrix} \\frac{-2k}{m} & \\frac{k}{m}\\\\\\\\  \\frac{k}{m} & \\frac{-2k}{m} \\end{bmatrix} $\n\n​\t观察到 $\\Omega$ 为Hermitian矩阵（$\\Omega^\\dagger = \\Omega$，共轭转置后不变），\n\n​\t故设$\\mid\\mathrm{I}\\rangle $和$\\mid\\mathrm{II}\\rangle $分别为$\\Omega$的两个本征矢（也叫特征向量）\n\n​\t有\n$$\n\\begin{cases}\n\t\\Omega \\mid \\mathrm{I} \\rangle = -\\omega_\\mathrm{I}^2 \\mid \\mathrm{I}\\rangle\\\\\\\\\n\t\\Omega \\mid \\mathrm{II} \\rangle = -\\omega_\\mathrm{II}^2 \\mid \\mathrm{II}\\rangle\n\\end{cases}\n$$\n​\t这里$-\\omega_\\mathrm{I}^2$与$-\\omega_\\mathrm{II}^2$分别表示$\\Omega$的两个本征值，因计算结果表示方便，这里用$-\\omega_i^2$表示，而不是$\\omega_i$。\n\n​\t求出$-\\omega_\\mathrm{I}^2$与$-\\omega_\\mathrm{II}^2$分别为$\\frac{k}{m} \\mp \\frac{2k}{m}$。不妨设$-\\omega_\\mathrm{I}^2＝-\\frac{k}{m}$，$-\\omega_\\mathrm{II}^2＝-\\frac{3k}{m}$。\n\n​\t已知本征值，可以求出本征矢为\n$$\n\\begin{cases}\n\t\\mid \\mathrm{I}\\rangle = \\frac{1}{\\sqrt{2}} \\begin{bmatrix} 1 \\\\\\\\ 1 \\end{bmatrix} & \\omega_\\mathrm{I}=\\sqrt{\\frac{k}{m}} \\\\\\\\\n\t\\mid \\mathrm{II} \\rangle = \\frac{1}{\\sqrt{2}} \\begin{bmatrix} 1 \\\\\\\\-1 \\end{bmatrix}  & \\omega_\\mathrm{II}=\\sqrt{\\frac{3k}{m}}\n \\end{cases}\n$$\n\n​\t可以看出$\\mid \\mathrm{I} \\rangle$与$\\mid \\mathrm{II}\\rangle$相互正交（内积为０）。\n\n​\t因此$x(t)= \\mid \\mathrm{I}\\rangle x_1(t) +\\mid \\mathrm{II}\\rangle x_2(t)$。\n\n​\t到这里，上面的步骤相当于对空间基矢进行了变换，原先的基矢为\n$x_1(t)$对应$\\mid 1 \\rangle = \\begin{bmatrix} 1 \\\\\\\\ 0 \\end{bmatrix}$，$x_2(t)$对应$\\mid 2 \\rangle = \\begin{bmatrix} 0 \\\\\\\\ 1 \\end{bmatrix}$，现变换为$x_\\mathrm{I}$对应$\\mid \\mathrm{I} \\rangle =\\frac{1}{\\sqrt{2}} \\begin{bmatrix} 1 \\\\\\\\ 1 \\end{bmatrix}$，$x_\\mathrm{II}$对应$\\mid \\mathrm{II} \\rangle =\\frac{1}{\\sqrt{2}} \\begin{bmatrix} 1 \\\\\\\\ -1 \\end{bmatrix}$。这样做有什么好处呢？好处马上就会呈现。\n\n​\t此时$\\Omega$可以对角化为\n$$\n\\Omega = \n\\begin{bmatrix}\n\t-\\omega_\\mathrm{I}^2 & 0 \\\\\\\\\n\t0 & -\\omega_\\mathrm{II}^2\n\\end{bmatrix}\n$$\n\n​\t故原方程式可以化为\n\n$$\n\\begin{bmatrix}\n\t\\ddot{x_\\mathrm{I}} \\\\\\\\\n\t\\ddot{x_\\mathrm{II}}\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n\t-\\omega_\\mathrm{I}^2 & 0 \\\\\\\\\n\t0 & -\\omega_\\mathrm{II}^2\n\\end{bmatrix}\n\\begin{bmatrix}\n\tx_\\mathrm{I} \\\\\\\\\n\tx_\\mathrm{II}\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n\t-\\omega_\\mathrm{I}^2 x_\\mathrm{I} \\\\\\\\\n\t-\\omega_\\mathrm{II}^2 x_\\mathrm{II}\n\\end{bmatrix}\n$$\n\n​\t此时分别解$\\ddot{x_\\mathrm{I}}$与$\\ddot{x_\\mathrm{II}}$（两个二阶线性微分方程$\\ddot{x_i} + \\omega_i^2 x_i = 0$，并且$\\dot{x_i}$=0），即可得到$x_i (t),\\quad i=\\mathrm{I,II}$的解，解为\n$$\nx_i(t) = x_i(0) \\cos\\omega_i t, \\quad i=\\mathrm{I,II}\n$$\n\n​\t此时我们离胜利已经很近了——已经得到\t\n$$\n\\begin{aligned}\n\t\\mid x(t) \\rangle & = \\mid \\mathrm{I} \\rangle x_\\mathrm{I}(0)\\cos\\omega_\\mathrm{I}t + \\mid \\mathrm{II} \\rangle x_\\mathrm{II}(0)\\cos\\omega_\\mathrm{II}t \\\\\\\\\n\t& = \\mid \\mathrm{I}\\rangle\\langle\\mathrm{I}\\mid x(0)\\rangle \\cos\\omega_\\mathrm{I}t + \\mid \\mathrm{II}\\rangle\\langle\\mathrm{II}\\mid x(0)\\rangle \\cos\\omega_\\mathrm{II}t \n\\end{aligned}\n$$\n\n​\t式中\n$$\n\\begin{aligned}\n\t\\langle \\mathrm{I} \\mid x(0) \\rangle &= \\frac{1}{\\sqrt{2}} \\begin{bmatrix} 1 & 1 \\end{bmatrix} \\begin{bmatrix} x_1(0) \\\\\\\\ x_2(0) \\end{bmatrix} = \\frac{x_1(0)+x_2(0)}{\\sqrt{2}} \\\\\\\\\n\t\\langle \\mathrm{II} \\mid x(0) \\rangle &= \\frac{1}{\\sqrt{2}} \\begin{bmatrix} 1& -1 \\end{bmatrix} \\begin{bmatrix} x_1(0) \\\\\\\\ x_2(0) \\end{bmatrix} = \\frac{x_1(0) - x_2(0)}{\\sqrt{2}}\n\\end{aligned}\n$$\n\n​\t$\\therefore \\mid x(t)\\rangle = \\mid \\mathrm{I}\\rangle \\frac{x_1(0)+x_2(0)}{\\sqrt{2}} + \\mid \\mathrm{II}\\rangle \\frac{x_1(0) - x_2(0)}{\\sqrt{2}}$\n\n​\t我们需要将$\\mid \\mathrm{I}\\rangle$和$\\mid \\mathrm{II}\\rangle$还原为$\\mid 1\\rangle$和$\\mid 2\\rangle$，这个操作可以通过投影 `projection` 来实现：\n$$\n\\begin{aligned}\n\tx_1(t) =& \\langle 1 \\mid x(t)\\rangle \\\\\\\\\n\t\t=& \\langle 1 \\mid \\mathrm{I}\\rangle \\frac{x_1(0) + x_2(0)}{\\sqrt{2}}\\cos\\omega_\\mathrm{I}t + \\langle 1 \\mid \\mathrm{II}\\rangle \\frac{x_1(0) - x_2(0)}{\\sqrt{2}}\\cos\\omega_\\mathrm{II}t \\\\\\\\\n\t\t=& \\frac{x_1(0) + x_2(0)}{2}\\cos\\left(\\sqrt{\\frac{k}{m}}t\\right) + \\frac{x_1(0) - x_2(0)}{2}\\cos\\left(\\sqrt{\\frac{3k}{m}}t\\right)\n\\end{aligned}\n$$\n​\t同理\n$$\nx_2(t)= \\frac{x_1(0) + x_2(0)}{2}\\cos\\left(\\sqrt{\\frac{k}{m}}t\\right) - \\frac{x_1(0) - x_2(0)}{2}\\cos\\left(\\sqrt{\\frac{3k}{m}}t\\right)\n$$\n​\t写成矩阵形式即为\n$$\n\\begin{bmatrix} x_1(t) \\\\\\\\ x_2(t)  \\end{bmatrix}\n=\n\\begin{bmatrix}\n\t\\frac{\\cos\\left(\\sqrt{\\frac{k}{m}}t\\right) + \\cos\\left(\\sqrt{\\frac{3k}{m}}t\\right) }{2} & \\frac{\\cos\\left(\\sqrt{\\frac{k}{m}}t\\right) - \\cos\\left(\\sqrt{\\frac{3k}{m}}t\\right) }{2} \\\\\\\\\n\t\\frac{\\cos\\left(\\sqrt{\\frac{k}{m}}t\\right) - \\cos\\left(\\sqrt{\\frac{3k}{m}}t\\right) }{2} & \\frac{\\cos\\left(\\sqrt{\\frac{k}{m}}t\\right) + \\cos\\left(\\sqrt{\\frac{3k}{m}}t\\right) }{2}\n\\end{bmatrix}\n\\begin{bmatrix} x_1(0) \\\\\\\\ x_2(0) \\end{bmatrix}\n$$\n​\t此时，只要给出$\\mid x(0)\\rangle$即可得到整个耦合振子系统的运动方程。结束战斗。\n\n\n\n# 收获总结\n\n​\t在Shankar上看到这道题的题解时，起初是不怎么明白的，直到在写这篇手记的过程中，我才体会到这样解的用意：\n\n1. 这是一个耦合系统，即两个微分方程分别含有对方的变量。\n2. 求出$\\mid \\mathrm{I}\\rangle$与$\\mid \\mathrm{II}\\rangle$的过程就是在对原有的线性空间基矢（或称基底）做变换，变换的目的是为了将微分方程组转化为非耦合的方程组。这里，个人以为，说的通俗一些，就是换元——在高等数学的某些求解不定积分时也会用到这种方法。\n3. 求算子$\\Omega$的本征值就是为了将其对角化（对角化后只有对角线上元素不为零），做矩阵乘法运算就可以得到非耦合的方程组，然后问题就变成了熟悉的二阶线性微分方程，之后求解需要用到欧拉公式，这里不赘述。\n4. 用矩阵表示大块方程组真的很方便！\n5. Ti$k$Z很好用！\n\n虽然说上面的题解基本是翻译过来的，但也是有一些收获的，权当 `拾人牙慧吧` 。","source":"_posts/Quantum-Physics-Learning-Log-1.md","raw":"---\ntitle: 量子力学学习手记（一）\ndate: 2017-06-30 21:28:24\ntags:\n   - 量子力学\n   - 线性代数\n   - 数学基础\ncategories: Quantum Mechanics\n---\n\n# 简介\n1. 这篇手记仅为自己学习记录而写。\n2. 虽然题目提到量子力学，但内容与量子力学关系不大，事实是这篇文章提到的某些概念以及方法在以后学习中十分普遍，因此有必要将其归为量子力学学习手记。\n3. 就当这是在打数学基础好了。\n\n# 符号说明\n\n| 符号                                 | 说明，以下符号表示的量是在 *复数范围* 内讨论的                |\n| ---------------------------------- | ---------------------------------------- |\n| $\\mid i\\rangle$                    | ket，也称列向量                                |\n| $\\langle i\\mid$                    | bra，也称行向量                                |\n| $\\langle i\\mid  j \\rangle $        | inner product，求向量$\\langle i\\mid $与向量$\\mid j\\rangle$的内积 |\n| $\\mid  i \\rangle \\langle j \\mid  $ | outer product，求向量$\\mid i\\rangle$与向量$\\langle j\\mid $的外积 |\n| $\\mid i\\rangle ^\\dagger$           | transpose conjugate，共轭转置，即向量每个元素取共轭复数后整体转置，$\\mid i\\rangle ^\\dagger = \\langle i^*\\mid $ |\n| $\\Omega$, $\\Lambda$                | 算子，或称算符，由函数组成的矩阵                         |\n| $\\Omega^\\dagger$                   | 对 $\\Omega$ 取共轭转置                         |\n\n# 题目重现\n\n如图，两个振子组成一维耦合振子，两质点的质量均为$m$，所有弹簧劲度系数均为$k$，以右为正方向，两者位移分别为$x_1$、$x_2$。若两振子初始速度均为零，设两个振子在各自平衡位置时的位移为０，且初始位置未知，求这两个振子的位移-时间函数即$x_i(t)$。\n\n![耦合振子示意图](fig.svg)\n\n# 题解\n\n​\t对两个振子分别分析，不妨设左边振子为1号，右边振子为2号。\n\n​\t对1号振子做受力分析：\n\n$$\nm \\frac{\\mathrm{d}^2 x_1}{\\mathrm{d}t^2} = k(x_2 - x_1) - k{x_1}\n$$\n​\t即\n\n$$\nm\\ddot{x_1} = -2kx_1+kx_2 \\notag\n$$\n\n​\t同理，2号振子满足\n$$\nm\\ddot{x_2} = k{x_1} - 2kx_2  \\notag\n$$\n​\t问题化简为求微分方程组\n$$\n\\begin{cases}\n\t\\ddot{x_1} = -\\frac{2k}{m}x_1 + \\frac{k}{m}x_2\\\\\\\\\n\t\\ddot{x_2} = \\frac{k}{m}x_1 - \\frac{2k}{m}x_2\n\\end{cases}\n$$\n​\t的解，写成矩阵形式即为\n$$\n\\begin{bmatrix}\n\t\\ddot{x_1}\\\\\\\\\n\t\\ddot{x_2}\n\\end{bmatrix} = \\begin{bmatrix}\n\t\\frac{-2k}{m} & \\frac{k}{m}\\\\\\\\\n\t\\frac{k}{m} & \\frac{-2k}{m}\n\\end{bmatrix} \\begin{bmatrix}\n\tx_1\\\\\\\\\n\tx_2\n\\end{bmatrix}\n$$\n​\t现令$\\Omega=\\begin{bmatrix} \\frac{-2k}{m} & \\frac{k}{m}\\\\\\\\  \\frac{k}{m} & \\frac{-2k}{m} \\end{bmatrix} $\n\n​\t观察到 $\\Omega$ 为Hermitian矩阵（$\\Omega^\\dagger = \\Omega$，共轭转置后不变），\n\n​\t故设$\\mid\\mathrm{I}\\rangle $和$\\mid\\mathrm{II}\\rangle $分别为$\\Omega$的两个本征矢（也叫特征向量）\n\n​\t有\n$$\n\\begin{cases}\n\t\\Omega \\mid \\mathrm{I} \\rangle = -\\omega_\\mathrm{I}^2 \\mid \\mathrm{I}\\rangle\\\\\\\\\n\t\\Omega \\mid \\mathrm{II} \\rangle = -\\omega_\\mathrm{II}^2 \\mid \\mathrm{II}\\rangle\n\\end{cases}\n$$\n​\t这里$-\\omega_\\mathrm{I}^2$与$-\\omega_\\mathrm{II}^2$分别表示$\\Omega$的两个本征值，因计算结果表示方便，这里用$-\\omega_i^2$表示，而不是$\\omega_i$。\n\n​\t求出$-\\omega_\\mathrm{I}^2$与$-\\omega_\\mathrm{II}^2$分别为$\\frac{k}{m} \\mp \\frac{2k}{m}$。不妨设$-\\omega_\\mathrm{I}^2＝-\\frac{k}{m}$，$-\\omega_\\mathrm{II}^2＝-\\frac{3k}{m}$。\n\n​\t已知本征值，可以求出本征矢为\n$$\n\\begin{cases}\n\t\\mid \\mathrm{I}\\rangle = \\frac{1}{\\sqrt{2}} \\begin{bmatrix} 1 \\\\\\\\ 1 \\end{bmatrix} & \\omega_\\mathrm{I}=\\sqrt{\\frac{k}{m}} \\\\\\\\\n\t\\mid \\mathrm{II} \\rangle = \\frac{1}{\\sqrt{2}} \\begin{bmatrix} 1 \\\\\\\\-1 \\end{bmatrix}  & \\omega_\\mathrm{II}=\\sqrt{\\frac{3k}{m}}\n \\end{cases}\n$$\n\n​\t可以看出$\\mid \\mathrm{I} \\rangle$与$\\mid \\mathrm{II}\\rangle$相互正交（内积为０）。\n\n​\t因此$x(t)= \\mid \\mathrm{I}\\rangle x_1(t) +\\mid \\mathrm{II}\\rangle x_2(t)$。\n\n​\t到这里，上面的步骤相当于对空间基矢进行了变换，原先的基矢为\n$x_1(t)$对应$\\mid 1 \\rangle = \\begin{bmatrix} 1 \\\\\\\\ 0 \\end{bmatrix}$，$x_2(t)$对应$\\mid 2 \\rangle = \\begin{bmatrix} 0 \\\\\\\\ 1 \\end{bmatrix}$，现变换为$x_\\mathrm{I}$对应$\\mid \\mathrm{I} \\rangle =\\frac{1}{\\sqrt{2}} \\begin{bmatrix} 1 \\\\\\\\ 1 \\end{bmatrix}$，$x_\\mathrm{II}$对应$\\mid \\mathrm{II} \\rangle =\\frac{1}{\\sqrt{2}} \\begin{bmatrix} 1 \\\\\\\\ -1 \\end{bmatrix}$。这样做有什么好处呢？好处马上就会呈现。\n\n​\t此时$\\Omega$可以对角化为\n$$\n\\Omega = \n\\begin{bmatrix}\n\t-\\omega_\\mathrm{I}^2 & 0 \\\\\\\\\n\t0 & -\\omega_\\mathrm{II}^2\n\\end{bmatrix}\n$$\n\n​\t故原方程式可以化为\n\n$$\n\\begin{bmatrix}\n\t\\ddot{x_\\mathrm{I}} \\\\\\\\\n\t\\ddot{x_\\mathrm{II}}\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n\t-\\omega_\\mathrm{I}^2 & 0 \\\\\\\\\n\t0 & -\\omega_\\mathrm{II}^2\n\\end{bmatrix}\n\\begin{bmatrix}\n\tx_\\mathrm{I} \\\\\\\\\n\tx_\\mathrm{II}\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n\t-\\omega_\\mathrm{I}^2 x_\\mathrm{I} \\\\\\\\\n\t-\\omega_\\mathrm{II}^2 x_\\mathrm{II}\n\\end{bmatrix}\n$$\n\n​\t此时分别解$\\ddot{x_\\mathrm{I}}$与$\\ddot{x_\\mathrm{II}}$（两个二阶线性微分方程$\\ddot{x_i} + \\omega_i^2 x_i = 0$，并且$\\dot{x_i}$=0），即可得到$x_i (t),\\quad i=\\mathrm{I,II}$的解，解为\n$$\nx_i(t) = x_i(0) \\cos\\omega_i t, \\quad i=\\mathrm{I,II}\n$$\n\n​\t此时我们离胜利已经很近了——已经得到\t\n$$\n\\begin{aligned}\n\t\\mid x(t) \\rangle & = \\mid \\mathrm{I} \\rangle x_\\mathrm{I}(0)\\cos\\omega_\\mathrm{I}t + \\mid \\mathrm{II} \\rangle x_\\mathrm{II}(0)\\cos\\omega_\\mathrm{II}t \\\\\\\\\n\t& = \\mid \\mathrm{I}\\rangle\\langle\\mathrm{I}\\mid x(0)\\rangle \\cos\\omega_\\mathrm{I}t + \\mid \\mathrm{II}\\rangle\\langle\\mathrm{II}\\mid x(0)\\rangle \\cos\\omega_\\mathrm{II}t \n\\end{aligned}\n$$\n\n​\t式中\n$$\n\\begin{aligned}\n\t\\langle \\mathrm{I} \\mid x(0) \\rangle &= \\frac{1}{\\sqrt{2}} \\begin{bmatrix} 1 & 1 \\end{bmatrix} \\begin{bmatrix} x_1(0) \\\\\\\\ x_2(0) \\end{bmatrix} = \\frac{x_1(0)+x_2(0)}{\\sqrt{2}} \\\\\\\\\n\t\\langle \\mathrm{II} \\mid x(0) \\rangle &= \\frac{1}{\\sqrt{2}} \\begin{bmatrix} 1& -1 \\end{bmatrix} \\begin{bmatrix} x_1(0) \\\\\\\\ x_2(0) \\end{bmatrix} = \\frac{x_1(0) - x_2(0)}{\\sqrt{2}}\n\\end{aligned}\n$$\n\n​\t$\\therefore \\mid x(t)\\rangle = \\mid \\mathrm{I}\\rangle \\frac{x_1(0)+x_2(0)}{\\sqrt{2}} + \\mid \\mathrm{II}\\rangle \\frac{x_1(0) - x_2(0)}{\\sqrt{2}}$\n\n​\t我们需要将$\\mid \\mathrm{I}\\rangle$和$\\mid \\mathrm{II}\\rangle$还原为$\\mid 1\\rangle$和$\\mid 2\\rangle$，这个操作可以通过投影 `projection` 来实现：\n$$\n\\begin{aligned}\n\tx_1(t) =& \\langle 1 \\mid x(t)\\rangle \\\\\\\\\n\t\t=& \\langle 1 \\mid \\mathrm{I}\\rangle \\frac{x_1(0) + x_2(0)}{\\sqrt{2}}\\cos\\omega_\\mathrm{I}t + \\langle 1 \\mid \\mathrm{II}\\rangle \\frac{x_1(0) - x_2(0)}{\\sqrt{2}}\\cos\\omega_\\mathrm{II}t \\\\\\\\\n\t\t=& \\frac{x_1(0) + x_2(0)}{2}\\cos\\left(\\sqrt{\\frac{k}{m}}t\\right) + \\frac{x_1(0) - x_2(0)}{2}\\cos\\left(\\sqrt{\\frac{3k}{m}}t\\right)\n\\end{aligned}\n$$\n​\t同理\n$$\nx_2(t)= \\frac{x_1(0) + x_2(0)}{2}\\cos\\left(\\sqrt{\\frac{k}{m}}t\\right) - \\frac{x_1(0) - x_2(0)}{2}\\cos\\left(\\sqrt{\\frac{3k}{m}}t\\right)\n$$\n​\t写成矩阵形式即为\n$$\n\\begin{bmatrix} x_1(t) \\\\\\\\ x_2(t)  \\end{bmatrix}\n=\n\\begin{bmatrix}\n\t\\frac{\\cos\\left(\\sqrt{\\frac{k}{m}}t\\right) + \\cos\\left(\\sqrt{\\frac{3k}{m}}t\\right) }{2} & \\frac{\\cos\\left(\\sqrt{\\frac{k}{m}}t\\right) - \\cos\\left(\\sqrt{\\frac{3k}{m}}t\\right) }{2} \\\\\\\\\n\t\\frac{\\cos\\left(\\sqrt{\\frac{k}{m}}t\\right) - \\cos\\left(\\sqrt{\\frac{3k}{m}}t\\right) }{2} & \\frac{\\cos\\left(\\sqrt{\\frac{k}{m}}t\\right) + \\cos\\left(\\sqrt{\\frac{3k}{m}}t\\right) }{2}\n\\end{bmatrix}\n\\begin{bmatrix} x_1(0) \\\\\\\\ x_2(0) \\end{bmatrix}\n$$\n​\t此时，只要给出$\\mid x(0)\\rangle$即可得到整个耦合振子系统的运动方程。结束战斗。\n\n\n\n# 收获总结\n\n​\t在Shankar上看到这道题的题解时，起初是不怎么明白的，直到在写这篇手记的过程中，我才体会到这样解的用意：\n\n1. 这是一个耦合系统，即两个微分方程分别含有对方的变量。\n2. 求出$\\mid \\mathrm{I}\\rangle$与$\\mid \\mathrm{II}\\rangle$的过程就是在对原有的线性空间基矢（或称基底）做变换，变换的目的是为了将微分方程组转化为非耦合的方程组。这里，个人以为，说的通俗一些，就是换元——在高等数学的某些求解不定积分时也会用到这种方法。\n3. 求算子$\\Omega$的本征值就是为了将其对角化（对角化后只有对角线上元素不为零），做矩阵乘法运算就可以得到非耦合的方程组，然后问题就变成了熟悉的二阶线性微分方程，之后求解需要用到欧拉公式，这里不赘述。\n4. 用矩阵表示大块方程组真的很方便！\n5. Ti$k$Z很好用！\n\n虽然说上面的题解基本是翻译过来的，但也是有一些收获的，权当 `拾人牙慧吧` 。","slug":"Quantum-Physics-Learning-Log-1","published":1,"updated":"2017-09-19T14:07:58.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj7rorijq0007tcjm4hqcxm0p","content":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><ol>\n<li>这篇手记仅为自己学习记录而写。</li>\n<li>虽然题目提到量子力学，但内容与量子力学关系不大，事实是这篇文章提到的某些概念以及方法在以后学习中十分普遍，因此有必要将其归为量子力学学习手记。</li>\n<li>就当这是在打数学基础好了。</li>\n</ol>\n<h1 id=\"符号说明\"><a href=\"#符号说明\" class=\"headerlink\" title=\"符号说明\"></a>符号说明</h1><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>符号</th>\n<th>说明，以下符号表示的量是在 <em>复数范围</em> 内讨论的</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>$\\mid i\\rangle$</td>\n<td>ket，也称列向量</td>\n</tr>\n<tr>\n<td>$\\langle i\\mid$</td>\n<td>bra，也称行向量</td>\n</tr>\n<tr>\n<td>$\\langle i\\mid  j \\rangle $</td>\n<td>inner product，求向量$\\langle i\\mid $与向量$\\mid j\\rangle$的内积</td>\n</tr>\n<tr>\n<td>$\\mid  i \\rangle \\langle j \\mid  $</td>\n<td>outer product，求向量$\\mid i\\rangle$与向量$\\langle j\\mid $的外积</td>\n</tr>\n<tr>\n<td>$\\mid i\\rangle ^\\dagger$</td>\n<td>transpose conjugate，共轭转置，即向量每个元素取共轭复数后整体转置，$\\mid i\\rangle ^\\dagger = \\langle i^*\\mid $</td>\n</tr>\n<tr>\n<td>$\\Omega$, $\\Lambda$</td>\n<td>算子，或称算符，由函数组成的矩阵</td>\n</tr>\n<tr>\n<td>$\\Omega^\\dagger$</td>\n<td>对 $\\Omega$ 取共轭转置</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h1 id=\"题目重现\"><a href=\"#题目重现\" class=\"headerlink\" title=\"题目重现\"></a>题目重现</h1><p>如图，两个振子组成一维耦合振子，两质点的质量均为$m$，所有弹簧劲度系数均为$k$，以右为正方向，两者位移分别为$x_1$、$x_2$。若两振子初始速度均为零，设两个振子在各自平衡位置时的位移为０，且初始位置未知，求这两个振子的位移-时间函数即$x_i(t)$。</p>\n<p><img src=\"fig.svg\" alt=\"耦合振子示意图\"></p>\n<h1 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h1><p>​    对两个振子分别分析，不妨设左边振子为1号，右边振子为2号。</p>\n<p>​    对1号振子做受力分析：</p>\n<script type=\"math/tex; mode=display\">\nm \\frac{\\mathrm{d}^2 x_1}{\\mathrm{d}t^2} = k(x_2 - x_1) - k{x_1}</script><p>​    即</p>\n<script type=\"math/tex; mode=display\">\nm\\ddot{x_1} = -2kx_1+kx_2 \\notag</script><p>​    同理，2号振子满足</p>\n<script type=\"math/tex; mode=display\">\nm\\ddot{x_2} = k{x_1} - 2kx_2  \\notag</script><p>​    问题化简为求微分方程组</p>\n<script type=\"math/tex; mode=display\">\n\\begin{cases}\n    \\ddot{x_1} = -\\frac{2k}{m}x_1 + \\frac{k}{m}x_2\\\\\\\\\n    \\ddot{x_2} = \\frac{k}{m}x_1 - \\frac{2k}{m}x_2\n\\end{cases}</script><p>​    的解，写成矩阵形式即为</p>\n<script type=\"math/tex; mode=display\">\n\\begin{bmatrix}\n    \\ddot{x_1}\\\\\\\\\n    \\ddot{x_2}\n\\end{bmatrix} = \\begin{bmatrix}\n    \\frac{-2k}{m} & \\frac{k}{m}\\\\\\\\\n    \\frac{k}{m} & \\frac{-2k}{m}\n\\end{bmatrix} \\begin{bmatrix}\n    x_1\\\\\\\\\n    x_2\n\\end{bmatrix}</script><p>​    现令$\\Omega=\\begin{bmatrix} \\frac{-2k}{m} &amp; \\frac{k}{m}\\\\  \\frac{k}{m} &amp; \\frac{-2k}{m} \\end{bmatrix} $</p>\n<p>​    观察到 $\\Omega$ 为Hermitian矩阵（$\\Omega^\\dagger = \\Omega$，共轭转置后不变），</p>\n<p>​    故设$\\mid\\mathrm{I}\\rangle $和$\\mid\\mathrm{II}\\rangle $分别为$\\Omega$的两个本征矢（也叫特征向量）</p>\n<p>​    有</p>\n<script type=\"math/tex; mode=display\">\n\\begin{cases}\n    \\Omega \\mid \\mathrm{I} \\rangle = -\\omega_\\mathrm{I}^2 \\mid \\mathrm{I}\\rangle\\\\\\\\\n    \\Omega \\mid \\mathrm{II} \\rangle = -\\omega_\\mathrm{II}^2 \\mid \\mathrm{II}\\rangle\n\\end{cases}</script><p>​    这里$-\\omega<em>\\mathrm{I}^2$与$-\\omega</em>\\mathrm{II}^2$分别表示$\\Omega$的两个本征值，因计算结果表示方便，这里用$-\\omega_i^2$表示，而不是$\\omega_i$。</p>\n<p>​    求出$-\\omega<em>\\mathrm{I}^2$与$-\\omega</em>\\mathrm{II}^2$分别为$\\frac{k}{m} \\mp \\frac{2k}{m}$。不妨设$-\\omega<em>\\mathrm{I}^2＝-\\frac{k}{m}$，$-\\omega</em>\\mathrm{II}^2＝-\\frac{3k}{m}$。</p>\n<p>​    已知本征值，可以求出本征矢为</p>\n<script type=\"math/tex; mode=display\">\n\\begin{cases}\n    \\mid \\mathrm{I}\\rangle = \\frac{1}{\\sqrt{2}} \\begin{bmatrix} 1 \\\\\\\\ 1 \\end{bmatrix} & \\omega_\\mathrm{I}=\\sqrt{\\frac{k}{m}} \\\\\\\\\n    \\mid \\mathrm{II} \\rangle = \\frac{1}{\\sqrt{2}} \\begin{bmatrix} 1 \\\\\\\\-1 \\end{bmatrix}  & \\omega_\\mathrm{II}=\\sqrt{\\frac{3k}{m}}\n \\end{cases}</script><p>​    可以看出$\\mid \\mathrm{I} \\rangle$与$\\mid \\mathrm{II}\\rangle$相互正交（内积为０）。</p>\n<p>​    因此$x(t)= \\mid \\mathrm{I}\\rangle x_1(t) +\\mid \\mathrm{II}\\rangle x_2(t)$。</p>\n<p>​    到这里，上面的步骤相当于对空间基矢进行了变换，原先的基矢为<br>$x<em>1(t)$对应$\\mid 1 \\rangle = \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix}$，$x_2(t)$对应$\\mid 2 \\rangle = \\begin{bmatrix} 0 \\\\ 1 \\end{bmatrix}$，现变换为$x</em>\\mathrm{I}$对应$\\mid \\mathrm{I} \\rangle =\\frac{1}{\\sqrt{2}} \\begin{bmatrix} 1 \\\\ 1 \\end{bmatrix}$，$x_\\mathrm{II}$对应$\\mid \\mathrm{II} \\rangle =\\frac{1}{\\sqrt{2}} \\begin{bmatrix} 1 \\\\ -1 \\end{bmatrix}$。这样做有什么好处呢？好处马上就会呈现。</p>\n<p>​    此时$\\Omega$可以对角化为</p>\n<script type=\"math/tex; mode=display\">\n\\Omega = \n\\begin{bmatrix}\n    -\\omega_\\mathrm{I}^2 & 0 \\\\\\\\\n    0 & -\\omega_\\mathrm{II}^2\n\\end{bmatrix}</script><p>​    故原方程式可以化为</p>\n<script type=\"math/tex; mode=display\">\n\\begin{bmatrix}\n    \\ddot{x_\\mathrm{I}} \\\\\\\\\n    \\ddot{x_\\mathrm{II}}\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n    -\\omega_\\mathrm{I}^2 & 0 \\\\\\\\\n    0 & -\\omega_\\mathrm{II}^2\n\\end{bmatrix}\n\\begin{bmatrix}\n    x_\\mathrm{I} \\\\\\\\\n    x_\\mathrm{II}\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n    -\\omega_\\mathrm{I}^2 x_\\mathrm{I} \\\\\\\\\n    -\\omega_\\mathrm{II}^2 x_\\mathrm{II}\n\\end{bmatrix}</script><p>​    此时分别解$\\ddot{x<em>\\mathrm{I}}$与$\\ddot{x</em>\\mathrm{II}}$（两个二阶线性微分方程$\\ddot{x_i} + \\omega_i^2 x_i = 0$，并且$\\dot{x_i}$=0），即可得到$x_i (t),\\quad i=\\mathrm{I,II}$的解，解为</p>\n<script type=\"math/tex; mode=display\">\nx_i(t) = x_i(0) \\cos\\omega_i t, \\quad i=\\mathrm{I,II}</script><p>​    此时我们离胜利已经很近了——已经得到    </p>\n<script type=\"math/tex; mode=display\">\n\\begin{aligned}\n    \\mid x(t) \\rangle & = \\mid \\mathrm{I} \\rangle x_\\mathrm{I}(0)\\cos\\omega_\\mathrm{I}t + \\mid \\mathrm{II} \\rangle x_\\mathrm{II}(0)\\cos\\omega_\\mathrm{II}t \\\\\\\\\n    & = \\mid \\mathrm{I}\\rangle\\langle\\mathrm{I}\\mid x(0)\\rangle \\cos\\omega_\\mathrm{I}t + \\mid \\mathrm{II}\\rangle\\langle\\mathrm{II}\\mid x(0)\\rangle \\cos\\omega_\\mathrm{II}t \n\\end{aligned}</script><p>​    式中</p>\n<script type=\"math/tex; mode=display\">\n\\begin{aligned}\n    \\langle \\mathrm{I} \\mid x(0) \\rangle &= \\frac{1}{\\sqrt{2}} \\begin{bmatrix} 1 & 1 \\end{bmatrix} \\begin{bmatrix} x_1(0) \\\\\\\\ x_2(0) \\end{bmatrix} = \\frac{x_1(0)+x_2(0)}{\\sqrt{2}} \\\\\\\\\n    \\langle \\mathrm{II} \\mid x(0) \\rangle &= \\frac{1}{\\sqrt{2}} \\begin{bmatrix} 1& -1 \\end{bmatrix} \\begin{bmatrix} x_1(0) \\\\\\\\ x_2(0) \\end{bmatrix} = \\frac{x_1(0) - x_2(0)}{\\sqrt{2}}\n\\end{aligned}</script><p>​    $\\therefore \\mid x(t)\\rangle = \\mid \\mathrm{I}\\rangle \\frac{x_1(0)+x_2(0)}{\\sqrt{2}} + \\mid \\mathrm{II}\\rangle \\frac{x_1(0) - x_2(0)}{\\sqrt{2}}$</p>\n<p>​    我们需要将$\\mid \\mathrm{I}\\rangle$和$\\mid \\mathrm{II}\\rangle$还原为$\\mid 1\\rangle$和$\\mid 2\\rangle$，这个操作可以通过投影 <code>projection</code> 来实现：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{aligned}\n    x_1(t) =& \\langle 1 \\mid x(t)\\rangle \\\\\\\\\n        =& \\langle 1 \\mid \\mathrm{I}\\rangle \\frac{x_1(0) + x_2(0)}{\\sqrt{2}}\\cos\\omega_\\mathrm{I}t + \\langle 1 \\mid \\mathrm{II}\\rangle \\frac{x_1(0) - x_2(0)}{\\sqrt{2}}\\cos\\omega_\\mathrm{II}t \\\\\\\\\n        =& \\frac{x_1(0) + x_2(0)}{2}\\cos\\left(\\sqrt{\\frac{k}{m}}t\\right) + \\frac{x_1(0) - x_2(0)}{2}\\cos\\left(\\sqrt{\\frac{3k}{m}}t\\right)\n\\end{aligned}</script><p>​    同理</p>\n<script type=\"math/tex; mode=display\">\nx_2(t)= \\frac{x_1(0) + x_2(0)}{2}\\cos\\left(\\sqrt{\\frac{k}{m}}t\\right) - \\frac{x_1(0) - x_2(0)}{2}\\cos\\left(\\sqrt{\\frac{3k}{m}}t\\right)</script><p>​    写成矩阵形式即为</p>\n<script type=\"math/tex; mode=display\">\n\\begin{bmatrix} x_1(t) \\\\\\\\ x_2(t)  \\end{bmatrix}\n=\n\\begin{bmatrix}\n    \\frac{\\cos\\left(\\sqrt{\\frac{k}{m}}t\\right) + \\cos\\left(\\sqrt{\\frac{3k}{m}}t\\right) }{2} & \\frac{\\cos\\left(\\sqrt{\\frac{k}{m}}t\\right) - \\cos\\left(\\sqrt{\\frac{3k}{m}}t\\right) }{2} \\\\\\\\\n    \\frac{\\cos\\left(\\sqrt{\\frac{k}{m}}t\\right) - \\cos\\left(\\sqrt{\\frac{3k}{m}}t\\right) }{2} & \\frac{\\cos\\left(\\sqrt{\\frac{k}{m}}t\\right) + \\cos\\left(\\sqrt{\\frac{3k}{m}}t\\right) }{2}\n\\end{bmatrix}\n\\begin{bmatrix} x_1(0) \\\\\\\\ x_2(0) \\end{bmatrix}</script><p>​    此时，只要给出$\\mid x(0)\\rangle$即可得到整个耦合振子系统的运动方程。结束战斗。</p>\n<h1 id=\"收获总结\"><a href=\"#收获总结\" class=\"headerlink\" title=\"收获总结\"></a>收获总结</h1><p>​    在Shankar上看到这道题的题解时，起初是不怎么明白的，直到在写这篇手记的过程中，我才体会到这样解的用意：</p>\n<ol>\n<li>这是一个耦合系统，即两个微分方程分别含有对方的变量。</li>\n<li>求出$\\mid \\mathrm{I}\\rangle$与$\\mid \\mathrm{II}\\rangle$的过程就是在对原有的线性空间基矢（或称基底）做变换，变换的目的是为了将微分方程组转化为非耦合的方程组。这里，个人以为，说的通俗一些，就是换元——在高等数学的某些求解不定积分时也会用到这种方法。</li>\n<li>求算子$\\Omega$的本征值就是为了将其对角化（对角化后只有对角线上元素不为零），做矩阵乘法运算就可以得到非耦合的方程组，然后问题就变成了熟悉的二阶线性微分方程，之后求解需要用到欧拉公式，这里不赘述。</li>\n<li>用矩阵表示大块方程组真的很方便！</li>\n<li>Ti$k$Z很好用！</li>\n</ol>\n<p>虽然说上面的题解基本是翻译过来的，但也是有一些收获的，权当 <code>拾人牙慧吧</code> 。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><ol>\n<li>这篇手记仅为自己学习记录而写。</li>\n<li>虽然题目提到量子力学，但内容与量子力学关系不大，事实是这篇文章提到的某些概念以及方法在以后学习中十分普遍，因此有必要将其归为量子力学学习手记。</li>\n<li>就当这是在打数学基础好了。</li>\n</ol>\n<h1 id=\"符号说明\"><a href=\"#符号说明\" class=\"headerlink\" title=\"符号说明\"></a>符号说明</h1><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>符号</th>\n<th>说明，以下符号表示的量是在 <em>复数范围</em> 内讨论的</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>$\\mid i\\rangle$</td>\n<td>ket，也称列向量</td>\n</tr>\n<tr>\n<td>$\\langle i\\mid$</td>\n<td>bra，也称行向量</td>\n</tr>\n<tr>\n<td>$\\langle i\\mid  j \\rangle $</td>\n<td>inner product，求向量$\\langle i\\mid $与向量$\\mid j\\rangle$的内积</td>\n</tr>\n<tr>\n<td>$\\mid  i \\rangle \\langle j \\mid  $</td>\n<td>outer product，求向量$\\mid i\\rangle$与向量$\\langle j\\mid $的外积</td>\n</tr>\n<tr>\n<td>$\\mid i\\rangle ^\\dagger$</td>\n<td>transpose conjugate，共轭转置，即向量每个元素取共轭复数后整体转置，$\\mid i\\rangle ^\\dagger = \\langle i^*\\mid $</td>\n</tr>\n<tr>\n<td>$\\Omega$, $\\Lambda$</td>\n<td>算子，或称算符，由函数组成的矩阵</td>\n</tr>\n<tr>\n<td>$\\Omega^\\dagger$</td>\n<td>对 $\\Omega$ 取共轭转置</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h1 id=\"题目重现\"><a href=\"#题目重现\" class=\"headerlink\" title=\"题目重现\"></a>题目重现</h1><p>如图，两个振子组成一维耦合振子，两质点的质量均为$m$，所有弹簧劲度系数均为$k$，以右为正方向，两者位移分别为$x_1$、$x_2$。若两振子初始速度均为零，设两个振子在各自平衡位置时的位移为０，且初始位置未知，求这两个振子的位移-时间函数即$x_i(t)$。</p>\n<p><img src=\"fig.svg\" alt=\"耦合振子示意图\"></p>\n<h1 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h1><p>​    对两个振子分别分析，不妨设左边振子为1号，右边振子为2号。</p>\n<p>​    对1号振子做受力分析：</p>\n<script type=\"math/tex; mode=display\">\nm \\frac{\\mathrm{d}^2 x_1}{\\mathrm{d}t^2} = k(x_2 - x_1) - k{x_1}</script><p>​    即</p>\n<script type=\"math/tex; mode=display\">\nm\\ddot{x_1} = -2kx_1+kx_2 \\notag</script><p>​    同理，2号振子满足</p>\n<script type=\"math/tex; mode=display\">\nm\\ddot{x_2} = k{x_1} - 2kx_2  \\notag</script><p>​    问题化简为求微分方程组</p>\n<script type=\"math/tex; mode=display\">\n\\begin{cases}\n    \\ddot{x_1} = -\\frac{2k}{m}x_1 + \\frac{k}{m}x_2\\\\\\\\\n    \\ddot{x_2} = \\frac{k}{m}x_1 - \\frac{2k}{m}x_2\n\\end{cases}</script><p>​    的解，写成矩阵形式即为</p>\n<script type=\"math/tex; mode=display\">\n\\begin{bmatrix}\n    \\ddot{x_1}\\\\\\\\\n    \\ddot{x_2}\n\\end{bmatrix} = \\begin{bmatrix}\n    \\frac{-2k}{m} & \\frac{k}{m}\\\\\\\\\n    \\frac{k}{m} & \\frac{-2k}{m}\n\\end{bmatrix} \\begin{bmatrix}\n    x_1\\\\\\\\\n    x_2\n\\end{bmatrix}</script><p>​    现令$\\Omega=\\begin{bmatrix} \\frac{-2k}{m} &amp; \\frac{k}{m}\\\\  \\frac{k}{m} &amp; \\frac{-2k}{m} \\end{bmatrix} $</p>\n<p>​    观察到 $\\Omega$ 为Hermitian矩阵（$\\Omega^\\dagger = \\Omega$，共轭转置后不变），</p>\n<p>​    故设$\\mid\\mathrm{I}\\rangle $和$\\mid\\mathrm{II}\\rangle $分别为$\\Omega$的两个本征矢（也叫特征向量）</p>\n<p>​    有</p>\n<script type=\"math/tex; mode=display\">\n\\begin{cases}\n    \\Omega \\mid \\mathrm{I} \\rangle = -\\omega_\\mathrm{I}^2 \\mid \\mathrm{I}\\rangle\\\\\\\\\n    \\Omega \\mid \\mathrm{II} \\rangle = -\\omega_\\mathrm{II}^2 \\mid \\mathrm{II}\\rangle\n\\end{cases}</script><p>​    这里$-\\omega<em>\\mathrm{I}^2$与$-\\omega</em>\\mathrm{II}^2$分别表示$\\Omega$的两个本征值，因计算结果表示方便，这里用$-\\omega_i^2$表示，而不是$\\omega_i$。</p>\n<p>​    求出$-\\omega<em>\\mathrm{I}^2$与$-\\omega</em>\\mathrm{II}^2$分别为$\\frac{k}{m} \\mp \\frac{2k}{m}$。不妨设$-\\omega<em>\\mathrm{I}^2＝-\\frac{k}{m}$，$-\\omega</em>\\mathrm{II}^2＝-\\frac{3k}{m}$。</p>\n<p>​    已知本征值，可以求出本征矢为</p>\n<script type=\"math/tex; mode=display\">\n\\begin{cases}\n    \\mid \\mathrm{I}\\rangle = \\frac{1}{\\sqrt{2}} \\begin{bmatrix} 1 \\\\\\\\ 1 \\end{bmatrix} & \\omega_\\mathrm{I}=\\sqrt{\\frac{k}{m}} \\\\\\\\\n    \\mid \\mathrm{II} \\rangle = \\frac{1}{\\sqrt{2}} \\begin{bmatrix} 1 \\\\\\\\-1 \\end{bmatrix}  & \\omega_\\mathrm{II}=\\sqrt{\\frac{3k}{m}}\n \\end{cases}</script><p>​    可以看出$\\mid \\mathrm{I} \\rangle$与$\\mid \\mathrm{II}\\rangle$相互正交（内积为０）。</p>\n<p>​    因此$x(t)= \\mid \\mathrm{I}\\rangle x_1(t) +\\mid \\mathrm{II}\\rangle x_2(t)$。</p>\n<p>​    到这里，上面的步骤相当于对空间基矢进行了变换，原先的基矢为<br>$x<em>1(t)$对应$\\mid 1 \\rangle = \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix}$，$x_2(t)$对应$\\mid 2 \\rangle = \\begin{bmatrix} 0 \\\\ 1 \\end{bmatrix}$，现变换为$x</em>\\mathrm{I}$对应$\\mid \\mathrm{I} \\rangle =\\frac{1}{\\sqrt{2}} \\begin{bmatrix} 1 \\\\ 1 \\end{bmatrix}$，$x_\\mathrm{II}$对应$\\mid \\mathrm{II} \\rangle =\\frac{1}{\\sqrt{2}} \\begin{bmatrix} 1 \\\\ -1 \\end{bmatrix}$。这样做有什么好处呢？好处马上就会呈现。</p>\n<p>​    此时$\\Omega$可以对角化为</p>\n<script type=\"math/tex; mode=display\">\n\\Omega = \n\\begin{bmatrix}\n    -\\omega_\\mathrm{I}^2 & 0 \\\\\\\\\n    0 & -\\omega_\\mathrm{II}^2\n\\end{bmatrix}</script><p>​    故原方程式可以化为</p>\n<script type=\"math/tex; mode=display\">\n\\begin{bmatrix}\n    \\ddot{x_\\mathrm{I}} \\\\\\\\\n    \\ddot{x_\\mathrm{II}}\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n    -\\omega_\\mathrm{I}^2 & 0 \\\\\\\\\n    0 & -\\omega_\\mathrm{II}^2\n\\end{bmatrix}\n\\begin{bmatrix}\n    x_\\mathrm{I} \\\\\\\\\n    x_\\mathrm{II}\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n    -\\omega_\\mathrm{I}^2 x_\\mathrm{I} \\\\\\\\\n    -\\omega_\\mathrm{II}^2 x_\\mathrm{II}\n\\end{bmatrix}</script><p>​    此时分别解$\\ddot{x<em>\\mathrm{I}}$与$\\ddot{x</em>\\mathrm{II}}$（两个二阶线性微分方程$\\ddot{x_i} + \\omega_i^2 x_i = 0$，并且$\\dot{x_i}$=0），即可得到$x_i (t),\\quad i=\\mathrm{I,II}$的解，解为</p>\n<script type=\"math/tex; mode=display\">\nx_i(t) = x_i(0) \\cos\\omega_i t, \\quad i=\\mathrm{I,II}</script><p>​    此时我们离胜利已经很近了——已经得到    </p>\n<script type=\"math/tex; mode=display\">\n\\begin{aligned}\n    \\mid x(t) \\rangle & = \\mid \\mathrm{I} \\rangle x_\\mathrm{I}(0)\\cos\\omega_\\mathrm{I}t + \\mid \\mathrm{II} \\rangle x_\\mathrm{II}(0)\\cos\\omega_\\mathrm{II}t \\\\\\\\\n    & = \\mid \\mathrm{I}\\rangle\\langle\\mathrm{I}\\mid x(0)\\rangle \\cos\\omega_\\mathrm{I}t + \\mid \\mathrm{II}\\rangle\\langle\\mathrm{II}\\mid x(0)\\rangle \\cos\\omega_\\mathrm{II}t \n\\end{aligned}</script><p>​    式中</p>\n<script type=\"math/tex; mode=display\">\n\\begin{aligned}\n    \\langle \\mathrm{I} \\mid x(0) \\rangle &= \\frac{1}{\\sqrt{2}} \\begin{bmatrix} 1 & 1 \\end{bmatrix} \\begin{bmatrix} x_1(0) \\\\\\\\ x_2(0) \\end{bmatrix} = \\frac{x_1(0)+x_2(0)}{\\sqrt{2}} \\\\\\\\\n    \\langle \\mathrm{II} \\mid x(0) \\rangle &= \\frac{1}{\\sqrt{2}} \\begin{bmatrix} 1& -1 \\end{bmatrix} \\begin{bmatrix} x_1(0) \\\\\\\\ x_2(0) \\end{bmatrix} = \\frac{x_1(0) - x_2(0)}{\\sqrt{2}}\n\\end{aligned}</script><p>​    $\\therefore \\mid x(t)\\rangle = \\mid \\mathrm{I}\\rangle \\frac{x_1(0)+x_2(0)}{\\sqrt{2}} + \\mid \\mathrm{II}\\rangle \\frac{x_1(0) - x_2(0)}{\\sqrt{2}}$</p>\n<p>​    我们需要将$\\mid \\mathrm{I}\\rangle$和$\\mid \\mathrm{II}\\rangle$还原为$\\mid 1\\rangle$和$\\mid 2\\rangle$，这个操作可以通过投影 <code>projection</code> 来实现：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{aligned}\n    x_1(t) =& \\langle 1 \\mid x(t)\\rangle \\\\\\\\\n        =& \\langle 1 \\mid \\mathrm{I}\\rangle \\frac{x_1(0) + x_2(0)}{\\sqrt{2}}\\cos\\omega_\\mathrm{I}t + \\langle 1 \\mid \\mathrm{II}\\rangle \\frac{x_1(0) - x_2(0)}{\\sqrt{2}}\\cos\\omega_\\mathrm{II}t \\\\\\\\\n        =& \\frac{x_1(0) + x_2(0)}{2}\\cos\\left(\\sqrt{\\frac{k}{m}}t\\right) + \\frac{x_1(0) - x_2(0)}{2}\\cos\\left(\\sqrt{\\frac{3k}{m}}t\\right)\n\\end{aligned}</script><p>​    同理</p>\n<script type=\"math/tex; mode=display\">\nx_2(t)= \\frac{x_1(0) + x_2(0)}{2}\\cos\\left(\\sqrt{\\frac{k}{m}}t\\right) - \\frac{x_1(0) - x_2(0)}{2}\\cos\\left(\\sqrt{\\frac{3k}{m}}t\\right)</script><p>​    写成矩阵形式即为</p>\n<script type=\"math/tex; mode=display\">\n\\begin{bmatrix} x_1(t) \\\\\\\\ x_2(t)  \\end{bmatrix}\n=\n\\begin{bmatrix}\n    \\frac{\\cos\\left(\\sqrt{\\frac{k}{m}}t\\right) + \\cos\\left(\\sqrt{\\frac{3k}{m}}t\\right) }{2} & \\frac{\\cos\\left(\\sqrt{\\frac{k}{m}}t\\right) - \\cos\\left(\\sqrt{\\frac{3k}{m}}t\\right) }{2} \\\\\\\\\n    \\frac{\\cos\\left(\\sqrt{\\frac{k}{m}}t\\right) - \\cos\\left(\\sqrt{\\frac{3k}{m}}t\\right) }{2} & \\frac{\\cos\\left(\\sqrt{\\frac{k}{m}}t\\right) + \\cos\\left(\\sqrt{\\frac{3k}{m}}t\\right) }{2}\n\\end{bmatrix}\n\\begin{bmatrix} x_1(0) \\\\\\\\ x_2(0) \\end{bmatrix}</script><p>​    此时，只要给出$\\mid x(0)\\rangle$即可得到整个耦合振子系统的运动方程。结束战斗。</p>\n<h1 id=\"收获总结\"><a href=\"#收获总结\" class=\"headerlink\" title=\"收获总结\"></a>收获总结</h1><p>​    在Shankar上看到这道题的题解时，起初是不怎么明白的，直到在写这篇手记的过程中，我才体会到这样解的用意：</p>\n<ol>\n<li>这是一个耦合系统，即两个微分方程分别含有对方的变量。</li>\n<li>求出$\\mid \\mathrm{I}\\rangle$与$\\mid \\mathrm{II}\\rangle$的过程就是在对原有的线性空间基矢（或称基底）做变换，变换的目的是为了将微分方程组转化为非耦合的方程组。这里，个人以为，说的通俗一些，就是换元——在高等数学的某些求解不定积分时也会用到这种方法。</li>\n<li>求算子$\\Omega$的本征值就是为了将其对角化（对角化后只有对角线上元素不为零），做矩阵乘法运算就可以得到非耦合的方程组，然后问题就变成了熟悉的二阶线性微分方程，之后求解需要用到欧拉公式，这里不赘述。</li>\n<li>用矩阵表示大块方程组真的很方便！</li>\n<li>Ti$k$Z很好用！</li>\n</ol>\n<p>虽然说上面的题解基本是翻译过来的，但也是有一些收获的，权当 <code>拾人牙慧吧</code> 。</p>\n"},{"title":"物理化学复习札记（一）：理想气体热力学量求解总结","date":"2017-06-26T09:07:41.000Z","_content":"\n\n**这是这个系列的第一篇，也是第一次写这种类型的札记，如果有纰漏，还请在评论区指出，谢谢各位！**\n\n## 热力学量说明\n物理化学中，热力学主要研究7个热力学量，这7个量如下：\n\n1. $U$，系统的热力学能，或称内能，属于状态函数，$U=f(T)$，无法求出$U$的值，但可以求出$\\Delta U$的值，单位为J；\n2. $Q$，系统与环境交换的热量，当系统放热时，$Q$为负值；系统吸热，则$Q$为正值，单位为J；\n3. $W$，环境对系统所做的功，分为体积功和非体积功，单位为J；\n4. $H$，焓，定义为 $H=U+pV$，无实际含义，仅为计算方便而产生，属于状态函数，$H=f(T)$，与$U$一样，无法求出$H$的值，但可以求出$\\Delta H$的值，单位为J；\n5. $S$，大名鼎鼎的熵，定义为$S=\\int_A^B (\\dfrac{\\delta Q}{T})_R$，属于状态函数，处于绝对零度时完美晶体的熵为0，单位J$\\cdot $K$^{-1}$\n6. $A$，亥姆霍兹自由能，定义为$A=U-TS$，为状态函数，无法求出$A$的值，但可以求出$\\Delta A$的值，单位为J；\n7. $G$，吉布斯自由能，定义为$G=H-TS$，为状态函数，无法求出$G$的值，但可以求出$\\Delta G$的值，单位为J；\n\n以上说明中，状态函数是指当系统状态一定时，其值即确定，亦即在某个过程中其变化量$\\Delta f$只与始末状态有关，与过程细节无关。这个性质**非常重要**，物理化学常见的设计过程求解热力学量的理论基础即在于此。\n\n## 热力学四大定律\n\n是的，热力学有四大定律，分别为热力学第零定律、热力学第一定律、热力学第二定律和热力学第三定律。\n\n### 热力学第零定律\n**如果两个系统分别与处于确定状态的第三个系统达到热平衡，则这两个系统彼此也将处于热平衡。**\n\n这个定律定义了温度的概念，当两个系统相互接触处于热平衡后，它们的性质不再变化，我们称之具有相同的温度。而定义中提到的第三系统为温度计的产生奠定了理论基础。\n\n### 热力学第一定律\n**在变化过程中，系统的热力学能变化量表示为系统和环境的热交换量与外界对系统所做功的总和。**\n写成公式即为 $ \\Delta U = Q + W $，\n或者写成微分形式$ \\mathrm{d}U = \\delta Q + \\delta W $\n\n### 热力学第二定律\n\n文字可表述为：\n\n> 克劳修斯表述：不可能把热从低温物体传到高温物体，而不引起其他变化；\n> 开尔文表述：不可能从单一热源取出热使之完全变为功，而不发生其他变化。\n\n数学形式：\n\n- 克劳修斯不等式表述形式：$ \\Delta S_{A\\to B}-\\sum_A^B \\dfrac{\\delta Q}{T} \\geq 0 $\n- 常用表述形式：$ \\mathrm{d}S - \\dfrac{\\delta Q}{T} \\geq 0 $\n\n\n上式表明，在一个隔离系统中，熵永不减少。 隔离系统是绝热的，即$\\delta Q=0$，因此$\\mathrm{d}S_{\\mathrm{iso}} \\geq 0$。\n\n\n### 热力学第三定律\n可以表述为**在温度趋于热力学温度0K的等温过程中，系统的熵值不变 **，也可以表述为“**在0K时，任何完美晶体的熵等于零**”，还可以表述为”**绝对零度不可能达到**“。\n\n\n## 特殊过程的热力学量求值\n\n**本节所有过程均为$p$,$V$,$T$过程，不考虑非体积功！**\n\n常见的变化过程（均为理想气体的变化过程）有：\n1. 等温过程：系统由状态1变到状态2，变化过程中以及始态和终态的温度不变，**且等于环境温度**；\n2. 等压过程：系统在变化过程中，始态和终态压力相等，且等于环境压力；\n3. 等容过程：系统在变化过程中保持体积不变。在刚性容器中发生的变化一般是等容过程；\n4. 绝热过程：系统在变化过程中与环境之间没有热的交换，或者是由于有绝热壁的存在，或者是因为变化太快而与环境来不及热交换，或者热交换量极少可近似看作是绝热过程；\n5. 环状过程：系统从始态出发，经过一系列变化后又回到了原来状态。经此过程，所有状态函数的变化量都为零。\n\n另外，自由膨胀过程可以看为外压恒为0的等压膨胀过程；节流膨胀过程属于实际气体的不可逆过程，不在本札记讨论范围内。\n\n### 自由膨胀过程\n此过程不可逆，可看作外压恒为零的等压过程。\n\n- $\\Delta U=0$，由`Gay-Lussac-Joule`实验得出，而$U=f(T)$，故此过程中气体$T$不变；\n- $W=0$，显然，自由膨胀时外压恒为零，也无非体积功，故$W=0$；\n- $Q=0$，由热力学第一定律，$\\Delta U=Q+W$，式中$\\Delta U=0$，$W=0$，因此$Q=0$；\n- $\\Delta H=0$，$H$是状态函数，由上文气体$T$不变可以推出$H$不变。 另外也可由公式$\\Delta H=\\Delta U + \\Delta(pV)$，$pV=nRT$（n、T不变，所以$pV$不变）推出$\\Delta H=0$；\n- $\\Delta S>0$，显然该过程不可逆，其对应的可逆过程为等温可逆膨胀，计算得$\\Delta S=\\int\\dfrac{\\delta Q}{T} = \\dfrac{Q}{T} = nR\\ln\\dfrac{V_2}{V_1} = -nR\\ln\\dfrac{p_2}{p_1}$；\n- $\\Delta G<0​$，由公式$\\Delta G=\\Delta H-\\Delta (TS)​$，并且$\\Delta H=0​$、$T​$不变得出$\\Delta G=-T\\Delta S​$；\n- $\\Delta A<0$，与计算$\\Delta G$的过程类似，$\\Delta A=-T\\Delta S$。\n\n### 等温可逆过程\n此过程满足 $pV=nRT=\\mathrm{Constant}$。\n\n- $\\Delta U=0$，$U$为状态函数，等温过程系统温度不变，因此$U$不变、$\\Delta U=0$；\n- $W$，由公式$W=-\\int_{V_1}^{V_2}p_{\\mathrm{e}}\\mathrm{d}V$，且$p_e=p=\\dfrac{nRT}{V}$（可逆过程中环境压力始终近似于系统压力），所以$W=-nRT\\int_{V_1}^{V^2} \\dfrac{1}{V} \\mathrm{d}V=-nRT\\ln\\dfrac{V_2}{V_1}$；此外，若已知系统的始末压力，也可以将前式变换为$W=nRT\\dfrac{p_1}{p_2}$\n- $Q$，由热力学第一定律，$\\Delta U=W+Q$，得$Q=-W=nRT\\ln\\dfrac{V_2}{V_1}$；\n- $\\Delta H$，与$U$类似，为状态函数，$\\Delta H=0$；\n- $\\Delta S$，此过程已经为可逆过程，不必再设计可逆过程。因此$\\Delta S=\\int\\dfrac{\\delta Q}{T} = \\dfrac{Q}{T} = nR\\ln\\dfrac{V_2}{V_1} = -nR\\ln\\dfrac{p_2}{p_1}$；\n- $\\Delta G$，直接代入公式$\\Delta G=\\Delta H-\\Delta(TS)$，得$\\Delta G=-nRT\\ln\\dfrac{V_2}{V_1}=nRT\\ln\\dfrac{p_2}{p_1}=W $；\n- $\\Delta A$，同$\\Delta G$，得到$\\Delta A=\\Delta G=W=-nRT\\ln\\dfrac{V_2}{V_1}=nRT\\ln\\dfrac{p_2}{p_1} $。\n\n### 等压过程\n此过程满足 $\\dfrac{nRT}{V}=\\text{Constant}$\n\n- $\\Delta U$，此时$\\Delta U\\neq 0$，应用公式$\\Delta U=Q_{\\mathrm{V}}=nC_{\\mathrm{V,m}} (T_2 - T_1)=\\dfrac{p}{R}C_{\\mathrm{V,m}} (V_2-V_1)$计算。单原子分子理想气体的$C_\\mathrm{V,m}=\\dfrac{3}{2}R$。\n- $W​$，显然 $W=-\\int_{V_1}^{V_2}p_e\\mathrm{d}V=p(V_2 - V_1)​$；\n- $Q$，等压过程中的热交换量用$Q_\\mathrm{p}$表示，并且$Q_\\mathrm{p}=nC_\\mathrm{p,m}\\Delta T$或者使用$C_\\mathrm{p,m}=C_\\mathrm{V,m}+R$以及$Q=\\Delta U-W$求解。\n- $\\Delta H$，直接使用公式$\\Delta H = \\Delta U + \\Delta(pV) = nC_\\mathrm{P,m}(T_2-T_1)$\n- $\\Delta S$，等压过程对应的可逆过程为物体的可逆加热或冷却，有$\\delta Q_R=C\\mathrm{d}T=nC_\\mathrm{p,m}\\mathrm{d}T$，因此，$\\Delta S = \\int_{T_A}^{T_B} \\dfrac{nC_\\mathrm{p,m}}{T}\\mathrm{d}T=nC_\\mathrm{p,m}\\ln\\dfrac{T_{B}}{T_{A}} $，根据公式$pV=nRT$可以求出$T$，这里不再对式子进行展开；\n- $\\Delta G$，直接代入式子$\\Delta G=\\Delta H-\\Delta(TS)$即可（题目会给出气体的标准摩尔熵，结合上面的$\\Delta S$可以使用$\\Delta (TS)=T_2 n(S_m+\\Delta S) - T_1 nS_m$求出$\\Delta G$）；\n- $\\Delta A$，同$\\Delta G$，直接代入$\\Delta A=\\Delta U-\\Delta (TS)$求解。\n\n### 等容过程\n此过程满足$\\dfrac{nRT}{p}=\\mathrm{Constant}$。\n\n- $\\Delta U$，与等压过程一样，直接使用公式$\\Delta U=Q_\\mathrm{V}=nC_\\mathrm{V,m}\\Delta T$。单原子分子理想气体的$C_\\mathrm{V,m}=\\dfrac{3}{2}R $；\n- $W$，因为体积无变化，$\\mathrm{d}V=0$，故$W=\\int_{V_1}^{V_2} p\\mathrm{d}V=0$；\n- $Q$，等容过程的热交换量也成为恒容热$Q_\\mathrm{V}$，$Q_\\mathrm{V}=nC_\\mathrm{V,m}\\Delta T$；\n- $\\Delta H$，可以结合式子$pV=nRT$求出$\\Delta (pV)=nR\\Delta T$，最后代入$\\Delta H=\\Delta U-\\Delta (PV)$求出$\\Delta H$；\n- $\\Delta S$，等容过程对应的可逆过程为物体的可逆加热或冷却，有$\\delta Q_R=C\\mathrm{d}T=nC_\\mathrm{V,m}\\mathrm{d}T$，因此，$\\Delta S = \\int_{T_A}^{T_B} \\dfrac{nC_\\mathrm{V,m}}{T}\\mathrm{d}T=\\Delta S=nC_\\mathrm{V,m}\\ln\\dfrac{T_{B}}{T_{A}} $，根据公式$pV=nRT$可以求出$T$，这里不再对式子进行展开；\n- $\\Delta G$，同等压过程，因为温度发生改变，必须知道$S$的初始值才能计算出$\\Delta (TS)$，所以题目会给出或间接给出$S$，此时直接代入公式$\\Delta  G=\\Delta H-\\Delta (TS)$即可求出吉布斯自由能的变化值；\n- $\\Delta A$，与$\\Delta G$类似，仅将$\\Delta H$替换为$\\Delta U$其余不变，即可计算出亥姆霍兹自由能的变化值。\n\n### 绝热可逆过程\n这是一个非常重要的过程，可逆，满足方程$pV^\\gamma=K=\\mathrm{Constant}$，式中$\\gamma=\\dfrac{C_\\mathrm{p,m}}{C_\\mathrm{V,m}}$，对于理想气体$\\gamma=\\dfrac{5}{3}$。\n\n- $\\Delta U$，由热力学第一定律，$\\Delta U=Q+W$，$Q=0$，故$\\Delta U=W=nC_\\mathrm{V,m}\\Delta T$；\n- $Q$，绝热过程定义直接表明$Q=0$；\n- $W​$，$W=-\\int_{V_1}^{V_2}p\\mathrm{d}V = -\\int_{V_1}^{V_2}\\dfrac{K}{V^\\gamma}\\mathrm{d}V = -\\big[ \\dfrac{K}{(1-\\gamma)V^{\\gamma-1}} \\big]_{V_1}^{V_2} = -\\dfrac{K}{1-\\gamma} \\big[ \\dfrac{1}{V_2^{\\gamma-1}} - \\dfrac{1}{V_1^{\\gamma-1}} \\big] $\n   因为$p_1 V_1^\\gamma = p_2 V_2^\\gamma = K$，上式写为$ W=\\dfrac{p_2 V_2- p_1 V_1}{\\gamma -1}=\\dfrac{nR(T_2 - T_1)}{\\gamma -1}  $，又因为$\\dfrac{nR}{C_V}=\\gamma-1$，所以$W=C_V(T_2 -T_1)$\n- $\\Delta H$，计算$\\Delta H$必须知道$\\Delta (pV)$，此时没有更加简单的办法，只能分别求出$p_1$，$V_1$，$p_2$，$V_2$然后计算出$p_2 V_2 - p_1 V_1$最后代入$\\Delta H=\\Delta U +p_2 V_2 - p_1 V_1$即可求出$\\Delta H$；\n- $\\Delta S$，该过程为绝热可逆过程，$\\delta Q_R=0$，故熵变为０，即$\\Delta S=0$；\n- $\\Delta G$，该过程为变温过程，故题目会直接或间接给出$S$的初始值，然后利用$\\Delta G=\\Delta H-\\Delta (TS)=\\Delta H-S\\Delta T$计算出$\\Delta G$即可；\n- $\\Delta A$，与$\\Delta G$类似，将$\\Delta G$中的$\\Delta H$换为$\\Delta U$即可。\n\n### 环状过程\n此过程没有具体的方程，但可以多个过程组成，系统最终状态与初始状态相同。\n\n- 由于系统初始状态与终末状态相同，故**系统**中所有状态函数的变化量为零，即$\\Delta U=\\Delta H=\\Delta S=\\Delta G=\\Delta A=0$，**注意，此式子描述的是系统的热力学量，而此系统与外界有能量交换，故为非孤立体系，熵变可以为０**。\n- $W$与$Q$，计算这两个热力学量时**不能**设计过程来求，只能按照过程的具体细节，分解成容易求出$W$和$Q$的过程分别计算出两者，然后求和。\n\n以上为本渣的总结，如有纰漏，还请大神指正。\n","source":"_posts/PhysChem-Revise-1.md","raw":"---\ntitle: 物理化学复习札记（一）：理想气体热力学量求解总结\ndate: 2017-06-26 17:07:41\ntags:\n    - 物理化学\n    - 化学\ncategories: Physical Chemistry\n---\n\n\n**这是这个系列的第一篇，也是第一次写这种类型的札记，如果有纰漏，还请在评论区指出，谢谢各位！**\n\n## 热力学量说明\n物理化学中，热力学主要研究7个热力学量，这7个量如下：\n\n1. $U$，系统的热力学能，或称内能，属于状态函数，$U=f(T)$，无法求出$U$的值，但可以求出$\\Delta U$的值，单位为J；\n2. $Q$，系统与环境交换的热量，当系统放热时，$Q$为负值；系统吸热，则$Q$为正值，单位为J；\n3. $W$，环境对系统所做的功，分为体积功和非体积功，单位为J；\n4. $H$，焓，定义为 $H=U+pV$，无实际含义，仅为计算方便而产生，属于状态函数，$H=f(T)$，与$U$一样，无法求出$H$的值，但可以求出$\\Delta H$的值，单位为J；\n5. $S$，大名鼎鼎的熵，定义为$S=\\int_A^B (\\dfrac{\\delta Q}{T})_R$，属于状态函数，处于绝对零度时完美晶体的熵为0，单位J$\\cdot $K$^{-1}$\n6. $A$，亥姆霍兹自由能，定义为$A=U-TS$，为状态函数，无法求出$A$的值，但可以求出$\\Delta A$的值，单位为J；\n7. $G$，吉布斯自由能，定义为$G=H-TS$，为状态函数，无法求出$G$的值，但可以求出$\\Delta G$的值，单位为J；\n\n以上说明中，状态函数是指当系统状态一定时，其值即确定，亦即在某个过程中其变化量$\\Delta f$只与始末状态有关，与过程细节无关。这个性质**非常重要**，物理化学常见的设计过程求解热力学量的理论基础即在于此。\n\n## 热力学四大定律\n\n是的，热力学有四大定律，分别为热力学第零定律、热力学第一定律、热力学第二定律和热力学第三定律。\n\n### 热力学第零定律\n**如果两个系统分别与处于确定状态的第三个系统达到热平衡，则这两个系统彼此也将处于热平衡。**\n\n这个定律定义了温度的概念，当两个系统相互接触处于热平衡后，它们的性质不再变化，我们称之具有相同的温度。而定义中提到的第三系统为温度计的产生奠定了理论基础。\n\n### 热力学第一定律\n**在变化过程中，系统的热力学能变化量表示为系统和环境的热交换量与外界对系统所做功的总和。**\n写成公式即为 $ \\Delta U = Q + W $，\n或者写成微分形式$ \\mathrm{d}U = \\delta Q + \\delta W $\n\n### 热力学第二定律\n\n文字可表述为：\n\n> 克劳修斯表述：不可能把热从低温物体传到高温物体，而不引起其他变化；\n> 开尔文表述：不可能从单一热源取出热使之完全变为功，而不发生其他变化。\n\n数学形式：\n\n- 克劳修斯不等式表述形式：$ \\Delta S_{A\\to B}-\\sum_A^B \\dfrac{\\delta Q}{T} \\geq 0 $\n- 常用表述形式：$ \\mathrm{d}S - \\dfrac{\\delta Q}{T} \\geq 0 $\n\n\n上式表明，在一个隔离系统中，熵永不减少。 隔离系统是绝热的，即$\\delta Q=0$，因此$\\mathrm{d}S_{\\mathrm{iso}} \\geq 0$。\n\n\n### 热力学第三定律\n可以表述为**在温度趋于热力学温度0K的等温过程中，系统的熵值不变 **，也可以表述为“**在0K时，任何完美晶体的熵等于零**”，还可以表述为”**绝对零度不可能达到**“。\n\n\n## 特殊过程的热力学量求值\n\n**本节所有过程均为$p$,$V$,$T$过程，不考虑非体积功！**\n\n常见的变化过程（均为理想气体的变化过程）有：\n1. 等温过程：系统由状态1变到状态2，变化过程中以及始态和终态的温度不变，**且等于环境温度**；\n2. 等压过程：系统在变化过程中，始态和终态压力相等，且等于环境压力；\n3. 等容过程：系统在变化过程中保持体积不变。在刚性容器中发生的变化一般是等容过程；\n4. 绝热过程：系统在变化过程中与环境之间没有热的交换，或者是由于有绝热壁的存在，或者是因为变化太快而与环境来不及热交换，或者热交换量极少可近似看作是绝热过程；\n5. 环状过程：系统从始态出发，经过一系列变化后又回到了原来状态。经此过程，所有状态函数的变化量都为零。\n\n另外，自由膨胀过程可以看为外压恒为0的等压膨胀过程；节流膨胀过程属于实际气体的不可逆过程，不在本札记讨论范围内。\n\n### 自由膨胀过程\n此过程不可逆，可看作外压恒为零的等压过程。\n\n- $\\Delta U=0$，由`Gay-Lussac-Joule`实验得出，而$U=f(T)$，故此过程中气体$T$不变；\n- $W=0$，显然，自由膨胀时外压恒为零，也无非体积功，故$W=0$；\n- $Q=0$，由热力学第一定律，$\\Delta U=Q+W$，式中$\\Delta U=0$，$W=0$，因此$Q=0$；\n- $\\Delta H=0$，$H$是状态函数，由上文气体$T$不变可以推出$H$不变。 另外也可由公式$\\Delta H=\\Delta U + \\Delta(pV)$，$pV=nRT$（n、T不变，所以$pV$不变）推出$\\Delta H=0$；\n- $\\Delta S>0$，显然该过程不可逆，其对应的可逆过程为等温可逆膨胀，计算得$\\Delta S=\\int\\dfrac{\\delta Q}{T} = \\dfrac{Q}{T} = nR\\ln\\dfrac{V_2}{V_1} = -nR\\ln\\dfrac{p_2}{p_1}$；\n- $\\Delta G<0​$，由公式$\\Delta G=\\Delta H-\\Delta (TS)​$，并且$\\Delta H=0​$、$T​$不变得出$\\Delta G=-T\\Delta S​$；\n- $\\Delta A<0$，与计算$\\Delta G$的过程类似，$\\Delta A=-T\\Delta S$。\n\n### 等温可逆过程\n此过程满足 $pV=nRT=\\mathrm{Constant}$。\n\n- $\\Delta U=0$，$U$为状态函数，等温过程系统温度不变，因此$U$不变、$\\Delta U=0$；\n- $W$，由公式$W=-\\int_{V_1}^{V_2}p_{\\mathrm{e}}\\mathrm{d}V$，且$p_e=p=\\dfrac{nRT}{V}$（可逆过程中环境压力始终近似于系统压力），所以$W=-nRT\\int_{V_1}^{V^2} \\dfrac{1}{V} \\mathrm{d}V=-nRT\\ln\\dfrac{V_2}{V_1}$；此外，若已知系统的始末压力，也可以将前式变换为$W=nRT\\dfrac{p_1}{p_2}$\n- $Q$，由热力学第一定律，$\\Delta U=W+Q$，得$Q=-W=nRT\\ln\\dfrac{V_2}{V_1}$；\n- $\\Delta H$，与$U$类似，为状态函数，$\\Delta H=0$；\n- $\\Delta S$，此过程已经为可逆过程，不必再设计可逆过程。因此$\\Delta S=\\int\\dfrac{\\delta Q}{T} = \\dfrac{Q}{T} = nR\\ln\\dfrac{V_2}{V_1} = -nR\\ln\\dfrac{p_2}{p_1}$；\n- $\\Delta G$，直接代入公式$\\Delta G=\\Delta H-\\Delta(TS)$，得$\\Delta G=-nRT\\ln\\dfrac{V_2}{V_1}=nRT\\ln\\dfrac{p_2}{p_1}=W $；\n- $\\Delta A$，同$\\Delta G$，得到$\\Delta A=\\Delta G=W=-nRT\\ln\\dfrac{V_2}{V_1}=nRT\\ln\\dfrac{p_2}{p_1} $。\n\n### 等压过程\n此过程满足 $\\dfrac{nRT}{V}=\\text{Constant}$\n\n- $\\Delta U$，此时$\\Delta U\\neq 0$，应用公式$\\Delta U=Q_{\\mathrm{V}}=nC_{\\mathrm{V,m}} (T_2 - T_1)=\\dfrac{p}{R}C_{\\mathrm{V,m}} (V_2-V_1)$计算。单原子分子理想气体的$C_\\mathrm{V,m}=\\dfrac{3}{2}R$。\n- $W​$，显然 $W=-\\int_{V_1}^{V_2}p_e\\mathrm{d}V=p(V_2 - V_1)​$；\n- $Q$，等压过程中的热交换量用$Q_\\mathrm{p}$表示，并且$Q_\\mathrm{p}=nC_\\mathrm{p,m}\\Delta T$或者使用$C_\\mathrm{p,m}=C_\\mathrm{V,m}+R$以及$Q=\\Delta U-W$求解。\n- $\\Delta H$，直接使用公式$\\Delta H = \\Delta U + \\Delta(pV) = nC_\\mathrm{P,m}(T_2-T_1)$\n- $\\Delta S$，等压过程对应的可逆过程为物体的可逆加热或冷却，有$\\delta Q_R=C\\mathrm{d}T=nC_\\mathrm{p,m}\\mathrm{d}T$，因此，$\\Delta S = \\int_{T_A}^{T_B} \\dfrac{nC_\\mathrm{p,m}}{T}\\mathrm{d}T=nC_\\mathrm{p,m}\\ln\\dfrac{T_{B}}{T_{A}} $，根据公式$pV=nRT$可以求出$T$，这里不再对式子进行展开；\n- $\\Delta G$，直接代入式子$\\Delta G=\\Delta H-\\Delta(TS)$即可（题目会给出气体的标准摩尔熵，结合上面的$\\Delta S$可以使用$\\Delta (TS)=T_2 n(S_m+\\Delta S) - T_1 nS_m$求出$\\Delta G$）；\n- $\\Delta A$，同$\\Delta G$，直接代入$\\Delta A=\\Delta U-\\Delta (TS)$求解。\n\n### 等容过程\n此过程满足$\\dfrac{nRT}{p}=\\mathrm{Constant}$。\n\n- $\\Delta U$，与等压过程一样，直接使用公式$\\Delta U=Q_\\mathrm{V}=nC_\\mathrm{V,m}\\Delta T$。单原子分子理想气体的$C_\\mathrm{V,m}=\\dfrac{3}{2}R $；\n- $W$，因为体积无变化，$\\mathrm{d}V=0$，故$W=\\int_{V_1}^{V_2} p\\mathrm{d}V=0$；\n- $Q$，等容过程的热交换量也成为恒容热$Q_\\mathrm{V}$，$Q_\\mathrm{V}=nC_\\mathrm{V,m}\\Delta T$；\n- $\\Delta H$，可以结合式子$pV=nRT$求出$\\Delta (pV)=nR\\Delta T$，最后代入$\\Delta H=\\Delta U-\\Delta (PV)$求出$\\Delta H$；\n- $\\Delta S$，等容过程对应的可逆过程为物体的可逆加热或冷却，有$\\delta Q_R=C\\mathrm{d}T=nC_\\mathrm{V,m}\\mathrm{d}T$，因此，$\\Delta S = \\int_{T_A}^{T_B} \\dfrac{nC_\\mathrm{V,m}}{T}\\mathrm{d}T=\\Delta S=nC_\\mathrm{V,m}\\ln\\dfrac{T_{B}}{T_{A}} $，根据公式$pV=nRT$可以求出$T$，这里不再对式子进行展开；\n- $\\Delta G$，同等压过程，因为温度发生改变，必须知道$S$的初始值才能计算出$\\Delta (TS)$，所以题目会给出或间接给出$S$，此时直接代入公式$\\Delta  G=\\Delta H-\\Delta (TS)$即可求出吉布斯自由能的变化值；\n- $\\Delta A$，与$\\Delta G$类似，仅将$\\Delta H$替换为$\\Delta U$其余不变，即可计算出亥姆霍兹自由能的变化值。\n\n### 绝热可逆过程\n这是一个非常重要的过程，可逆，满足方程$pV^\\gamma=K=\\mathrm{Constant}$，式中$\\gamma=\\dfrac{C_\\mathrm{p,m}}{C_\\mathrm{V,m}}$，对于理想气体$\\gamma=\\dfrac{5}{3}$。\n\n- $\\Delta U$，由热力学第一定律，$\\Delta U=Q+W$，$Q=0$，故$\\Delta U=W=nC_\\mathrm{V,m}\\Delta T$；\n- $Q$，绝热过程定义直接表明$Q=0$；\n- $W​$，$W=-\\int_{V_1}^{V_2}p\\mathrm{d}V = -\\int_{V_1}^{V_2}\\dfrac{K}{V^\\gamma}\\mathrm{d}V = -\\big[ \\dfrac{K}{(1-\\gamma)V^{\\gamma-1}} \\big]_{V_1}^{V_2} = -\\dfrac{K}{1-\\gamma} \\big[ \\dfrac{1}{V_2^{\\gamma-1}} - \\dfrac{1}{V_1^{\\gamma-1}} \\big] $\n   因为$p_1 V_1^\\gamma = p_2 V_2^\\gamma = K$，上式写为$ W=\\dfrac{p_2 V_2- p_1 V_1}{\\gamma -1}=\\dfrac{nR(T_2 - T_1)}{\\gamma -1}  $，又因为$\\dfrac{nR}{C_V}=\\gamma-1$，所以$W=C_V(T_2 -T_1)$\n- $\\Delta H$，计算$\\Delta H$必须知道$\\Delta (pV)$，此时没有更加简单的办法，只能分别求出$p_1$，$V_1$，$p_2$，$V_2$然后计算出$p_2 V_2 - p_1 V_1$最后代入$\\Delta H=\\Delta U +p_2 V_2 - p_1 V_1$即可求出$\\Delta H$；\n- $\\Delta S$，该过程为绝热可逆过程，$\\delta Q_R=0$，故熵变为０，即$\\Delta S=0$；\n- $\\Delta G$，该过程为变温过程，故题目会直接或间接给出$S$的初始值，然后利用$\\Delta G=\\Delta H-\\Delta (TS)=\\Delta H-S\\Delta T$计算出$\\Delta G$即可；\n- $\\Delta A$，与$\\Delta G$类似，将$\\Delta G$中的$\\Delta H$换为$\\Delta U$即可。\n\n### 环状过程\n此过程没有具体的方程，但可以多个过程组成，系统最终状态与初始状态相同。\n\n- 由于系统初始状态与终末状态相同，故**系统**中所有状态函数的变化量为零，即$\\Delta U=\\Delta H=\\Delta S=\\Delta G=\\Delta A=0$，**注意，此式子描述的是系统的热力学量，而此系统与外界有能量交换，故为非孤立体系，熵变可以为０**。\n- $W$与$Q$，计算这两个热力学量时**不能**设计过程来求，只能按照过程的具体细节，分解成容易求出$W$和$Q$的过程分别计算出两者，然后求和。\n\n以上为本渣的总结，如有纰漏，还请大神指正。\n","slug":"PhysChem-Revise-1","published":1,"updated":"2017-09-19T14:07:58.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj7rorijr0008tcjmpubj6npw","content":"<p><strong>这是这个系列的第一篇，也是第一次写这种类型的札记，如果有纰漏，还请在评论区指出，谢谢各位！</strong></p>\n<h2 id=\"热力学量说明\"><a href=\"#热力学量说明\" class=\"headerlink\" title=\"热力学量说明\"></a>热力学量说明</h2><p>物理化学中，热力学主要研究7个热力学量，这7个量如下：</p>\n<ol>\n<li>$U$，系统的热力学能，或称内能，属于状态函数，$U=f(T)$，无法求出$U$的值，但可以求出$\\Delta U$的值，单位为J；</li>\n<li>$Q$，系统与环境交换的热量，当系统放热时，$Q$为负值；系统吸热，则$Q$为正值，单位为J；</li>\n<li>$W$，环境对系统所做的功，分为体积功和非体积功，单位为J；</li>\n<li>$H$，焓，定义为 $H=U+pV$，无实际含义，仅为计算方便而产生，属于状态函数，$H=f(T)$，与$U$一样，无法求出$H$的值，但可以求出$\\Delta H$的值，单位为J；</li>\n<li>$S$，大名鼎鼎的熵，定义为$S=\\int_A^B (\\dfrac{\\delta Q}{T})_R$，属于状态函数，处于绝对零度时完美晶体的熵为0，单位J$\\cdot $K$^{-1}$</li>\n<li>$A$，亥姆霍兹自由能，定义为$A=U-TS$，为状态函数，无法求出$A$的值，但可以求出$\\Delta A$的值，单位为J；</li>\n<li>$G$，吉布斯自由能，定义为$G=H-TS$，为状态函数，无法求出$G$的值，但可以求出$\\Delta G$的值，单位为J；</li>\n</ol>\n<p>以上说明中，状态函数是指当系统状态一定时，其值即确定，亦即在某个过程中其变化量$\\Delta f$只与始末状态有关，与过程细节无关。这个性质<strong>非常重要</strong>，物理化学常见的设计过程求解热力学量的理论基础即在于此。</p>\n<h2 id=\"热力学四大定律\"><a href=\"#热力学四大定律\" class=\"headerlink\" title=\"热力学四大定律\"></a>热力学四大定律</h2><p>是的，热力学有四大定律，分别为热力学第零定律、热力学第一定律、热力学第二定律和热力学第三定律。</p>\n<h3 id=\"热力学第零定律\"><a href=\"#热力学第零定律\" class=\"headerlink\" title=\"热力学第零定律\"></a>热力学第零定律</h3><p><strong>如果两个系统分别与处于确定状态的第三个系统达到热平衡，则这两个系统彼此也将处于热平衡。</strong></p>\n<p>这个定律定义了温度的概念，当两个系统相互接触处于热平衡后，它们的性质不再变化，我们称之具有相同的温度。而定义中提到的第三系统为温度计的产生奠定了理论基础。</p>\n<h3 id=\"热力学第一定律\"><a href=\"#热力学第一定律\" class=\"headerlink\" title=\"热力学第一定律\"></a>热力学第一定律</h3><p><strong>在变化过程中，系统的热力学能变化量表示为系统和环境的热交换量与外界对系统所做功的总和。</strong><br>写成公式即为 $ \\Delta U = Q + W $，<br>或者写成微分形式$ \\mathrm{d}U = \\delta Q + \\delta W $</p>\n<h3 id=\"热力学第二定律\"><a href=\"#热力学第二定律\" class=\"headerlink\" title=\"热力学第二定律\"></a>热力学第二定律</h3><p>文字可表述为：</p>\n<blockquote>\n<p>克劳修斯表述：不可能把热从低温物体传到高温物体，而不引起其他变化；<br>开尔文表述：不可能从单一热源取出热使之完全变为功，而不发生其他变化。</p>\n</blockquote>\n<p>数学形式：</p>\n<ul>\n<li>克劳修斯不等式表述形式：$ \\Delta S_{A\\to B}-\\sum_A^B \\dfrac{\\delta Q}{T} \\geq 0 $</li>\n<li>常用表述形式：$ \\mathrm{d}S - \\dfrac{\\delta Q}{T} \\geq 0 $</li>\n</ul>\n<p>上式表明，在一个隔离系统中，熵永不减少。 隔离系统是绝热的，即$\\delta Q=0$，因此$\\mathrm{d}S_{\\mathrm{iso}} \\geq 0$。</p>\n<h3 id=\"热力学第三定律\"><a href=\"#热力学第三定律\" class=\"headerlink\" title=\"热力学第三定律\"></a>热力学第三定律</h3><p>可以表述为<strong>在温度趋于热力学温度0K的等温过程中，系统的熵值不变 </strong>，也可以表述为“<strong>在0K时，任何完美晶体的熵等于零</strong>”，还可以表述为”<strong>绝对零度不可能达到</strong>“。</p>\n<h2 id=\"特殊过程的热力学量求值\"><a href=\"#特殊过程的热力学量求值\" class=\"headerlink\" title=\"特殊过程的热力学量求值\"></a>特殊过程的热力学量求值</h2><p><strong>本节所有过程均为$p$,$V$,$T$过程，不考虑非体积功！</strong></p>\n<p>常见的变化过程（均为理想气体的变化过程）有：</p>\n<ol>\n<li>等温过程：系统由状态1变到状态2，变化过程中以及始态和终态的温度不变，<strong>且等于环境温度</strong>；</li>\n<li>等压过程：系统在变化过程中，始态和终态压力相等，且等于环境压力；</li>\n<li>等容过程：系统在变化过程中保持体积不变。在刚性容器中发生的变化一般是等容过程；</li>\n<li>绝热过程：系统在变化过程中与环境之间没有热的交换，或者是由于有绝热壁的存在，或者是因为变化太快而与环境来不及热交换，或者热交换量极少可近似看作是绝热过程；</li>\n<li>环状过程：系统从始态出发，经过一系列变化后又回到了原来状态。经此过程，所有状态函数的变化量都为零。</li>\n</ol>\n<p>另外，自由膨胀过程可以看为外压恒为0的等压膨胀过程；节流膨胀过程属于实际气体的不可逆过程，不在本札记讨论范围内。</p>\n<h3 id=\"自由膨胀过程\"><a href=\"#自由膨胀过程\" class=\"headerlink\" title=\"自由膨胀过程\"></a>自由膨胀过程</h3><p>此过程不可逆，可看作外压恒为零的等压过程。</p>\n<ul>\n<li>$\\Delta U=0$，由<code>Gay-Lussac-Joule</code>实验得出，而$U=f(T)$，故此过程中气体$T$不变；</li>\n<li>$W=0$，显然，自由膨胀时外压恒为零，也无非体积功，故$W=0$；</li>\n<li>$Q=0$，由热力学第一定律，$\\Delta U=Q+W$，式中$\\Delta U=0$，$W=0$，因此$Q=0$；</li>\n<li>$\\Delta H=0$，$H$是状态函数，由上文气体$T$不变可以推出$H$不变。 另外也可由公式$\\Delta H=\\Delta U + \\Delta(pV)$，$pV=nRT$（n、T不变，所以$pV$不变）推出$\\Delta H=0$；</li>\n<li>$\\Delta S&gt;0$，显然该过程不可逆，其对应的可逆过程为等温可逆膨胀，计算得$\\Delta S=\\int\\dfrac{\\delta Q}{T} = \\dfrac{Q}{T} = nR\\ln\\dfrac{V_2}{V_1} = -nR\\ln\\dfrac{p_2}{p_1}$；</li>\n<li>$\\Delta G&lt;0​$，由公式$\\Delta G=\\Delta H-\\Delta (TS)​$，并且$\\Delta H=0​$、$T​$不变得出$\\Delta G=-T\\Delta S​$；</li>\n<li>$\\Delta A&lt;0$，与计算$\\Delta G$的过程类似，$\\Delta A=-T\\Delta S$。</li>\n</ul>\n<h3 id=\"等温可逆过程\"><a href=\"#等温可逆过程\" class=\"headerlink\" title=\"等温可逆过程\"></a>等温可逆过程</h3><p>此过程满足 $pV=nRT=\\mathrm{Constant}$。</p>\n<ul>\n<li>$\\Delta U=0$，$U$为状态函数，等温过程系统温度不变，因此$U$不变、$\\Delta U=0$；</li>\n<li>$W$，由公式$W=-\\int<em>{V_1}^{V_2}p</em>{\\mathrm{e}}\\mathrm{d}V$，且$p<em>e=p=\\dfrac{nRT}{V}$（可逆过程中环境压力始终近似于系统压力），所以$W=-nRT\\int</em>{V_1}^{V^2} \\dfrac{1}{V} \\mathrm{d}V=-nRT\\ln\\dfrac{V_2}{V_1}$；此外，若已知系统的始末压力，也可以将前式变换为$W=nRT\\dfrac{p_1}{p_2}$</li>\n<li>$Q$，由热力学第一定律，$\\Delta U=W+Q$，得$Q=-W=nRT\\ln\\dfrac{V_2}{V_1}$；</li>\n<li>$\\Delta H$，与$U$类似，为状态函数，$\\Delta H=0$；</li>\n<li>$\\Delta S$，此过程已经为可逆过程，不必再设计可逆过程。因此$\\Delta S=\\int\\dfrac{\\delta Q}{T} = \\dfrac{Q}{T} = nR\\ln\\dfrac{V_2}{V_1} = -nR\\ln\\dfrac{p_2}{p_1}$；</li>\n<li>$\\Delta G$，直接代入公式$\\Delta G=\\Delta H-\\Delta(TS)$，得$\\Delta G=-nRT\\ln\\dfrac{V_2}{V_1}=nRT\\ln\\dfrac{p_2}{p_1}=W $；</li>\n<li>$\\Delta A$，同$\\Delta G$，得到$\\Delta A=\\Delta G=W=-nRT\\ln\\dfrac{V_2}{V_1}=nRT\\ln\\dfrac{p_2}{p_1} $。</li>\n</ul>\n<h3 id=\"等压过程\"><a href=\"#等压过程\" class=\"headerlink\" title=\"等压过程\"></a>等压过程</h3><p>此过程满足 $\\dfrac{nRT}{V}=\\text{Constant}$</p>\n<ul>\n<li>$\\Delta U$，此时$\\Delta U\\neq 0$，应用公式$\\Delta U=Q<em>{\\mathrm{V}}=nC</em>{\\mathrm{V,m}} (T<em>2 - T_1)=\\dfrac{p}{R}C</em>{\\mathrm{V,m}} (V<em>2-V_1)$计算。单原子分子理想气体的$C</em>\\mathrm{V,m}=\\dfrac{3}{2}R$。</li>\n<li>$W​$，显然 $W=-\\int_{V_1}^{V_2}p_e\\mathrm{d}V=p(V_2 - V_1)​$；</li>\n<li>$Q$，等压过程中的热交换量用$Q<em>\\mathrm{p}$表示，并且$Q</em>\\mathrm{p}=nC<em>\\mathrm{p,m}\\Delta T$或者使用$C</em>\\mathrm{p,m}=C_\\mathrm{V,m}+R$以及$Q=\\Delta U-W$求解。</li>\n<li>$\\Delta H$，直接使用公式$\\Delta H = \\Delta U + \\Delta(pV) = nC_\\mathrm{P,m}(T_2-T_1)$</li>\n<li>$\\Delta S$，等压过程对应的可逆过程为物体的可逆加热或冷却，有$\\delta Q<em>R=C\\mathrm{d}T=nC</em>\\mathrm{p,m}\\mathrm{d}T$，因此，$\\Delta S = \\int<em>{T_A}^{T_B} \\dfrac{nC</em>\\mathrm{p,m}}{T}\\mathrm{d}T=nC<em>\\mathrm{p,m}\\ln\\dfrac{T</em>{B}}{T_{A}} $，根据公式$pV=nRT$可以求出$T$，这里不再对式子进行展开；</li>\n<li>$\\Delta G$，直接代入式子$\\Delta G=\\Delta H-\\Delta(TS)$即可（题目会给出气体的标准摩尔熵，结合上面的$\\Delta S$可以使用$\\Delta (TS)=T_2 n(S_m+\\Delta S) - T_1 nS_m$求出$\\Delta G$）；</li>\n<li>$\\Delta A$，同$\\Delta G$，直接代入$\\Delta A=\\Delta U-\\Delta (TS)$求解。</li>\n</ul>\n<h3 id=\"等容过程\"><a href=\"#等容过程\" class=\"headerlink\" title=\"等容过程\"></a>等容过程</h3><p>此过程满足$\\dfrac{nRT}{p}=\\mathrm{Constant}$。</p>\n<ul>\n<li>$\\Delta U$，与等压过程一样，直接使用公式$\\Delta U=Q<em>\\mathrm{V}=nC</em>\\mathrm{V,m}\\Delta T$。单原子分子理想气体的$C_\\mathrm{V,m}=\\dfrac{3}{2}R $；</li>\n<li>$W$，因为体积无变化，$\\mathrm{d}V=0$，故$W=\\int_{V_1}^{V_2} p\\mathrm{d}V=0$；</li>\n<li>$Q$，等容过程的热交换量也成为恒容热$Q<em>\\mathrm{V}$，$Q</em>\\mathrm{V}=nC_\\mathrm{V,m}\\Delta T$；</li>\n<li>$\\Delta H$，可以结合式子$pV=nRT$求出$\\Delta (pV)=nR\\Delta T$，最后代入$\\Delta H=\\Delta U-\\Delta (PV)$求出$\\Delta H$；</li>\n<li>$\\Delta S$，等容过程对应的可逆过程为物体的可逆加热或冷却，有$\\delta Q<em>R=C\\mathrm{d}T=nC</em>\\mathrm{V,m}\\mathrm{d}T$，因此，$\\Delta S = \\int<em>{T_A}^{T_B} \\dfrac{nC</em>\\mathrm{V,m}}{T}\\mathrm{d}T=\\Delta S=nC<em>\\mathrm{V,m}\\ln\\dfrac{T</em>{B}}{T_{A}} $，根据公式$pV=nRT$可以求出$T$，这里不再对式子进行展开；</li>\n<li>$\\Delta G$，同等压过程，因为温度发生改变，必须知道$S$的初始值才能计算出$\\Delta (TS)$，所以题目会给出或间接给出$S$，此时直接代入公式$\\Delta  G=\\Delta H-\\Delta (TS)$即可求出吉布斯自由能的变化值；</li>\n<li>$\\Delta A$，与$\\Delta G$类似，仅将$\\Delta H$替换为$\\Delta U$其余不变，即可计算出亥姆霍兹自由能的变化值。</li>\n</ul>\n<h3 id=\"绝热可逆过程\"><a href=\"#绝热可逆过程\" class=\"headerlink\" title=\"绝热可逆过程\"></a>绝热可逆过程</h3><p>这是一个非常重要的过程，可逆，满足方程$pV^\\gamma=K=\\mathrm{Constant}$，式中$\\gamma=\\dfrac{C<em>\\mathrm{p,m}}{C</em>\\mathrm{V,m}}$，对于理想气体$\\gamma=\\dfrac{5}{3}$。</p>\n<ul>\n<li>$\\Delta U$，由热力学第一定律，$\\Delta U=Q+W$，$Q=0$，故$\\Delta U=W=nC_\\mathrm{V,m}\\Delta T$；</li>\n<li>$Q$，绝热过程定义直接表明$Q=0$；</li>\n<li>$W​$，$W=-\\int<em>{V_1}^{V_2}p\\mathrm{d}V = -\\int</em>{V<em>1}^{V_2}\\dfrac{K}{V^\\gamma}\\mathrm{d}V = -\\big[ \\dfrac{K}{(1-\\gamma)V^{\\gamma-1}} \\big]</em>{V_1}^{V_2} = -\\dfrac{K}{1-\\gamma} \\big[ \\dfrac{1}{V_2^{\\gamma-1}} - \\dfrac{1}{V_1^{\\gamma-1}} \\big] $<br> 因为$p_1 V_1^\\gamma = p_2 V_2^\\gamma = K$，上式写为$ W=\\dfrac{p_2 V_2- p_1 V_1}{\\gamma -1}=\\dfrac{nR(T_2 - T_1)}{\\gamma -1}  $，又因为$\\dfrac{nR}{C_V}=\\gamma-1$，所以$W=C_V(T_2 -T_1)$</li>\n<li>$\\Delta H$，计算$\\Delta H$必须知道$\\Delta (pV)$，此时没有更加简单的办法，只能分别求出$p_1$，$V_1$，$p_2$，$V_2$然后计算出$p_2 V_2 - p_1 V_1$最后代入$\\Delta H=\\Delta U +p_2 V_2 - p_1 V_1$即可求出$\\Delta H$；</li>\n<li>$\\Delta S$，该过程为绝热可逆过程，$\\delta Q_R=0$，故熵变为０，即$\\Delta S=0$；</li>\n<li>$\\Delta G$，该过程为变温过程，故题目会直接或间接给出$S$的初始值，然后利用$\\Delta G=\\Delta H-\\Delta (TS)=\\Delta H-S\\Delta T$计算出$\\Delta G$即可；</li>\n<li>$\\Delta A$，与$\\Delta G$类似，将$\\Delta G$中的$\\Delta H$换为$\\Delta U$即可。</li>\n</ul>\n<h3 id=\"环状过程\"><a href=\"#环状过程\" class=\"headerlink\" title=\"环状过程\"></a>环状过程</h3><p>此过程没有具体的方程，但可以多个过程组成，系统最终状态与初始状态相同。</p>\n<ul>\n<li>由于系统初始状态与终末状态相同，故<strong>系统</strong>中所有状态函数的变化量为零，即$\\Delta U=\\Delta H=\\Delta S=\\Delta G=\\Delta A=0$，<strong>注意，此式子描述的是系统的热力学量，而此系统与外界有能量交换，故为非孤立体系，熵变可以为０</strong>。</li>\n<li>$W$与$Q$，计算这两个热力学量时<strong>不能</strong>设计过程来求，只能按照过程的具体细节，分解成容易求出$W$和$Q$的过程分别计算出两者，然后求和。</li>\n</ul>\n<p>以上为本渣的总结，如有纰漏，还请大神指正。</p>\n","site":{"data":{}},"excerpt":"","more":"<p><strong>这是这个系列的第一篇，也是第一次写这种类型的札记，如果有纰漏，还请在评论区指出，谢谢各位！</strong></p>\n<h2 id=\"热力学量说明\"><a href=\"#热力学量说明\" class=\"headerlink\" title=\"热力学量说明\"></a>热力学量说明</h2><p>物理化学中，热力学主要研究7个热力学量，这7个量如下：</p>\n<ol>\n<li>$U$，系统的热力学能，或称内能，属于状态函数，$U=f(T)$，无法求出$U$的值，但可以求出$\\Delta U$的值，单位为J；</li>\n<li>$Q$，系统与环境交换的热量，当系统放热时，$Q$为负值；系统吸热，则$Q$为正值，单位为J；</li>\n<li>$W$，环境对系统所做的功，分为体积功和非体积功，单位为J；</li>\n<li>$H$，焓，定义为 $H=U+pV$，无实际含义，仅为计算方便而产生，属于状态函数，$H=f(T)$，与$U$一样，无法求出$H$的值，但可以求出$\\Delta H$的值，单位为J；</li>\n<li>$S$，大名鼎鼎的熵，定义为$S=\\int_A^B (\\dfrac{\\delta Q}{T})_R$，属于状态函数，处于绝对零度时完美晶体的熵为0，单位J$\\cdot $K$^{-1}$</li>\n<li>$A$，亥姆霍兹自由能，定义为$A=U-TS$，为状态函数，无法求出$A$的值，但可以求出$\\Delta A$的值，单位为J；</li>\n<li>$G$，吉布斯自由能，定义为$G=H-TS$，为状态函数，无法求出$G$的值，但可以求出$\\Delta G$的值，单位为J；</li>\n</ol>\n<p>以上说明中，状态函数是指当系统状态一定时，其值即确定，亦即在某个过程中其变化量$\\Delta f$只与始末状态有关，与过程细节无关。这个性质<strong>非常重要</strong>，物理化学常见的设计过程求解热力学量的理论基础即在于此。</p>\n<h2 id=\"热力学四大定律\"><a href=\"#热力学四大定律\" class=\"headerlink\" title=\"热力学四大定律\"></a>热力学四大定律</h2><p>是的，热力学有四大定律，分别为热力学第零定律、热力学第一定律、热力学第二定律和热力学第三定律。</p>\n<h3 id=\"热力学第零定律\"><a href=\"#热力学第零定律\" class=\"headerlink\" title=\"热力学第零定律\"></a>热力学第零定律</h3><p><strong>如果两个系统分别与处于确定状态的第三个系统达到热平衡，则这两个系统彼此也将处于热平衡。</strong></p>\n<p>这个定律定义了温度的概念，当两个系统相互接触处于热平衡后，它们的性质不再变化，我们称之具有相同的温度。而定义中提到的第三系统为温度计的产生奠定了理论基础。</p>\n<h3 id=\"热力学第一定律\"><a href=\"#热力学第一定律\" class=\"headerlink\" title=\"热力学第一定律\"></a>热力学第一定律</h3><p><strong>在变化过程中，系统的热力学能变化量表示为系统和环境的热交换量与外界对系统所做功的总和。</strong><br>写成公式即为 $ \\Delta U = Q + W $，<br>或者写成微分形式$ \\mathrm{d}U = \\delta Q + \\delta W $</p>\n<h3 id=\"热力学第二定律\"><a href=\"#热力学第二定律\" class=\"headerlink\" title=\"热力学第二定律\"></a>热力学第二定律</h3><p>文字可表述为：</p>\n<blockquote>\n<p>克劳修斯表述：不可能把热从低温物体传到高温物体，而不引起其他变化；<br>开尔文表述：不可能从单一热源取出热使之完全变为功，而不发生其他变化。</p>\n</blockquote>\n<p>数学形式：</p>\n<ul>\n<li>克劳修斯不等式表述形式：$ \\Delta S_{A\\to B}-\\sum_A^B \\dfrac{\\delta Q}{T} \\geq 0 $</li>\n<li>常用表述形式：$ \\mathrm{d}S - \\dfrac{\\delta Q}{T} \\geq 0 $</li>\n</ul>\n<p>上式表明，在一个隔离系统中，熵永不减少。 隔离系统是绝热的，即$\\delta Q=0$，因此$\\mathrm{d}S_{\\mathrm{iso}} \\geq 0$。</p>\n<h3 id=\"热力学第三定律\"><a href=\"#热力学第三定律\" class=\"headerlink\" title=\"热力学第三定律\"></a>热力学第三定律</h3><p>可以表述为<strong>在温度趋于热力学温度0K的等温过程中，系统的熵值不变 </strong>，也可以表述为“<strong>在0K时，任何完美晶体的熵等于零</strong>”，还可以表述为”<strong>绝对零度不可能达到</strong>“。</p>\n<h2 id=\"特殊过程的热力学量求值\"><a href=\"#特殊过程的热力学量求值\" class=\"headerlink\" title=\"特殊过程的热力学量求值\"></a>特殊过程的热力学量求值</h2><p><strong>本节所有过程均为$p$,$V$,$T$过程，不考虑非体积功！</strong></p>\n<p>常见的变化过程（均为理想气体的变化过程）有：</p>\n<ol>\n<li>等温过程：系统由状态1变到状态2，变化过程中以及始态和终态的温度不变，<strong>且等于环境温度</strong>；</li>\n<li>等压过程：系统在变化过程中，始态和终态压力相等，且等于环境压力；</li>\n<li>等容过程：系统在变化过程中保持体积不变。在刚性容器中发生的变化一般是等容过程；</li>\n<li>绝热过程：系统在变化过程中与环境之间没有热的交换，或者是由于有绝热壁的存在，或者是因为变化太快而与环境来不及热交换，或者热交换量极少可近似看作是绝热过程；</li>\n<li>环状过程：系统从始态出发，经过一系列变化后又回到了原来状态。经此过程，所有状态函数的变化量都为零。</li>\n</ol>\n<p>另外，自由膨胀过程可以看为外压恒为0的等压膨胀过程；节流膨胀过程属于实际气体的不可逆过程，不在本札记讨论范围内。</p>\n<h3 id=\"自由膨胀过程\"><a href=\"#自由膨胀过程\" class=\"headerlink\" title=\"自由膨胀过程\"></a>自由膨胀过程</h3><p>此过程不可逆，可看作外压恒为零的等压过程。</p>\n<ul>\n<li>$\\Delta U=0$，由<code>Gay-Lussac-Joule</code>实验得出，而$U=f(T)$，故此过程中气体$T$不变；</li>\n<li>$W=0$，显然，自由膨胀时外压恒为零，也无非体积功，故$W=0$；</li>\n<li>$Q=0$，由热力学第一定律，$\\Delta U=Q+W$，式中$\\Delta U=0$，$W=0$，因此$Q=0$；</li>\n<li>$\\Delta H=0$，$H$是状态函数，由上文气体$T$不变可以推出$H$不变。 另外也可由公式$\\Delta H=\\Delta U + \\Delta(pV)$，$pV=nRT$（n、T不变，所以$pV$不变）推出$\\Delta H=0$；</li>\n<li>$\\Delta S&gt;0$，显然该过程不可逆，其对应的可逆过程为等温可逆膨胀，计算得$\\Delta S=\\int\\dfrac{\\delta Q}{T} = \\dfrac{Q}{T} = nR\\ln\\dfrac{V_2}{V_1} = -nR\\ln\\dfrac{p_2}{p_1}$；</li>\n<li>$\\Delta G&lt;0​$，由公式$\\Delta G=\\Delta H-\\Delta (TS)​$，并且$\\Delta H=0​$、$T​$不变得出$\\Delta G=-T\\Delta S​$；</li>\n<li>$\\Delta A&lt;0$，与计算$\\Delta G$的过程类似，$\\Delta A=-T\\Delta S$。</li>\n</ul>\n<h3 id=\"等温可逆过程\"><a href=\"#等温可逆过程\" class=\"headerlink\" title=\"等温可逆过程\"></a>等温可逆过程</h3><p>此过程满足 $pV=nRT=\\mathrm{Constant}$。</p>\n<ul>\n<li>$\\Delta U=0$，$U$为状态函数，等温过程系统温度不变，因此$U$不变、$\\Delta U=0$；</li>\n<li>$W$，由公式$W=-\\int<em>{V_1}^{V_2}p</em>{\\mathrm{e}}\\mathrm{d}V$，且$p<em>e=p=\\dfrac{nRT}{V}$（可逆过程中环境压力始终近似于系统压力），所以$W=-nRT\\int</em>{V_1}^{V^2} \\dfrac{1}{V} \\mathrm{d}V=-nRT\\ln\\dfrac{V_2}{V_1}$；此外，若已知系统的始末压力，也可以将前式变换为$W=nRT\\dfrac{p_1}{p_2}$</li>\n<li>$Q$，由热力学第一定律，$\\Delta U=W+Q$，得$Q=-W=nRT\\ln\\dfrac{V_2}{V_1}$；</li>\n<li>$\\Delta H$，与$U$类似，为状态函数，$\\Delta H=0$；</li>\n<li>$\\Delta S$，此过程已经为可逆过程，不必再设计可逆过程。因此$\\Delta S=\\int\\dfrac{\\delta Q}{T} = \\dfrac{Q}{T} = nR\\ln\\dfrac{V_2}{V_1} = -nR\\ln\\dfrac{p_2}{p_1}$；</li>\n<li>$\\Delta G$，直接代入公式$\\Delta G=\\Delta H-\\Delta(TS)$，得$\\Delta G=-nRT\\ln\\dfrac{V_2}{V_1}=nRT\\ln\\dfrac{p_2}{p_1}=W $；</li>\n<li>$\\Delta A$，同$\\Delta G$，得到$\\Delta A=\\Delta G=W=-nRT\\ln\\dfrac{V_2}{V_1}=nRT\\ln\\dfrac{p_2}{p_1} $。</li>\n</ul>\n<h3 id=\"等压过程\"><a href=\"#等压过程\" class=\"headerlink\" title=\"等压过程\"></a>等压过程</h3><p>此过程满足 $\\dfrac{nRT}{V}=\\text{Constant}$</p>\n<ul>\n<li>$\\Delta U$，此时$\\Delta U\\neq 0$，应用公式$\\Delta U=Q<em>{\\mathrm{V}}=nC</em>{\\mathrm{V,m}} (T<em>2 - T_1)=\\dfrac{p}{R}C</em>{\\mathrm{V,m}} (V<em>2-V_1)$计算。单原子分子理想气体的$C</em>\\mathrm{V,m}=\\dfrac{3}{2}R$。</li>\n<li>$W​$，显然 $W=-\\int_{V_1}^{V_2}p_e\\mathrm{d}V=p(V_2 - V_1)​$；</li>\n<li>$Q$，等压过程中的热交换量用$Q<em>\\mathrm{p}$表示，并且$Q</em>\\mathrm{p}=nC<em>\\mathrm{p,m}\\Delta T$或者使用$C</em>\\mathrm{p,m}=C_\\mathrm{V,m}+R$以及$Q=\\Delta U-W$求解。</li>\n<li>$\\Delta H$，直接使用公式$\\Delta H = \\Delta U + \\Delta(pV) = nC_\\mathrm{P,m}(T_2-T_1)$</li>\n<li>$\\Delta S$，等压过程对应的可逆过程为物体的可逆加热或冷却，有$\\delta Q<em>R=C\\mathrm{d}T=nC</em>\\mathrm{p,m}\\mathrm{d}T$，因此，$\\Delta S = \\int<em>{T_A}^{T_B} \\dfrac{nC</em>\\mathrm{p,m}}{T}\\mathrm{d}T=nC<em>\\mathrm{p,m}\\ln\\dfrac{T</em>{B}}{T_{A}} $，根据公式$pV=nRT$可以求出$T$，这里不再对式子进行展开；</li>\n<li>$\\Delta G$，直接代入式子$\\Delta G=\\Delta H-\\Delta(TS)$即可（题目会给出气体的标准摩尔熵，结合上面的$\\Delta S$可以使用$\\Delta (TS)=T_2 n(S_m+\\Delta S) - T_1 nS_m$求出$\\Delta G$）；</li>\n<li>$\\Delta A$，同$\\Delta G$，直接代入$\\Delta A=\\Delta U-\\Delta (TS)$求解。</li>\n</ul>\n<h3 id=\"等容过程\"><a href=\"#等容过程\" class=\"headerlink\" title=\"等容过程\"></a>等容过程</h3><p>此过程满足$\\dfrac{nRT}{p}=\\mathrm{Constant}$。</p>\n<ul>\n<li>$\\Delta U$，与等压过程一样，直接使用公式$\\Delta U=Q<em>\\mathrm{V}=nC</em>\\mathrm{V,m}\\Delta T$。单原子分子理想气体的$C_\\mathrm{V,m}=\\dfrac{3}{2}R $；</li>\n<li>$W$，因为体积无变化，$\\mathrm{d}V=0$，故$W=\\int_{V_1}^{V_2} p\\mathrm{d}V=0$；</li>\n<li>$Q$，等容过程的热交换量也成为恒容热$Q<em>\\mathrm{V}$，$Q</em>\\mathrm{V}=nC_\\mathrm{V,m}\\Delta T$；</li>\n<li>$\\Delta H$，可以结合式子$pV=nRT$求出$\\Delta (pV)=nR\\Delta T$，最后代入$\\Delta H=\\Delta U-\\Delta (PV)$求出$\\Delta H$；</li>\n<li>$\\Delta S$，等容过程对应的可逆过程为物体的可逆加热或冷却，有$\\delta Q<em>R=C\\mathrm{d}T=nC</em>\\mathrm{V,m}\\mathrm{d}T$，因此，$\\Delta S = \\int<em>{T_A}^{T_B} \\dfrac{nC</em>\\mathrm{V,m}}{T}\\mathrm{d}T=\\Delta S=nC<em>\\mathrm{V,m}\\ln\\dfrac{T</em>{B}}{T_{A}} $，根据公式$pV=nRT$可以求出$T$，这里不再对式子进行展开；</li>\n<li>$\\Delta G$，同等压过程，因为温度发生改变，必须知道$S$的初始值才能计算出$\\Delta (TS)$，所以题目会给出或间接给出$S$，此时直接代入公式$\\Delta  G=\\Delta H-\\Delta (TS)$即可求出吉布斯自由能的变化值；</li>\n<li>$\\Delta A$，与$\\Delta G$类似，仅将$\\Delta H$替换为$\\Delta U$其余不变，即可计算出亥姆霍兹自由能的变化值。</li>\n</ul>\n<h3 id=\"绝热可逆过程\"><a href=\"#绝热可逆过程\" class=\"headerlink\" title=\"绝热可逆过程\"></a>绝热可逆过程</h3><p>这是一个非常重要的过程，可逆，满足方程$pV^\\gamma=K=\\mathrm{Constant}$，式中$\\gamma=\\dfrac{C<em>\\mathrm{p,m}}{C</em>\\mathrm{V,m}}$，对于理想气体$\\gamma=\\dfrac{5}{3}$。</p>\n<ul>\n<li>$\\Delta U$，由热力学第一定律，$\\Delta U=Q+W$，$Q=0$，故$\\Delta U=W=nC_\\mathrm{V,m}\\Delta T$；</li>\n<li>$Q$，绝热过程定义直接表明$Q=0$；</li>\n<li>$W​$，$W=-\\int<em>{V_1}^{V_2}p\\mathrm{d}V = -\\int</em>{V<em>1}^{V_2}\\dfrac{K}{V^\\gamma}\\mathrm{d}V = -\\big[ \\dfrac{K}{(1-\\gamma)V^{\\gamma-1}} \\big]</em>{V_1}^{V_2} = -\\dfrac{K}{1-\\gamma} \\big[ \\dfrac{1}{V_2^{\\gamma-1}} - \\dfrac{1}{V_1^{\\gamma-1}} \\big] $<br> 因为$p_1 V_1^\\gamma = p_2 V_2^\\gamma = K$，上式写为$ W=\\dfrac{p_2 V_2- p_1 V_1}{\\gamma -1}=\\dfrac{nR(T_2 - T_1)}{\\gamma -1}  $，又因为$\\dfrac{nR}{C_V}=\\gamma-1$，所以$W=C_V(T_2 -T_1)$</li>\n<li>$\\Delta H$，计算$\\Delta H$必须知道$\\Delta (pV)$，此时没有更加简单的办法，只能分别求出$p_1$，$V_1$，$p_2$，$V_2$然后计算出$p_2 V_2 - p_1 V_1$最后代入$\\Delta H=\\Delta U +p_2 V_2 - p_1 V_1$即可求出$\\Delta H$；</li>\n<li>$\\Delta S$，该过程为绝热可逆过程，$\\delta Q_R=0$，故熵变为０，即$\\Delta S=0$；</li>\n<li>$\\Delta G$，该过程为变温过程，故题目会直接或间接给出$S$的初始值，然后利用$\\Delta G=\\Delta H-\\Delta (TS)=\\Delta H-S\\Delta T$计算出$\\Delta G$即可；</li>\n<li>$\\Delta A$，与$\\Delta G$类似，将$\\Delta G$中的$\\Delta H$换为$\\Delta U$即可。</li>\n</ul>\n<h3 id=\"环状过程\"><a href=\"#环状过程\" class=\"headerlink\" title=\"环状过程\"></a>环状过程</h3><p>此过程没有具体的方程，但可以多个过程组成，系统最终状态与初始状态相同。</p>\n<ul>\n<li>由于系统初始状态与终末状态相同，故<strong>系统</strong>中所有状态函数的变化量为零，即$\\Delta U=\\Delta H=\\Delta S=\\Delta G=\\Delta A=0$，<strong>注意，此式子描述的是系统的热力学量，而此系统与外界有能量交换，故为非孤立体系，熵变可以为０</strong>。</li>\n<li>$W$与$Q$，计算这两个热力学量时<strong>不能</strong>设计过程来求，只能按照过程的具体细节，分解成容易求出$W$和$Q$的过程分别计算出两者，然后求和。</li>\n</ul>\n<p>以上为本渣的总结，如有纰漏，还请大神指正。</p>\n"}],"PostAsset":[{"_id":"source/_posts/Coriolis-Force/fig6_1.png","slug":"fig6_1.png","post":"cj7rorijj0002tcjmjyn3m4ax","modified":1,"renderable":0},{"_id":"source/_posts/Coriolis-Force/Sagiri.jpg","post":"cj7rorijj0002tcjmjyn3m4ax","slug":"Sagiri.jpg","modified":1,"renderable":1},{"_id":"source/_posts/Coriolis-Force/animated.gif","slug":"animated.gif","post":"cj7rorijj0002tcjmjyn3m4ax","modified":1,"renderable":0},{"_id":"source/_posts/Coriolis-Force/fig1.ggb","post":"cj7rorijj0002tcjmjyn3m4ax","slug":"fig1.ggb","modified":1,"renderable":1},{"_id":"source/_posts/Coriolis-Force/fig1.png","post":"cj7rorijj0002tcjmjyn3m4ax","slug":"fig1.png","modified":1,"renderable":1},{"_id":"source/_posts/Coriolis-Force/fig2.ggb","post":"cj7rorijj0002tcjmjyn3m4ax","slug":"fig2.ggb","modified":1,"renderable":1},{"_id":"source/_posts/Coriolis-Force/fig2.png","post":"cj7rorijj0002tcjmjyn3m4ax","slug":"fig2.png","modified":1,"renderable":1},{"_id":"source/_posts/Coriolis-Force/fig2.svg","post":"cj7rorijj0002tcjmjyn3m4ax","slug":"fig2.svg","modified":1,"renderable":1},{"_id":"source/_posts/Coriolis-Force/fig3.ggb","post":"cj7rorijj0002tcjmjyn3m4ax","slug":"fig3.ggb","modified":1,"renderable":1},{"_id":"source/_posts/Coriolis-Force/fig3.png","post":"cj7rorijj0002tcjmjyn3m4ax","slug":"fig3.png","modified":1,"renderable":1},{"_id":"source/_posts/Coriolis-Force/fig4.ggb","post":"cj7rorijj0002tcjmjyn3m4ax","slug":"fig4.ggb","modified":1,"renderable":1},{"_id":"source/_posts/Coriolis-Force/fig4.png","post":"cj7rorijj0002tcjmjyn3m4ax","slug":"fig4.png","modified":1,"renderable":1},{"_id":"source/_posts/Coriolis-Force/fig5.ggb","post":"cj7rorijj0002tcjmjyn3m4ax","slug":"fig5.ggb","modified":1,"renderable":1},{"_id":"source/_posts/Coriolis-Force/fig5.gif","slug":"fig5.gif","post":"cj7rorijj0002tcjmjyn3m4ax","modified":1,"renderable":0},{"_id":"source/_posts/Coriolis-Force/fig5.png","post":"cj7rorijj0002tcjmjyn3m4ax","slug":"fig5.png","modified":1,"renderable":1},{"_id":"source/_posts/Coriolis-Force/fig6.ggb","post":"cj7rorijj0002tcjmjyn3m4ax","slug":"fig6.ggb","modified":1,"renderable":1},{"_id":"source/_posts/Coriolis-Force/fig6_2.pdf","post":"cj7rorijj0002tcjmjyn3m4ax","slug":"fig6_2.pdf","modified":1,"renderable":1},{"_id":"source/_posts/Coriolis-Force/fig6_2.svg","post":"cj7rorijj0002tcjmjyn3m4ax","slug":"fig6_2.svg","modified":1,"renderable":1},{"_id":"source/_posts/Coriolis-Force/fig6_3.pdf","post":"cj7rorijj0002tcjmjyn3m4ax","slug":"fig6_3.pdf","modified":1,"renderable":1},{"_id":"source/_posts/Coriolis-Force/fig6_3.svg","post":"cj7rorijj0002tcjmjyn3m4ax","slug":"fig6_3.svg","modified":1,"renderable":1},{"_id":"source/_posts/Quantum-Physics-Learning-Log-1/fig.svg","post":"cj7rorijq0007tcjm4hqcxm0p","slug":"fig.svg","modified":1,"renderable":1}],"PostCategory":[{"post_id":"cj7rorijq0007tcjm4hqcxm0p","category_id":"cj7rorijl0004tcjmzhrw4kxp","_id":"cj7rorijt000ctcjmko360t7b"},{"post_id":"cj7rorijf0000tcjmvgd89yxv","category_id":"cj7rorijl0004tcjmzhrw4kxp","_id":"cj7roriju000ftcjmig8qdq8c"},{"post_id":"cj7rorijj0002tcjmjyn3m4ax","category_id":"cj7rorijs0009tcjmezl6l7k3","_id":"cj7roriju000gtcjmd3su5ywu"},{"post_id":"cj7rorijn0006tcjmg9y4nzmw","category_id":"cj7roriju000dtcjmp7ufr5lo","_id":"cj7rorijv000jtcjmnpititzw"},{"post_id":"cj7rorijr0008tcjmpubj6npw","category_id":"cj7roriju000htcjmascbhlwu","_id":"cj7rorijv000mtcjm5tvdzwzv"}],"PostTag":[{"post_id":"cj7rorijf0000tcjmvgd89yxv","tag_id":"cj7rorijn0005tcjmpjfa1sri","_id":"cj7rorijs000btcjmc04a8cpq"},{"post_id":"cj7rorijj0002tcjmjyn3m4ax","tag_id":"cj7rorijs000atcjm1a06omuo","_id":"cj7rorijv000ltcjmxftm7rzo"},{"post_id":"cj7rorijj0002tcjmjyn3m4ax","tag_id":"cj7roriju000etcjm23hu48bo","_id":"cj7rorijv000ntcjm9jpv2w0l"},{"post_id":"cj7rorijj0002tcjmjyn3m4ax","tag_id":"cj7roriju000itcjmyv6fri79","_id":"cj7rorijw000ptcjmmr6yr0g8"},{"post_id":"cj7rorijn0006tcjmg9y4nzmw","tag_id":"cj7rorijv000ktcjm1j4zq8m3","_id":"cj7rorijw000stcjmaax64oa9"},{"post_id":"cj7rorijn0006tcjmg9y4nzmw","tag_id":"cj7rorijv000otcjmd6mm16k2","_id":"cj7rorijx000ttcjmsvb382m9"},{"post_id":"cj7rorijn0006tcjmg9y4nzmw","tag_id":"cj7rorijw000qtcjmqao7lzus","_id":"cj7rorijx000vtcjm6zlhs1ox"},{"post_id":"cj7rorijq0007tcjm4hqcxm0p","tag_id":"cj7rorijn0005tcjmpjfa1sri","_id":"cj7rorijx000xtcjmi7c86n8p"},{"post_id":"cj7rorijq0007tcjm4hqcxm0p","tag_id":"cj7rorijw000rtcjm596flhs6","_id":"cj7rorijx000ytcjmad5nt0ca"},{"post_id":"cj7rorijq0007tcjm4hqcxm0p","tag_id":"cj7rorijx000utcjmutnd6wd6","_id":"cj7rorijy0010tcjm8revgt7x"},{"post_id":"cj7rorijr0008tcjmpubj6npw","tag_id":"cj7rorijx000wtcjmbh71lrqh","_id":"cj7rorijy0011tcjm17wagx9t"},{"post_id":"cj7rorijr0008tcjmpubj6npw","tag_id":"cj7rorijx000ztcjmx9robqx7","_id":"cj7rorijy0012tcjm0wd6ta0u"}],"Tag":[{"name":"量子力学","_id":"cj7rorijn0005tcjmpjfa1sri"},{"name":"物理学","_id":"cj7rorijs000atcjm1a06omuo"},{"name":"经典力学","_id":"cj7roriju000etcjm23hu48bo"},{"name":"科里奥利力","_id":"cj7roriju000itcjmyv6fri79"},{"name":"C++","_id":"cj7rorijv000ktcjm1j4zq8m3"},{"name":"PAT","_id":"cj7rorijv000otcjmd6mm16k2"},{"name":"排序","_id":"cj7rorijw000qtcjmqao7lzus"},{"name":"线性代数","_id":"cj7rorijw000rtcjm596flhs6"},{"name":"数学基础","_id":"cj7rorijx000utcjmutnd6wd6"},{"name":"物理化学","_id":"cj7rorijx000wtcjmbh71lrqh"},{"name":"化学","_id":"cj7rorijx000ztcjmx9robqx7"}]}}